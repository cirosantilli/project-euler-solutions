# Project Euler 711 Solution - Binary Blackboard

<https://projecteuler.net/problem=711>:

* [711.py](711.py)

This repository contains a fast, no-dependencies solution for **Project Euler 711**.

## Key ideas

### 1) Reduce the game to parity only
Each written number contributes `popcount(x)` ones to the blackboard.
Only the **parity** (odd/even) of the total number of ones matters, so each move contributes:

- `t(x) = popcount(x) mod 2`

This is the classic **Thue–Morse parity** function.

The game always ends exactly when the total sum reaches `2n`, i.e. the players write a sequence of positive
integers summing to `n` after the initial `n`.

### 2) A minimax recursion with a useful symmetry
Let the state be `(remaining, current_parity, whose_turn)` and evaluate it with optimal play.
A small but crucial observation is that (because the target parities are opposite for the two players)
the “Eric-to-move” outcome is the logical negation of an “Oscar-to-move” outcome with flipped parity.
This lets the game be expressed with a single recursive predicate.

Another consequence: a position can only be “safe for Eric no matter what Oscar does” when the
current parity matches `t(remaining)`. That is exactly the initial condition, so we only need to study
those states.

### 3) Base‑4 structure (two bits at a time)
When the recursion is unwound, the only way Oscar can move into a similarly “safe” state depends on the
parity difference between `t(remaining - x)` and `t(remaining xor x)`, which is governed by the borrow/carry
structure in binary subtraction.

Grouping bits in pairs (i.e. working in **base 4**) makes the carry/borrow behavior tractable. The set of
winning `n` has a clean base‑4 description:

- either `n = 4^k - 1` (base‑4: `333...3`),
- or `n` is in `[4^k, 2·4^k)` (base‑4 leading digit `1`) and the lower `k` digits contain no `2` and, reading
  from the least significant digit, the **first digit that is not `3` is `0`** (or all are `3`).

This creates offset-sets `B_k` of size `2^k` that can be summed without enumerating elements.

### 4) A linear recurrence for the offset sums
Let `T_k = sum_{b in B_k} b (mod M)`. The base‑4 construction implies a simple recurrence:

- `T_0 = 0`
- `T_{k+1} = 2·T_k + (2^k + 2)·4^k   (mod M)`

We also need prefix sums `sum_{i=0..k} T_i`, which can be accumulated in a single `O(k)` loop.

### 5) Close the remaining sums with geometric series
The final formula for `S(N)` is a combination of:

- geometric sums of powers of `8` (coming from `2^k·4^k`),
- geometric sums of powers of `4` (for the `4^k - 1` terms),
- and the computed prefix sums of `T_k`.

All arithmetic is performed modulo `1_000_000_007`.

## Complexity
For the target `N = 12,345,678`, the loop length is about `N/2`, so the runtime is **O(N)** with only a few
modular operations per iteration, and **O(1)** extra memory.
