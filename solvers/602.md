# Project Euler 602 Solution - Product of Head Counts

<https://projecteuler.net/problem=602>:

* [602.py](602.py)

This solution reduces the probability problem to a single **Eulerian number** computation modulo `1_000_000_007`.

## 1) Turning the process into a formula

Let `p = P(Tails)` and `q = 1 - p`.

- Let `T` be the number of times Alice flips **Tails** before her first **Head**.
  Then `P(T=t) = p^t q` (geometric distribution).

- If `T=t`, each friend flips exactly `t` times.
  Each friend’s head count `H` is `Binomial(t, q)`, so `E[H | T=t] = t q`.

- Alice’s random number is the product of the friends’ head counts:
  `R = ∏ H_i`.
  Given `T=t`, the `H_i` are independent, so:

`E[R | T=t] = ∏ E[H_i | T=t] = (t q)^n`.

Therefore the expected value is:

`e(n,p) = Σ_{t≥0} p^t q (t q)^n = (1-p)^{n+1} Σ_{t≥1} t^n p^t`.

## 2) Eulerian polynomials appear

A classical identity links the power series `Σ t^n p^t` to **Eulerian polynomials**:

`Σ_{t≥1} t^n p^t = p * A_n(p) / (1-p)^{n+1}`

where `A_n(p)` is the Eulerian polynomial and its coefficients are Eulerian numbers `A(n,m)`.

Multiplying by `(1-p)^{n+1}` gives:

`e(n,p) = p * A_n(p)`.

So the coefficient asked by the problem is:

`c(n,k) = [p^k] e(n,p) = A(n, k-1)`.

## 3) Computing one Eulerian number fast (mod prime)

We use the explicit alternating-sum formula:

`A(n,m) = Σ_{j=0..m+1} (-1)^j * C(n+1, j) * (m+1-j)^n  (mod M)`.

To make this efficient for `m ≈ 4,000,000`:

- **Binomial coefficients are updated sequentially**:
  `C(n+1, j+1) = C(n+1, j) * (n+1-j)/(j+1)`.

- Division modulo `M` is done with **precomputed inverses** up to `m+1`.

- Powers `(m+1-j)^n` are computed using Python’s built-in `pow(base, exp, mod)`,
  which is fast (modular exponentiation in C).

This yields an `O(m)` time / `O(m)` memory solution that computes the required coefficient directly.
