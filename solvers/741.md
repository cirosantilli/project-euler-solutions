# Project Euler 741 Solution - Binary Grid Colouring

<https://projecteuler.net/problem=741>:

* [741.py](741.py)

We count `n×n` black/white grids where every row and column contains **exactly two** black cells.

- `f(n)` = number of such grids.
- `g(n)` = number of such grids **up to rotations and reflections** (the dihedral group `D4`).

The program computes:

- `g(7^7) + g(8^8) (mod 1_000_000_007)`


## 1) Graph interpretation

A grid with two black cells in each row and column is the adjacency matrix of a **2-regular simple bipartite graph**
between:

- row-vertices `R1..Rn`
- column-vertices `C1..Cn`

Each black cell `(i,j)` is an edge between `Ri` and `Cj`.

So `f(n)` counts 2-regular bipartite graphs on `n+n` labeled vertices.


## 2) Burnside’s lemma for `g(n)`

`D4` has 8 symmetries:

- identity
- rotations by 90°, 180°, 270°
- 4 reflections (2 axis, 2 diagonal)

Burnside:

`g(n) = (1/8) * Σ Fix(symmetry)`

By conjugacy in `D4`, we only need:

- `Fix(id) = f(n)`
- `Fix(axis)` (vertical = horizontal)
- `Fix(diagonal)` (main diagonal = anti-diagonal)
- `Fix(rot180)`
- `Fix(rot90)` (same as rot270)

So:

`Σ Fix = f + Fix(rot180) + 2*Fix(rot90) + 2*Fix(axis) + 2*Fix(diagonal)`


## 3) Turning generating functions into O(n) recurrences

All fixed-point counts are obtained from compact (exponential) generating functions, then converted into **linear-time**
recurrences that use only O(1) memory.

This is crucial because we need `n = 7^7 = 823543` and `n = 8^8 = 16777216`.


### 3.1 Identity (computing `f(n)`)

A normalized coefficient sequence satisfies a short recurrence that becomes integer-valued after multiplying by `n!`.

We compute an integer sequence `h_n` such that:

`f(n) = n! * h_n`

with:

- `h_0 = 1`, `h_1 = 0`
- `h_{n+1} = n*h_n + (n/2)*h_{n-1}`


### 3.2 Axis reflection

For a reflection across a vertical/horizontal axis:

- if `n` is odd: impossible ⇒ `Fix = 0`
- if `n` is even: `Fix = n! / 2^{n/2}`


### 3.3 180° rotation

After orbit-compression, the counting reduces to extracting one coefficient from:

`E(x) = exp(-x) / sqrt(1-4x)`

We maintain an integer sequence `j_n = n!*[x^n]E(x)` by:

- `j_0=1`, `j_1=1`
- `j_{n+1} = (4n+1) j_n + 4n j_{n-1}`

and combine with `m!` where `m = floor(n/2)` to get `Fix(rot180)`.

For odd `n`, a closely related series `D(x)=2xE(x)/(1-4x)` leads to another integer recurrence.


### 3.4 Diagonal reflection (transpose)

A diagonal-fixed grid is a **symmetric** 0/1 matrix with row sums 2, i.e. a labeled undirected graph (loops allowed)
where every vertex has degree 2 (a loop contributes 1).

Such graphs decompose into:

- cycles (length ≥ 3)
- paths (length ≥ 2) whose endpoints carry loops

This yields an EGF, and from its logarithmic derivative we obtain a direct integer recurrence for `A_n = Fix(diagonal)`:

- `A_0=1, A_1=0, A_2=1, A_3=4`
- for `k ≥ 3`:

`A_{k+1} = 2k*A_k - k(k-2)*A_{k-1} - (k(k-1)(k-2)/2)*A_{k-3}`


### 3.5 90° rotation

For `n` odd, 90°-fixed grids are impossible (black cells come in 4-cycles, but total black cells is `2n`).

For `n=2m` even, the fixed grids correspond to a 2-regular multigraph on `m` labeled vertices, with:

- loops allowed
- between distinct vertices there are **two** edge-types (coming from the two distinct cell-orbits)

The EGF simplifies to:

`(1-2x)^(-1/2) * exp(-x^2/2)`

and gives an integer recurrence for `b_m = Fix(rot90)`:

- `b_0=1, b_1=1, b_2=2`
- for `n ≥ 2`:

`b_{n+1} = (2n+1)b_n - n b_{n-1} + 2n(n-1)b_{n-2}`


## 4) Mod arithmetic

All computations are performed modulo `1_000_000_007`.

Division by small constants uses modular inverses (`1/2` and `1/8`).


## 5) Correctness checks

The code asserts all test values stated in the problem statement:

- `f(4)=90`, `f(7)=3110940`, `f(8)=187530840`
- `g(4)=20`, `g(7)=390816`, `g(8)=23462347`
- `g(7)+g(8)=23853163`
