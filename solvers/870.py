#!/usr/bin/env python3
"""
Project Euler 870 - Stone Game IV

We work with the transition values T(i) described in the problem statement.

Key fact used (from the generalized-base analysis of this game):
For a fixed r>0, the losing initial pile sizes form a (possibly finite) g-base B(r) generated by:

    b0 = 1
    b_{k+1} = b_k + b_i
    where i is the smallest index with floor(r * b_i) >= b_k.

As r varies, the generated sequence only changes when one of the inequalities
crosses an equality boundary. Those boundary points are rational values.

If q is a transition value, then the next transition value after q is the minimum
upper endpoint among the intervals determined while generating B(q). This can be
computed by generating B(q) and tracking the best candidate ratio b_k / b_{i-1}.

No external libraries are used.
"""

from __future__ import annotations

import sys
from math import gcd


TARGET_I = 123456

# How far we generate the g-base while searching for the next transition.
# Empirically this is plenty for the required index and is much faster than
# using an "epsilon-scaled" r = q + tiny.
MAX_STEPS = 3000


def reduce_frac(n: int, d: int) -> tuple[int, int]:
    g = gcd(n, d)
    return n // g, d // g


def frac_lt(an: int, ad: int, bn: int, bd: int) -> bool:
    """Return True iff an/ad < bn/bd with exact integer arithmetic."""
    return an * bd < bn * ad


def g_base(r_num: int, r_den: int, terms: int) -> list[int]:
    """
    Generate the first `terms` elements of the g-base B(r) using
    the defining recurrence with exact integer comparisons.
    """
    b = [1]
    i_ptr = 0

    # local bindings for speed
    rn = r_num
    rd = r_den
    append = b.append

    while len(b) < terms:
        bk = b[-1]
        rhs = bk * rd
        # find smallest i with rn * b[i] >= bk * rd
        while i_ptr < len(b) and rn * b[i_ptr] < rhs:
            i_ptr += 1
        if i_ptr >= len(b):
            break  # finite base
        append(bk + b[i_ptr])
    return b


def next_transition(q_num: int, q_den: int) -> tuple[int, int]:
    """
    Compute the next transition value after q = q_num/q_den (q is assumed to be
    itself a transition value), returning it as a reduced fraction.

    We generate B(q) for a bounded number of steps and track the minimum
    upper endpoint b_k / b_{i-1} among all constraints encountered.
    """
    b = [1]
    i_ptr = 0

    # best upper endpoint so far
    best_num = 0
    best_den = 1
    have_best = False

    qn = q_num
    qd = q_den

    append = b.append

    for _ in range(MAX_STEPS):
        bk = b[-1]
        rhs = bk * qd

        # advance i_ptr until qn*b[i_ptr] >= bk*qd
        while i_ptr < len(b) and qn * b[i_ptr] < rhs:
            i_ptr += 1
        if i_ptr >= len(b):
            break  # shouldn't happen for q >= 1, but safe

        # candidate upper endpoint uses previous term (if it exists)
        if i_ptr > 0:
            cand_num = bk
            cand_den = b[i_ptr - 1]
            if (not have_best) or cand_num * best_den < best_num * cand_den:
                best_num = cand_num
                best_den = cand_den
                have_best = True

        # extend the base
        append(bk + b[i_ptr])

    # For q >= 1 we always find an upper endpoint.
    if not have_best:
        return 1, 1
    return reduce_frac(best_num, best_den)


def transition_value(i: int) -> tuple[int, int]:
    """Return T(i) as a reduced fraction."""
    if i < 1:
        raise ValueError("i must be >= 1")
    q_num, q_den = 1, 1  # T(1) = 1
    for _ in range(1, i):
        q_num, q_den = next_transition(q_num, q_den)
    return q_num, q_den


def format_rounded(num: int, den: int, digits: int = 10) -> str:
    """
    Format num/den rounded to exactly `digits` digits after the decimal point,
    without using floating point.
    """
    ip = num // den
    rem = num % den

    scale = 10 ** (digits + 1)  # extra digit for rounding
    scaled = (rem * scale) // den

    last = scaled % 10
    frac = scaled // 10

    if last >= 5:
        frac += 1
        if frac >= 10**digits:
            ip += 1
            frac -= 10**digits

    return f"{ip}.{frac:0{digits}d}"


def run_tests() -> None:
    # Examples for L(r) in the statement:
    # L(0.5) = {1}
    assert g_base(1, 2, 10) == [1]

    # L(1) = {1, 2, 4, 8, 16, ...}
    assert g_base(1, 1, 6) == [1, 2, 4, 8, 16, 32]

    # L(2) = {1, 2, 3, 5, 8, ...}
    assert g_base(2, 1, 7) == [1, 2, 3, 5, 8, 13, 21]

    # Examples for transition values:
    assert transition_value(1) == (1, 1)
    assert transition_value(2) == (2, 1)

    # T(22) â‰ˆ 6.3043478261 (statement). Exact value implied by that decimal:
    assert transition_value(22) == (145, 23)


def main() -> None:
    run_tests()
    num, den = transition_value(TARGET_I)
    print(format_rounded(num, den, 10))


if __name__ == "__main__":
    main()
