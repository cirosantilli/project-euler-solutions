# Project Euler 661 Solution - A Long Chess Match

<https://projecteuler.net/problem=661>:

* [661.py](661.py)

This repository contains a single-file solution (`main.py`) for **Project Euler 661**.

The program prints **`H(50)` rounded to 4 decimal places** and includes assertions for all numerical examples given in the problem statement.

## Core ideas

### 1) Model the match as a killed random walk
Let the score difference after a game be

- `D = (#A wins) − (#B wins)`

Each game changes `D` by:

- `+1` with probability `pA` (A wins)
- `−1` with probability `pB` (B wins)
- `0` with probability `1 − pA − pB` (draw)

After every game we **record whether A is leading** (i.e. `D > 0`), then the match ends with probability `p` (Heads) or continues with probability `q = 1 − p` (Tails).

So the quantity

\[\mathbb{E}_A(pA,pB,p)\]

is the expected total reward where the per-game reward is `1{D>0}` and the process is *killed* (stopped) geometrically.

### 2) Value function + linear recurrence
Define a value function:

- `V(d)`: expected number of future times A will be leading, **starting from score difference `d` before the next game**.

One step of the Markov chain gives a recurrence of the form

\[c V(d) - a V(d+1) - b V(d-1) = R(d)\]

with constants

- `a = q·pA`
- `b = q·pB`
- `c = p + q·(pA+pB)`

and where `R(d)` depends only on whether the post-game state is positive.

For all `d ≥ 2`, `R(d)=1` and for all `d ≤ −1`, `R(d)=0`, so away from `{0,1}` the recurrence has constant coefficients and can be solved using the **characteristic equation**.

### 3) Solve the infinite system using boundary conditions at ±∞
The homogeneous recurrence has characteristic polynomial

\[a r^2 - c r + b = 0\]

with two real positive roots:

- `r1 < 1` (decays as `d → +∞`)
- `r2 > 1` (decays as `d → −∞` when used as `r2^d`)

Because the match terminates geometrically, `V(d)` is bounded and approaches:

- `1/p` as `d → +∞` (A is essentially always leading)
- `0` as `d → −∞`

Matching the solutions across the boundary layer at `d = 0,1` yields a compact closed form:

\[\boxed{\;V(0) = \Big(\frac{1}{p} + \frac{1}{q}\Big)\,\frac{1-r_1}{r_2-r_1}\;}\]

and

\[\mathbb{E}_A(pA,pB,p) = V(0).\]

This avoids any simulation or large dynamic programming tables.

### 4) Compute \(H(50)\)
For each `k = 3..50`, we plug in:

- `pA = 1/sqrt(k+3)`
- `pB = 1/sqrt(k+3) + 1/k^2`
- `p  = 1/k^3`

compute `E_A` using the closed form above, and sum.

## Numerical stability
The code computes the larger root directly and uses `r1*r2 = b/a` to get the smaller root:

- `r2 = (c + sqrt(c² − 4ab)) / (2a)`
- `r1 = (b/a) / r2`

This is more stable than subtracting nearly equal numbers in `(c − sqrt(...)) / (2a)`.

## Complexity
For each `k` we do **O(1)** arithmetic, so total runtime is tiny.

## How to run

```bash
python3 main.py
```

It prints the answer as a single line with 4 digits after the decimal point.
