# Project Euler 492 Solution - Exploding Sequence

<https://projecteuler.net/problem=492>:

* [492.py](492.py)

This solution computes:

- B(10^9, 10^7, 10^15)

where:

- a1 = 1
- a(n+1) = 6*a(n)^2 + 10*a(n) + 3
- B(x,y,n) = sum(a_n mod p) over all primes p with x <= p <= x+y

## Main techniques

### 1) Linear change of variables
Define:

    u_n = 6*a_n + 5

Then the recurrence becomes:

    u_{n+1} = u_n^2 - 2

This polynomial is special: if u = 2*cos(theta) then u^2 - 2 = 2*cos(2*theta).
That is, iterating u_{n+1} = u_n^2 - 2 corresponds to repeatedly doubling an "angle".

### 2) Lucas sequence interpretation
Let V_k be the Lucas V-sequence for parameters (P,Q) = (11,1):

    V_0 = 2
    V_1 = 11
    V_{k+1} = P*V_k - V_{k-1}

One can show:

    u_n = V_{2^{n-1}}

So we need V_{2^{n-1}} modulo many primes p.

### 3) Reducing the huge index modulo p-1 or p+1
Write the Lucas closed form using roots alpha, beta with alpha*beta = Q = 1.
Depending on whether the discriminant D = P^2 - 4 = 117 is a quadratic residue mod p,
alpha lives in GF(p) or GF(p^2), and its multiplicative order divides:

- p-1 if D is a residue
- p+1 if D is a non-residue

Therefore V_k mod p only depends on k modulo M = p - (D/p).
Here 117 = 3^2 * 13 and 13 == 1 (mod 4), so (D/p) = (13/p) = (p mod 13 / 13),
which can be decided by a small lookup table of residues modulo 13.

So for each prime p we compute:

    e = 2^{n-1} mod M
    u_n mod p = V_e mod p
    a_n mod p = (u_n - 5) / 6 mod p

### 4) Fast doubling for Lucas sequences
To compute V_e mod p quickly, we compute (U_e, U_{e+1}) with a fast-doubling method,
where U_k is the companion Lucas U-sequence:

    U_0 = 0
    U_1 = 1
    U_{k+1} = P*U_k - U_{k-1}

For Q=1 there is a simple relation:

    V_k = 2*U_{k+1} - P*U_k

The code uses an iterative bit-scan (like Fibonacci fast doubling), giving O(log e)
work per prime (about 30 iterations).

### 5) Segmented sieve for primes in [10^9, 10^9+10^7]
The interval has length 10^7, so we generate primes using a segmented sieve:

- compute all base primes up to sqrt(high)
- mark their multiples in a bytearray representing only odd numbers
- iterate the remaining unmarked entries as primes

This keeps memory small and runs quickly.

## Files

- main.py: computes and prints the required answer, and includes asserts for all sample values.
- README.md: this explanation.
