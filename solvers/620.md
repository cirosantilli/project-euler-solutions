# Project Euler 620 Solution - Planetary Gears

<https://projecteuler.net/problem=620>:

* [620.py](620.py)

This repository contains a fast, single-threaded solution in pure Python (standard library only).

## Core ideas

### 1) Replace “find all configurations” with “count integers in an interval”
For fixed integers `(s, p, q)` (and `c = s+p+q`), the geometry still allows a *continuous* degree of freedom: the offset between the centers of the inner gear `S` and the outer gear `C` (bounded by the requirement that their boundaries stay at least 1 cm apart).

Perfect meshing is stronger than tangency: the gear teeth must stay aligned as the system rotates. That constraint can be written as a single “phase balance” expression built from arc-lengths on the involved circles. When this expression is required to be an integer, the valid configurations become *discrete*.

As the center offset varies, that phase expression changes monotonically and sweeps an interval `[D_min, D_max)`. Therefore:

- each integer in the interval corresponds to exactly one valid arrangement;
- the number of arrangements is simply the count of integers in that interval.

So for each `(s,p,q)` we compute:
`g = floor(D_max - D_min)`.

### 2) Endpoints come from extreme offsets
- `D_max` occurs at the degenerate limiting position where equal-size planets coincide (excluded because planets must be distinct).
- `D_min` occurs when the boundaries of `S` and `C` are exactly 1 cm apart (allowed).

This avoids any search over offsets.

### 3) Trigonometry with a single triangle (law of cosines)
At the extreme where the gap is 1 cm, angles needed for the arc-length expression can be read from a triangle formed by the centers of:
- the outer gear `C`,
- the inner gear `S`,
- one planet of size `p`.

To reduce clutter, lengths are scaled by `2π`, turning radii into circumferences. With that scaling, the triangle side lengths become:
- `s+q`, `s+p`, and `(p+q) - 2π`.

Two angles from this triangle (`alpha`, `beta`) are enough to compute the interval length, leading to a compact formula:

`g = floor((alpha*(p+s) + beta*(p+q+2s)) / π)`.

### 4) Numerical robustness
Floating arithmetic is used only for `acos` and a small number of operations per triple. Two small precautions make it safe:

- Clamp cosine values into `[-1,1]` before calling `acos` to avoid domain errors.
- Add a tiny `EPS` before truncating to an integer to protect against rare negative rounding drift.

## Files

- `main.py`: computes `G(500)` and prints it, and asserts the sample values from the statement.
- `README.md`: this explanation.
