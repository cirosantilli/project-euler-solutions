# Project Euler 846 Solution - Magic Bracelets

<https://projecteuler.net/problem=846>:

* [846.py](846.py)

A **magic bracelet** is a cyclic arrangement of distinct allowed integers where the product of adjacent beads is always of the form:

\[
ab = x^2 + 1
\]

Rotations and reflections are considered the same bracelet. The **potency** is the sum of bead values, and the task is to compute:

\[
F(N) = \sum_{\text{bracelets using values }\le N} \text{potency}
\]

This repository contains a pure-Python solution (no external libraries) that prints `F(10^6)` and asserts the two given sample values.

## Core ideas used

### 1) Graph model
- Each allowed value `v` (≤ N) is a **vertex**.
- An undirected **edge** `a—b` exists if `a*b - 1` is a perfect square, i.e. `a*b = x^2 + 1`.
- A bracelet is exactly a **simple cycle** of length ≥ 3 in this graph.
- “Same up to rotation/reflection” means we count each undirected cycle once.

### 2) Number theory pruning
If an odd prime `p` divides `x^2 + 1`, then:

\[
x^2 \equiv -1 \pmod p
\]

This is only possible when `p ≡ 1 (mod 4)`.  
So primes `≡ 3 (mod 4)` never appear in any `x^2+1` factorization and can be ignored entirely.

Also, `x^2+1` is **never divisible by 4**, so it has at most one factor of 2. This implies:
- there are **no even-even edges** in the graph.

### 3) Efficient edge generation via modular square roots
Instead of checking all pairs `(a,b)`, we generate edges by fixing an odd node `a` and enumerating all `x` such that:

\[
x^2 \equiv -1 \pmod a
\]

For `a = p^k` (with `p ≡ 1 (mod 4)`), there are exactly two residues modulo `p^k`.
We compute a square root of `-1 mod p` using **Tonelli–Shanks**, then lift it to `p^k` using **Hensel lifting**.

For each solution `x`, we compute:

\[
b = \frac{x^2 + 1}{a}
\]

and keep the edge if `b` is allowed and `b ≤ N`.

### 4) Cycle counting without exploding search
Naively enumerating cycles in a large sparse graph can still be slow. Two classic graph techniques make it fast:

- **2-core pruning:** iteratively remove all vertices of degree `< 2`.  
  All cycles lie entirely inside the remaining subgraph.

- **Biconnected components (Tarjan):** every simple cycle is contained in exactly one biconnected component (“block”).  
  We decompose into blocks and enumerate cycles *inside each block only*, avoiding huge cross-component backtracking.

### 5) Counting each bracelet once (rotation + reflection)
Within a block, cycles are enumerated with a canonical rule:
- require the **smallest vertex** of the cycle to be the start vertex
- break reflection symmetry by accepting the direction only when `second_vertex < last_vertex`

When a block is itself just a simple cycle (all block-degrees are 2 and `|E|=|V|`), we add its potency directly.

## Running
Just run:

```bash
python3 main.py
It will:

assert the given examples F(20)=258 and F(100)=538768

print F(10^6)
