# Project Euler 108 Solution - Diophantine Reciprocals I

<https://projecteuler.net/problem=108>:

* [108.py](108.py)

We need the least positive integer `n` such that the number of distinct positive integer solutions `(x, y)` (counted without order, i.e. `x <= y`) to:

\[
\frac{1}{x} + \frac{1}{y} = \frac{1}{n}
\]

exceeds 1000.

## Key transformation

Rearrange:

\[
\frac{1}{x} + \frac{1}{y} = \frac{1}{n}
\;\Longrightarrow\;
xy - nx - ny = 0
\;\Longrightarrow\;
(x-n)(y-n) = n^2
\]

Since solutions require `x > n` and `y > n`, we set:

- `a = x - n > 0`
- `b = y - n > 0`

So `ab = n^2`. Each factor pair `(a, b)` corresponds to a solution `(x, y)`.

## Counting solutions via divisors

Let `d(m)` be the number of positive divisors of `m`. The number of unordered factor pairs `(a, b)` with `a*b = n^2` equals:

\[
\frac{d(n^2)+1}{2}
\]

because `n^2` is a perfect square, so `d(n^2)` is odd.

We need:

\[
\frac{d(n^2)+1}{2} > 1000 \;\Longleftrightarrow\; d(n^2) > 1999
\]

So it suffices to find the smallest `n` with `d(n^2) >= 2000` (since `d(n^2)` is always odd).

## Minimizing `n` by searching prime exponents

If:

\[
n = \prod p_i^{a_i}
\]

then:

\[
d(n^2) = \prod (2a_i + 1)
\]

We perform a DFS over exponent choices `a_i` for increasing primes, enforcing non-increasing exponents (`a_1 >= a_2 >= ...`) which is a standard minimization trick: larger exponents should be assigned to smaller primes to keep `n` minimal.

The DFS prunes any branch whose partial `n` already exceeds the best solution found so far.

The program prints the minimal `n`.
