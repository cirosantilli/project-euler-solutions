# Project Euler 580 Solution - Squarefree Hilbert Numbers

<https://projecteuler.net/problem=580>:

* [580.py](580.py)

This solution counts **squarefree Hilbert numbers** up to `N = 10^16` (a *Hilbert number* is `n ≡ 1 (mod 4)`).

A Hilbert number `n` is **squarefree** (in the sense of the problem) if there is **no** Hilbert number `h > 1` such that `h² | n`.

---

## 1) Key characterization

Let `χ` be the non-principal Dirichlet character mod 4:

- `χ(n) = 0` if `n` is even
- `χ(n) = 1` if `n ≡ 1 (mod 4)`
- `χ(n) = -1` if `n ≡ 3 (mod 4)`

For odd `n`, `χ(n)` depends only on the parity of the total exponent of primes `≡ 3 (mod 4)`.

A number `n ≡ 1 (mod 4)` fails the problem’s “squarefree” condition **iff** it has a square divisor `d²` with `d ≡ 1 (mod 4)`.

From this, one can show:

- If any prime `q ≡ 1 (mod 4)` appears with exponent ≥ 2, then `q² | n` with `q ≡ 1`, forbidden.
- If two different primes `p, r ≡ 3 (mod 4)` both have exponent ≥ 2, then `(pr)² | n` with `pr ≡ 1`, forbidden.
- If a prime `p ≡ 3 (mod 4)` has exponent ≥ 4, then `(p²)² | n` with `p² ≡ 1`, forbidden.

So every valid `n` is either:

1. **Squarefree** (ordinary squarefree) and `n ≡ 1 (mod 4)`, or
2. `n = p² · s` where `p ≡ 3 (mod 4)` is prime and `s` is **squarefree** and `s ≡ 1 (mod 4)`.

This leads to the clean counting identity:

\[
C(N)=SQ1(N)+\sum_{\substack{p\ \text{prime}\\p\equiv 3\ (4)\\p^2\le N}} SQ1\!\left(\left\lfloor\frac{N}{p^2}\right\rfloor\right)
\]

where `SQ1(x)` counts squarefree integers `≤ x` that are `≡ 1 (mod 4)`.

---

## 2) Counting `SQ1(x)` fast

For odd squarefree numbers, `χ(n)=±1`, so:

- `O(x)` = number of **odd squarefree** `≤ x`
- `T(x)` = sum of `χ(n)` over odd squarefree `n ≤ x`

Then:

\[
SQ1(x)=\frac{O(x)+T(x)}{2}
\]

Using Möbius inversion for squarefree indicator:

- `μ²(n) = Σ_{d²|n} μ(d)`

and the fact that only **odd** `d` can contribute to odd numbers, both `O(x)` and `T(x)` become sums over `μ(d)` with `d ≤ √x`.

To make this fast, the implementation uses a standard trick:

- Split the `d`-sum at `D = ⌊x^{1/3}⌋`
- For `d ≤ D`: sum directly
- For `d > D`: the quotient `q = ⌊x/d²⌋` is small, so group all `d` that share the same `q`

This reduces the work to **O(x^{1/3})** per `SQ1(x)`.

---

## 3) Fast Mertens queries (Du Jiao sieve)

The grouped tail needs interval sums of `μ(d)`:

- `M(n) = Σ_{k≤n} μ(k)` (Mertens function)

`M(n)` is computed on-demand for large `n` using the **Du Jiao sieve** recurrence with memoization, requiring only a small pre-sieve of `μ` up to about `3×10^5`.

For “odd-only” sums, the identity is used:

\[
\sum_{\substack{k\le n\\k\ \text{odd}}}\mu(k)=\sum_{j\ge 0} M\!\left(\left\lfloor\frac{n}{2^j}\right\rfloor\right)
\]

so no separate odd-μ sieve is needed.

---

## 4) Summing over primes up to `√N`

The prime sum needs primes `p ≡ 3 (mod 4)` up to `√N = 10^8`.

This is done in two parts:

- For small primes `p ≤ ⌊N^{1/3}⌋` (≈ 2.15×10^5): compute each term with the `SQ1(x)` routine.
- For large primes `p > ⌊N^{1/3}⌋`: the quotient `⌊N/p²⌋` is small (≈ ≤ `N^{1/3}`), so we precompute a tiny prefix table of `SQ1` values and use a **segmented sieve** to stream primes up to `10^8` without storing them.

---

## 5) Built-in check

The program includes the problem statement’s verification:

- `C(10^7) = 2327192`

as an `assert` in `main()`.

---
