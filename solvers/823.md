# Project Euler 823 Solution - Factor Shuffle

<https://projecteuler.net/problem=823>:

* [823.py](823.py)

This repository contains a single-file Python solution (`main.py`) for computing:

- `S(n, m)`: the sum of the numbers remaining after `m` rounds of the “factor shuffle” process
- the final answer requested by the problem is `S(10^4, 10^16) mod 1234567891`

## Core ideas

### 1) Work with prime factors instead of large integers
Every number in the list is represented by its prime factors in nondecreasing order.  
One round becomes:

- remove the first (smallest) factor from every list
- those removed primes form a new list (sorted) that is appended
- lists that become empty are dropped

Because all prime factors originate from `2..n`, every factor is `<= n`, so we never have to store gigantic integers while simulating.

### 2) The lengths behave like Bulgarian solitaire
If you ignore the actual prime values and only track how many prime factors each list has, the move is exactly:

- subtract `1` from every positive pile
- create a new pile of size “number of piles”

That classical process is known to reach a structured repeating regime quickly. Here it acts as a guide for how many prime factors exist in the newly created number.

### 3) Column periodicity for the k-th prime factor
Let `x(t, k)` be the `k`-th smallest prime factor of the number **added** at round `t` (or `1` if it has fewer than `k` factors).

After a transient, the simulation reaches a state where for every relevant `k`:

- `x(t, k) = x(t - k, k)` for all future `t`

So each “column” `k` becomes purely periodic with period `k`.  
The code detects this by watching when each column buffer rotates perfectly for many consecutive rounds.

### 4) Jump to huge `m` using the short cycles
Once the per-column cycles are known, `x(t, k)` for an enormous `t` can be read by a single modular index.

After `m` rounds, every surviving number is a suffix of a recently-added number:
the one added at round `m - d` has been divided `d` times, so it equals the product of its prime factors from positions `d+1` onward (empty products do **not** contribute, because those numbers are removed as `1`).

We only need `O(K^2)` cycle lookups, where `K` is about `sqrt(2 * total_prime_factors)` (around a few hundred for `n = 10^4`).

## What the program does

1. Sieve smallest prime factors up to `n` and build factor lists for `2..n`.
2. Simulate rounds on factor lists until the per-column rotation condition is stable.
3. Use the discovered cycles to compute `S(n, m) mod 1234567891` for huge `m`.

The example values from the statement are asserted in `main.py`.
