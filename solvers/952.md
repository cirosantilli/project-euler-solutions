# Project Euler 952 Solution - Order Modulo Factorial

<https://projecteuler.net/problem=952>:

* [952.py](952.py)

This solution computes the multiplicative order

\[ R(p,n) = \min\{r\ge 1 : p^r \equiv 1 \pmod{n!}\} \]

for the specific Euler query `p = 10^9 + 7`, `n = 10^7`, and outputs the result **modulo** `10^9 + 7`.

## Main ideas

### 1) Reduce the problem to prime powers
Since

\[ n! = \prod_{q \le n} q^{\nu_q(n!)} \]

and `p` is prime with `n < p`, we have `gcd(p, n!) = 1`. The order modulo a product is the least common multiple of the orders modulo each prime power:

\[ R(p,n) = \operatorname{lcm}_{q \le n} \; \operatorname{ord}_{q^{\nu_q(n!)}}(p). \]

So the task becomes:

* for each prime `q ≤ n`, compute `a = ν_q(n!)`
* compute the order of `p` modulo `q^a`
* take the LCM across all these orders

### 2) Use LCM via “maximum prime exponents”
Instead of forming the (astronomically large) LCM directly, we maintain an array `max_exp[ℓ]`:

* `max_exp[ℓ]` is the largest exponent of prime `ℓ` that appears in any of the prime-power orders.

Then

\[ R(p,n) = \prod_{\ell \le n} \ell^{\max\_exp[\ell]} \]

and we can compute this product **modulo** `p` using modular exponentiation.

### 3) Order modulo an odd prime and factor updates
For an odd prime `q`, the order modulo `q` divides `q−1`.

* Factor `q−1` using a precomputed smallest-prime-factor table.
* Start with `r = q−1` and repeatedly try dividing by each prime factor `f`:
  * if `p^{r/f} ≡ 1 (mod q)`, then the true order still divides `r/f`, so we reduce `r`.

At the end, `r = ord_q(p)`. During this reduction we also know the remaining exponent of each factor `f` in `r`, so we can update `max_exp[f]` without refactoring.

### 4) Lift the order from `q` to `q^a`
Let `r0 = ord_q(p)`. Define

\[ s = \nu_q(p^{r0} - 1). \]

For odd `q`, standard lifting facts imply:

* if `a ≤ s` then the order modulo `q^a` is still `r0`
* if `a > s` then the order gains an extra factor `q^{a-s}`

So

\[ \operatorname{ord}_{q^a}(p) = r0 \cdot q^{\max(0, a-s)}. \]

In practice `s` is usually very small; the code finds it by checking whether `p^{r0} ≡ 1` modulo `q^2`, `q^3`, … until it fails (or until reaching `a`).

### 5) Special handling for `2^a`
The multiplicative group modulo `2^k` is not cyclic for `k≥3`, so the odd-prime method doesn’t apply directly.

For odd `p`, the order modulo `2^k` is always a power of two. The code computes the exponent `t` such that:

\[ \operatorname{ord}_{2^k}(p) = 2^t \]

using 2-adic valuation identities (an LTE-based formula), without ever constructing `2^k`.

### 6) Fast preprocessing: smallest prime factors
Factoring `q−1` for every prime `q ≤ n` is the main repeated operation.

A linear sieve builds:

* the list of primes up to `n`
* `spf[x]` = smallest prime factor for every `x ≤ n`

This makes each factorization of `q−1` essentially `O(log q)`.

## Output

The script prints the required value `R(10^9 + 7, 10^7) mod (10^9 + 7)`.
