# Project Euler 692 Solution - Siegbert and Jo

<https://projecteuler.net/problem=692>:

* [692.py](692.py)

## Key observation: Fibonacci structure

Define Fibonacci numbers with:

- `F1 = 1`, `F2 = 2`
- `F(k+1) = F(k) + F(k-1)`

For this game, the “interesting” structure shows up at these Fibonacci numbers and the ranges between them.

### 1) What `H(N)` really is

If you write `N` in its **Zeckendorf decomposition** (a greedy sum of non‑consecutive Fibonacci numbers),
then:

> `H(N)` equals the **smallest Fibonacci term** appearing in that decomposition.

Equivalently, if `F` is the largest Fibonacci number `<= N`, then:

- `H(F) = F`
- and for `F < N < next_F`, we have `H(N) = H(N − F)`

This induces the visible “self‑similar” repetition of `H` values between consecutive Fibonacci numbers.

The code computes `H(N)` by repeatedly subtracting the largest Fibonacci `<=` the remaining value; the
last subtracted term is the smallest term of the decomposition.

## Fast prefix sums for `G(n)`

We need:

`G(n) = sum_{k=1..n} H(k)`

Direct summation is impossible for `n ≈ 2×10^16`, so we exploit the Fibonacci interval recursion.

Let:

- `S[i] = G(F(i) − 1)` (the sum up to just before a Fibonacci boundary)

From the interval structure:

- numbers `F(i) + t` (for the valid range of `t`) contribute `H(t)`,
- and `H(F(i)) = F(i)`,

so we get:

`S[i+1] = S[i] + F(i) + S[i-1]`

This lets us precompute all needed `S[i]` in `O(#fibs)`.

For an arbitrary `n`, let `F` be the largest Fibonacci number `<= n`. Then:

`G(n) = G(F − 1) + H(F) + G(n − F) = S[F_index] + F + G(n − F)`

The remainder `n − F` is strictly smaller than the next lower Fibonacci number, so repeating this
reduces `n` quickly (in about `O(log n)` steps). A small memo table avoids repeated work.

## Complexity

- Building Fibonacci numbers: `O(log n)`
- Precomputing boundary sums: `O(log n)`
- Computing `G(n)`: `O(log n)` time, `O(log n)` memory

No external libraries are used.
