# Project Euler 283 Solution - Integer Sided Triangles with Integral Area/perimeter Ratio

<https://projecteuler.net/problem=283>:

* [283.py](283.py)

## Core Observation (Geometry → Number Theory)

For any triangle:

- `Area = r * s`, where `r` is the inradius and `s` is the semiperimeter.
- `Perimeter = 2s`

So:

\[
\frac{Area}{Perimeter} = \frac{r s}{2 s} = \frac{r}{2}
\]

Therefore, the condition “Area/Perimeter is an integer `k`” becomes:

- `r = 2k` is an **even integer**
- and `k ≤ 1000` implies `r ≤ 2000`

So the problem becomes:

> Sum perimeters of all integer-sided triangles whose **inradius** is an even integer ≤ 2000.

---

## Tangency / Semiperimeter Variables

Define:

\[
x = \frac{a+b-c}{2},\quad
y = \frac{a-b+c}{2},\quad
z = \frac{-a+b+c}{2}
\]

Then:

- `a = x+y`, `b = x+z`, `c = y+z`
- `Perimeter = 2(x+y+z)`

Using Heron + inradius identity:

\[
r^2(x+y+z) = xyz
\]

Let `n = r²`. Then:

\[
n(x+y+z)=xyz
\]

---

## Ordering + Critical Bound

Assume canonical ordering:

\[
x \le y \le z
\]

Because `z ≥ x,y` we have:

\[
x+y \le 2z \Rightarrow x+y+z \le 3z
\]

Plugging into `xyz = n(x+y+z)`:

\[
xyz \le 3nz \Rightarrow xy \le 3n
\]

This is the crucial finiteness/efficiency bound:  
**for each `n`, valid pairs satisfy `xy ≤ 3n`.**

Also define:

\[
d = xy-n
\]

Since `xy ≤ 3n`, we get:

\[
d = xy-n \le 2n
\]

So `d` always lies in the small interval `1..2n`.

---

## Divisibility Trick (Avoid Scanning y)

We use:

\[
z = \frac{n(x+y)}{xy-n} = \frac{n(x+y)}{d}
\]

Thus `d` must divide `n(x+y)`.

Also `d = xy-n`.

A key elimination:

- `d | n(x+y)`  
- `d | (xy-n)`

Combine them to remove `y`, giving:

\[
d \mid n(x^2+n)
\]

So for each `(n,x)`, we enumerate divisors:

- `d` dividing `n(x²+n)`
- with `d ≤ 2n`

Then recover:

\[
y=\frac{n+d}{x}
\]

and check if `z` is integral and `z ≥ y`.

This transforms a huge search into manageable divisor enumeration.

---

## Implementation Techniques

✅ **Smallest Prime Factor Sieve (SPF)**  
Used to factor many values quickly (`≤ 16,000,000`) while looping.

✅ **Prime-factor merge**  
Factor `n` once per radius, factor `x²+n` per `x`, merge exponents.

✅ **Bounded divisor generation**  
Generate divisors of `n(x²+n)` only up to `2n`.

✅ **Canonical ordering (x ≤ y ≤ z)**  
Ensures each triangle counted once.

---

## Correctness Checks Included

The code asserts the statement examples:

- `(6,8,10)` has ratio `1`
- `(13,14,15)` has ratio `2`

Also includes an extra known checkpoint:

- `k ≤ 100` → sum `289620027474`

---

## Output

Running `python3 main.py` prints the Euler 283 answer (for `k ≤ 1000`).
