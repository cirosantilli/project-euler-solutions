# Project Euler 862 Solution - Larger Digit Permutation

<https://projecteuler.net/problem=862>:

* [862.py](862.py)

## Key ideas

### 1) Group by digit multiset
Every *k*-digit number belongs to a unique digit multiset (counts of digits `0..9`).
For a fixed multiset, consider the set of all **distinct** permutations that form a valid *k*-digit number (no leading zero).
Let this set have size **M**.

### 2) Turn the “count larger permutations” sum into pair counting
For each number `n` in that set, `T(n)` is “how many other numbers in the same set are larger than `n`”.
If you sum `T(n)` over **all** `n` in the set, each unordered pair of distinct numbers contributes exactly `1` (the smaller counts the larger).
Therefore:

- Sum of `T(n)` over that multiset = `C(M, 2) = M*(M-1)/2`.

So we never need ranks or comparisons between individual permutations.

### 3) Compute M with a multinomial coefficient (and remove leading-zero cases)
Let the digit counts be `d0..d9` with `d0 + ... + d9 = k`.

- Total distinct permutations (allowing leading zero) is:
  `P = k! / (d0! d1! ... d9!)`
- Permutations with a leading zero (only if `d0 > 0`) are:
  `P0 = (k-1)! / ((d0-1)! d1! ... d9!)`

Thus the number of **valid** *k*-digit permutations is:

`M = P - P0 = (k-d0) * (k-1)! / (d0! d1! ... d9!)`.

### 4) Enumerate digit-count vectors, not numbers
For `k = 12`, the number of digit-count vectors is `C(12+9, 9) = 293,930`, which is tiny compared to `9*10^11` twelve-digit numbers.
We enumerate all count vectors via recursion (compositions of `k` into 10 parts), compute `M`, and add `M*(M-1)/2`.

## Implementation details

- Precompute factorials up to `k`.
- Enumerate `d0` from `0..k`, then distribute the remaining `k-d0` across digits `1..9`.
- Use Python big integers (built-in) to keep the arithmetic exact.
- Include the statement-provided checks as assertions:
  - `T(2302) = 4`
  - `S(3) = 1701`
