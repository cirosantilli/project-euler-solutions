#!/usr/bin/env python3
"""
Project Euler 835 - Supernatural Triangles

A Pythagorean triangle is called supernatural if two of its three sides
are consecutive integers.

We need S(N): the sum of perimeters of all distinct supernatural triangles
with perimeter <= N. Finally compute S(10^(10^10)) mod 1234567891.

No external libraries are used.
"""

import math

MOD = 1234567891


# ----------------- basic modular helpers -----------------


def egcd(a: int, b: int):
    """Extended GCD: returns (g, x, y) with ax + by = g = gcd(a,b)."""
    x0, y0, x1, y1 = 1, 0, 0, 1
    while b:
        q = a // b
        a, b = b, a - q * b
        x0, x1 = x1, x0 - q * x1
        y0, y1 = y1, y0 - q * y1
    return a, x0, y0


def modinv(a: int, m: int = MOD) -> int:
    g, x, _ = egcd(a % m, m)
    if g != 1:
        raise ValueError("inverse does not exist")
    return x % m


INV3 = modinv(3, MOD)


# ----------------- family B: hypotenuse and leg are consecutive -----------------
#
# If c = b + 1 then a^2 + b^2 = (b+1)^2 => a^2 = 2b + 1, so a is odd.
# Put a = t (odd), b = (t^2 - 1)/2, c = (t^2 + 1)/2, perimeter P = t(t+1).
#
# For N = 10^(2M), the largest t with t(t+1) <= N is t = 10^M - 1 (odd).
# We must sum P = t^2 + t over all odd t in [3, 10^M-1] modulo MOD.


def sum_family_B_for_power10_exponent(E: int) -> int:
    """
    Returns the sum of perimeters for family B with P=t(t+1) over odd t>=3
    such that P <= 10^E, computed modulo MOD.

    This specialized routine is for the specific N in the problem:
    N = 10^(10^10), where E = 10^10 is even.
    """
    if E % 2 != 0 or E < 2:
        raise ValueError("This helper expects an even exponent E >= 2.")
    M = E // 2

    # Odd t from 1..(10^M-1): count n = 10^M / 2 = 5 * 10^(M-1).
    # We only need n modulo MOD.
    n = (5 * pow(10, M - 1, MOD)) % MOD

    n2 = (n * n) % MOD
    n3 = (n2 * n) % MOD

    # Sum_{odd t<=2n-1} t = 1+3+...+(2n-1) = n^2
    sum_t_all = n2

    # Sum_{odd t<=2n-1} t^2 = (4n^3 - n) / 3
    sum_t2_all = ((4 * n3 - n) % MOD) * INV3 % MOD

    # Remove the t=1 term (t + t^2 = 2) and also exclude degenerate t=1 overall.
    # Desired range is t>=3, so subtract (1^2 + 1) = 2.
    return (sum_t_all + sum_t2_all - 2) % MOD


# ----------------- family A: the legs are consecutive -----------------
#
# Let legs be a, a+1. Then a^2 + (a+1)^2 = c^2 => (2a+1)^2 - 2c^2 = -1.
# Put x = 2a+1, y = c, so x^2 - 2y^2 = -1.
#
# Solutions are generated by multiplying by (3 + 2*sqrt(2)):
# (x_{k+1}, y_{k+1}) = (3x_k + 4y_k, 2x_k + 3y_k).
# The perimeter is P_k = x_k + y_k.
#
# The sequence P_k satisfies:
#   P_{k+2} = 6*P_{k+1} - P_k,  with P_0=2 (degenerate), P_1=12 (3-4-5).
#
# We need sum_{k=1..n} P_k modulo MOD, where n is the largest index with P_n <= 10^E.
# n is around 1e10, so we use matrix exponentiation (O(log n)).


def pell_max_index_for_power10_exponent(E: int) -> int:
    """
    Find the largest n >= 1 such that P_n <= 10^E, where:
        P_0=2, P_1=12, P_{n+2}=6P_{n+1}-P_n.

    For huge E we cannot build 10^E, so we compare in log10 space using
    the closed-form root alpha = 3+2*sqrt(2).
    """
    alpha = 3.0 + 2.0 * math.sqrt(2.0)
    A = (4.0 + 3.0 * math.sqrt(2.0)) / 4.0  # coefficient of alpha^n in P_n

    log10_alpha = math.log10(alpha)
    log10_A = math.log10(A)

    # P_n is extremely close to A * alpha^n for large n, so digit-length comparisons
    # reduce to log10_A + n*log10_alpha < E.
    x = (E - log10_A) / log10_alpha
    n = int(x)  # floor

    def approx_log10_P(k: int) -> float:
        return log10_A + k * log10_alpha

    # Adjust a few steps to be safe against floating rounding.
    while n > 0 and approx_log10_P(n) >= E:
        n -= 1
    while approx_log10_P(n + 1) < E:
        n += 1

    return n if n >= 1 else 0


def mat_mul(A, B, mod: int):
    """Matrix multiplication (small sizes), all entries reduced modulo mod."""
    r, k, c = len(A), len(A[0]), len(B[0])
    out = [[0] * c for _ in range(r)]
    for i in range(r):
        Ai = A[i]
        for t in range(k):
            a_it = Ai[t]
            if a_it:
                Bt = B[t]
                for j in range(c):
                    out[i][j] = (out[i][j] + a_it * Bt[j]) % mod
    return out


def mat_pow(M, e: int, mod: int):
    """Fast exponentiation of a square matrix M^e modulo mod."""
    n = len(M)
    # identity
    R = [[0] * n for _ in range(n)]
    for i in range(n):
        R[i][i] = 1

    base = [row[:] for row in M]
    while e > 0:
        if e & 1:
            R = mat_mul(R, base, mod)
        base = mat_mul(base, base, mod)
        e >>= 1
    return R


def sum_family_A(n: int) -> int:
    """Return sum_{k=1..n} P_k modulo MOD."""
    if n <= 0:
        return 0
    if n == 1:
        return 12 % MOD

    # State v_k = [P_k, P_{k-1}, S_k]^T, where S_k = sum_{i=1..k} P_i.
    # Update:
    #   P_{k+1} = 6P_k - P_{k-1}
    #   P_k     = P_k
    #   S_{k+1} = S_k + P_{k+1}
    A = [
        [6, MOD - 1, 0],
        [1, 0, 0],
        [6, MOD - 1, 1],
    ]

    v1 = [[12], [2], [12]]  # k=1
    P = mat_pow(A, n - 1, MOD)
    vn = mat_mul(P, v1, MOD)
    return vn[2][0] % MOD


# ----------------- small-N brute force for given examples -----------------


def S_bruteforce(N: int) -> int:
    """Bruteforce S(N) for small N, used only for the problem statement asserts."""
    total = 0

    # Family B
    t = 3
    while True:
        per = t * (t + 1)
        if per > N:
            break
        total += per
        t += 2

    # Family A (Pell)
    p0, p1 = 2, 12  # P_0, P_1
    while p1 <= N:
        total += p1
        p0, p1 = p1, 6 * p1 - p0

    # Overlap: (3,4,5) perimeter 12 appears in both families
    if N >= 12:
        total -= 12

    return total


def main():
    # Examples from the problem statement
    assert S_bruteforce(100) == 258
    assert S_bruteforce(10_000) == 172_004

    # Target: S(10^(10^10)) mod 1234567891.
    E = 10**10  # exponent in N = 10^E (note: N is far too large to construct)

    sum_B = sum_family_B_for_power10_exponent(E)
    nA = pell_max_index_for_power10_exponent(E)
    sum_A = sum_family_A(nA)

    # Remove the overlap once: perimeter 12 exists in both families.
    ans = (sum_A + sum_B - 12) % MOD
    print(ans)


if __name__ == "__main__":
    main()
