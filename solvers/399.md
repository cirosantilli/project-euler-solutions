# Project Euler 399 Solution - Squarefree Fibonacci Numbers

<https://projecteuler.net/problem=399>:

* [399.py](399.py)

This repository contains a standalone `main.py` solution (standard library only).

## Main techniques used

### 1) Rank of apparition (entry point)
For a prime `p`, define `z(p)` as the smallest positive index such that:

- `p | F_{z(p)}`

A key Fibonacci property is:

- `p | F_n` **iff** `z(p) | n`

For primes `p ≠ 5`, `z(p)` is known to divide `p − (5/p)`, where `(5/p)` is the Legendre symbol.
So `z(p)` always divides either `p − 1` or `p + 1`.

### 2) Using the problem’s assumption (Wall’s conjecture instance)
The statement asks us to assume that for every prime `p`, the first Fibonacci number divisible by `p`
(i.e. `F_{z(p)}`) is **not** divisible by `p²`.

Under this assumption, the first index where `p²` divides a Fibonacci number is:

- `z(p²) = p · z(p)`

So:

- `p² | F_n` **iff** `(p · z(p)) | n`

This converts “squarefree Fibonacci values” into a condition purely about **indices**.

### 3) Turning squarefreeness into “avoid these moduli”
Define a “bad modulus” for each prime:

- `m(p) = p · z(p)`

Then `F_n` is squarefree exactly when `n` is **not** a multiple of any `m(p)`.

So the problem becomes: find the `k`-th index `n` that is not divisible by any `m(p)`.

### 4) Inclusion–exclusion over LCMs
Let `mods = { m(p) }` with `m(p) ≤ N` (larger moduli cannot divide indices `≤ N`).

The count of “good” indices `≤ N` can be computed by inclusion–exclusion:

- `count(N) = Σ (-1)^{|S|} · ⌊ N / lcm(S) ⌋`

where `S` ranges over all subsets of `mods` (the empty subset contributes `lcm=1`).

To make this fast, the program enumerates only those subsets whose LCM stays `≤ Nmax`,
and groups identical LCMs by summing their coefficients.

### 5) Binary search for the target index
`count(N)` is monotone in `N`, so we binary search the smallest `n` with:

- `count(n) ≥ 100,000,000`

That `n` is the index of the `100,000,000`-th squarefree Fibonacci number.

### 6) Output formatting
- **Last 16 digits**: computed with Fibonacci fast doubling modulo `10^16`.
- **Scientific notation**: uses `log10(F_n) ≈ n·log10(φ) − log10(√5)` and rounds the mantissa to 1 decimal.

## Statement-derived checks included
`main.py` includes `assert`s for the examples given in the problem statement:

- The first 15 Fibonacci numbers.
- The first 13 squarefree Fibonacci numbers.
- The 200th squarefree Fibonacci number example, including the exact value and the formatted output
  `1608739584170445,9.7e53`.
