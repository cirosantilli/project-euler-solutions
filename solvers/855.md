# Project Euler 855 Solution - Delphi Paper

<https://projecteuler.net/problem=855>:

* [855.py](855.py)

## Key idea
The game is **scale-invariant**: after Bianca picks a piece, the future game depends only on **which grid labels are still unused**, not on the absolute size of the current rectangle. So the final area is the product of per-round area fractions.

## Min–max recursion
Let `V(U)` be the optimal final area (starting from area `1`) when the set `U` of unused labels remains.
In one round Alex chooses row heights `h_1..h_a` (sum to 1) and column widths `w_1..w_b` (sum to 1). Choosing cell `(r,c)` multiplies the current area by `h_r * w_c`, then the game continues with `U \ {(r,c)}`. This gives

- `V(U) = max_{h,w} min_{(r,c) in U}  (h_r * w_c * V(U\{(r,c)}))`.

## Collapse to row/column counts
A crucial simplification is that `V(U)` depends **only** on:
- `m_r`: how many unused labels are in row `r`
- `n_c`: how many unused labels are in column `c`
- `k = |U|` (total unused labels)

Using induction on `k`, you can show the closed form

- `V(U) = (∏_r m_r!) (∏_c n_c!) / (k!)^2`.

### Why this works (sketch)
Assume the formula holds for all smaller sets. Then removing `(r,c)` changes only `m_r, n_c, k`, so
`V(U\{(r,c)}) / V(U) = k^2 / (m_r n_c)`.
The min–max step becomes:

- maximize `min_{(r,c) in U}  k^2 h_r w_c / (m_r n_c)`.

Alex achieves value `1` by choosing cuts proportional to the remaining counts:
- `h_r = m_r / k`
- `w_c = n_c / k`

To show he **cannot** force the minimum above `1`, rescale variables
`α_r = k h_r / m_r`, `β_c = k w_c / n_c`. If `α_r β_c > 1` for every remaining cell, summing over rows and applying a weighted Cauchy–Schwarz inequality yields a contradiction. So some remaining cell always has `α_r β_c ≤ 1`.

This pins the optimal value exactly.

## Final closed form for the full grid
Initially all `ab` labels are unused, so `m_r = b` for each row and `n_c = a` for each column, `k = ab`. Therefore

- `S(a,b) = (a!)^b (b!)^a / ((ab)!)^2`.

## Implementation notes
- Uses Python’s built-in `math.factorial` and `fractions.Fraction` for exact arithmetic.
- Formats the final result with `decimal.Decimal`, rounding the mantissa to **10 digits after the decimal point** in scientific notation.
- Includes `assert` checks for the example values given in the problem statement.
