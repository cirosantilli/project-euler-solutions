# Project Euler 848 Solution - Guessing with Sets

<https://projecteuler.net/problem=848>:

* [848.py](848.py)

This repository contains a reference solution in `main.py` (no third‑party libraries).

## Problem in one sentence

Two players alternately ask yes/no “membership in a set” questions about the other player’s secret number; the first player wins as soon as they ask a *singleton* set that contains the opponent’s number.  
Let `p(m,n)` be the first player’s winning probability when the second player’s number is uniform in `1..m` and the first player’s number is uniform in `1..n`. Compute:

\[
\sum_{i=0}^{20}\sum_{j=0}^{20} p(7^i, 5^j)
\]

rounded to 8 digits after the decimal point.

## Key techniques used

### 1) Symmetry and a state-only recursion

At any point, each player’s knowledge about the opponent is just “the opponent’s number lies in a set of size `k`”. Because all candidates are symmetric, only the *sizes* matter.

If it’s your turn and you’re trying to find an opponent number among `m` candidates, while the opponent is trying to find your number among `n` candidates, you may choose a subset of size `a`:

- With probability `a/m` the answer is “in”, and your opponent set-size becomes `a`.
- With probability `(m-a)/m` the answer is “out”, and your opponent set-size becomes `m-a`.
- If `a=1` and the answer is “in”, you win immediately.

After the answer, turns swap, so the roles of `(m,n)` swap to `(n, a)` or `(n, m-a)`.

This yields a minimax recurrence:

- For `a > 1`:
  \[
  \text{value}(a) = \frac{a}{m}\bigl(1-p(n,a)\bigr) + \frac{m-a}{m}\bigl(1-p(n,m-a)\bigr)
  \]
- For `a = 1`:
  \[
  \text{value}(1) = \frac{1}{m} + \frac{m-1}{m}\bigl(1-p(n,m-1)\bigr)
  \]
and
\[
p(m,n)=\max_{1\le a\le m-1}\text{value}(a).
\]

### 2) “Stable regions” with closed forms

A direct dynamic program over all `m` up to `7^20` is impossible.

The crucial observation is that the recurrence has large parameter regions where the optimal move and the resulting value simplify to *closed forms*.

Define:

- `p` = smallest power of 2 such that `3p ≥ x`
- `T = 3p`
- `L = 3(p/2)` (only meaningful when `p≥2`)

Then the game has two useful stable regimes:

**High-`n` (you are very safe):** if `n ≥ L(m)` then
\[
p(m,n)=1-\frac{L(m)\,\bigl(m-p(m)\bigr)}{m\,n}.
\]

**High-`m` (you must win quickly):** if `m ≥ T(n)` (and `n≥3`) then
\[
p(m,n)=\frac{T(n)\,\bigl(n-p(n)\bigr)}{n\,m}.
\]

For the specific inputs `m=7^i` and `n=5^j`, every pair falls into one of these stable regimes (or a trivial base case), so each `p(m,n)` can be computed in constant time.

A small fallback evaluation (testing `a=1` and an almost-even split around `m/2`) is still included for completeness, but it is not needed for the final double sum.

### 3) Exact rational arithmetic and exact rounding

All formulas are rational. The implementation keeps everything as `fractions.Fraction`, sums exactly, and rounds to 8 decimal places using integer arithmetic (no floating-point drift).

## Complexity

- Computing all 441 required values is essentially **O(441)** with small integer arithmetic.
- Memory use is tiny (a few hundred cached `p(m,n)` values).
