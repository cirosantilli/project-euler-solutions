#!/usr/bin/env python3
"""
Project Euler 390
Triangles with non-rational sides and integral area

We consider triangles with side lengths:
  sqrt(1+b^2), sqrt(1+c^2), sqrt(b^2+c^2)   (b,c positive integers)

Let S(n) be the sum of areas of all such triangles whose area is an integer <= n.

This script prints S(10^10).
"""

from __future__ import annotations


def _p_bound(N: int) -> int:
    """
    For b=2p, c=2q, the smallest positive q-solution for a fixed p is q=4p^2,
    which yields area A = p(8p^2+1). Therefore if 8p^3 + p > N, there can be no
    solutions starting from that p.

    Returns the largest p with 8p^3 + p <= N.
    """
    lo, hi = 0, 1
    # Exponential search for an upper bound
    while 8 * hi * hi * hi + hi <= N:
        hi *= 2
    # Binary search
    while lo + 1 < hi:
        mid = (lo + hi) // 2
        if 8 * mid * mid * mid + mid <= N:
            lo = mid
        else:
            hi = mid
    return lo


def S(N: int) -> int:
    """
    Compute S(N).

    Key facts (see README.md for derivation):
      - b and c must be even, so write b=2p, c=2q.
      - The area A is integral iff (p,q,A) satisfies:
            A^2 - (4p^2+1) q^2 = p^2
        which is a generalized Pell equation.
      - For fixed p, solutions are generated by multiplying by the unit
        (8p^2+1) + 4p*sqrt(4p^2+1), giving the linear recurrence:
            q' = (8p^2+1) q + 4p A
            A' = 4p(4p^2+1) q + (8p^2+1) A
      - The original equation is symmetric in p and q, and sign changes
        are also valid. This yields a 3-way branching tree that enumerates
        each valid triangle exactly once.
    """
    bound = _p_bound(N)

    total = 0
    stack: list[tuple[int, int, int]] = [(p, 0, p) for p in range(1, bound + 1)]

    while stack:
        p, q, A = stack.pop()

        a = 8 * p * p + 1
        b = 4 * p
        c = 4 * p * (4 * p * p + 1)

        # One "Pell step" (must be computed from the old (q,A) pair)
        q_new = a * q + b * A
        A_new = c * q + a * A

        if A_new > N:
            continue

        total += A_new

        # Continue along the same p-sequence, and branch by symmetry
        stack.append((p, q_new, A_new))
        stack.append((q_new, p, A_new))
        stack.append((q_new, -p, A_new))

    return total


def euler390() -> int:
    return S(10**10)


def main() -> None:
    # Test value from the problem statement:
    assert S(10**6) == 18018206
    print(euler390())


if __name__ == "__main__":
    main()
