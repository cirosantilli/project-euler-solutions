# Project Euler 786 Solution - Billiard

<https://projecteuler.net/problem=786>:

* [786.py](786.py)

This problem counts billiard paths on a special quadrilateral with angles  
\(120^\circ, 90^\circ, 60^\circ, 90^\circ\) and equal sides \(AB=AD\).  
A path starts at \(A\), reflects perfectly on edges, and must return to \(A\) without ever bouncing on a corner.

## Key ideas used

### 1) Unfolding by reflections
Instead of reflecting the ball direction at each bounce, reflect the table across the struck edge.  
In the unfolded plane, the billiard path becomes a straight line between the original point \(A\) and a reflected copy of \(A\).

The repeated reflections form a periodic tiling (conveniently described using a hexagon/triangle lattice picture), so valid return paths correspond to certain lattice vectors.

### 2) Reducing paths to primitive integer pairs
Each admissible return segment can be parameterized by a pair of positive integers \((x,y)\) with:

- a linear inequality that encodes “at most \(N\) bounces”, and
- a coprimality condition \(\gcd(x,y)=1\) to avoid hitting \(A\) earlier,
- a simple modular restriction (here, excluding \(3 \mid y\)) which prevents “bad” collisions with special points of the tiling.

After symmetry reduction, the count becomes:

\[
B(N)=2 + 4 \cdot \#\{(x,y)\in\mathbb{Z}_{>0}^2:\gcd(x,y)=1,\ 3\nmid y,\ 18x+10y \le 3N+6\}.
\]

The constants `2` and `4` come from small edge cases and symmetry (rotations/reflections of equivalent directions).

### 3) Möbius inversion for the gcd constraint
To count only coprime pairs, apply:

\[
\#\{\gcd(x,y)=1\}=\sum_{d\ge 1} \mu(d)\ \#\{d\mid x,\ d\mid y\}.
\]

Because of the extra condition \(3\nmid y\), only divisors \(d\) with \(3\nmid d\) can contribute.

So the primitive count is:

\[
\sum_{d\ge 1,\ 3\nmid d} \mu(d)\ T\!\left(\left\lfloor \frac{M}{d}\right\rfloor\right),
\]
where \(M=3N+6\) and \(T(\cdot)\) counts all integer points under the same line constraint, without enforcing gcd.

### 4) Fast lattice-point counting under a line
The “non-primitive” count

\[
T(M)=\#\{(x,y): x\ge 1,\ y\ge 1,\ 18x+10y\le M,\ 3\nmid y\}
\]

is computed as a sum of floor divisions:

- count all \(y\),
- subtract the contribution of \(y\) that are multiples of 3.

Both sums are evaluated with a standard `floor_sum` routine in \(O(\log M)\) time.

### 5) Harmonic grouping + fast Mertens-type prefix sums
The Möbius sum is evaluated by grouping all \(d\) for which \(\left\lfloor M/d\right\rfloor\) is constant.  
This reduces the number of terms from \(O(M)\) to \(O(\sqrt{M})\).

To get interval sums of \(\mu(d)\) efficiently, the program computes the Mertens function
\(M(n)=\sum_{k\le n}\mu(k)\) using:

- a small sieve up to roughly \(n^{2/3}\),
- a memoized divisor-group recursion for larger values.

From \(M(n)\) it derives
\(F(n)=\sum_{k\le n,\,3\nmid k}\mu(k)\), which directly supplies the needed interval coefficients.

## Complexity
For \(N=10^9\), the implementation runs comfortably in a few seconds in pure Python:

- about \(O(M^{1/2})\) distinct quotient groups in the outer sum,
- about \(O(M^{2/3})\) work to support the required prefix sums,
- memory dominated by the small Möbius sieve.

## Files
- `main.py` computes `B(10^9)` and asserts the sample values:
  - \(B(10)=6\)
  - \(B(100)=478\)
  - \(B(1000)=45790\)
