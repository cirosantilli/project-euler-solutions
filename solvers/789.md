# Project Euler 789 Solution - Minimal Pairing Modulo $p$

<https://projecteuler.net/problem=789>:

* [789.py](789.py)

This write-up describes the techniques used in `main.py`.

## 1) From pairing costs to a modular constraint

If the pairs are `(a1,b1), (a2,b2), ...`, the **cost product** is

- `K = Π (ai * bi mod p)`.

But every number `1..p-1` appears exactly once across all pairs, so

- `K ≡ Π_{x=1..p-1} x (mod p) ≡ (p-1)! (mod p)`.

By **Wilson's theorem**, `(p-1)! ≡ -1 (mod p)`, therefore every pairing satisfies

- `K ≡ -1 (mod p)`.

So the cost product we seek is an **integer** whose residue mod `p` is `-1`.

## 2) Why only prime costs matter

The total cost is `Σ cost(pair)`.
Most numbers can be paired as `(x, x^{-1})`, which has cost `1`.
Only a small set of non-`1` costs is needed to satisfy the global product constraint.

For optimization, it is useful to measure the "extra over 1": if a cost is `c`, it
contributes `(c-1)` beyond the minimum `1`.

If a cost `c` is composite, say `c = u*v` with `u,v > 1`, then

- `(u-1) + (v-1) = u+v-2 < u*v-1 = (c-1)`.

So replacing `c` by two costs `u` and `v` keeps the modular product the same, but
strictly decreases the total extra cost. Repeating this argument shows:

- in an optimal solution, all non-`1` costs can be taken as **primes** (with multiplicity).

Therefore the problem becomes:

> Choose a multiset of primes with product `≡ -1 (mod p)` minimizing `Σ (q-1)`.

## 3) Weight-bounded meet-in-the-middle search

Let each prime `q` have **weight** `w(q)=q-1`.
For a given weight limit `W`, the only primes that can appear satisfy `q-1 <= W`, i.e.
`q <= W+1`.

The program searches increasing bounds `W` until it finds a solution, and within a
bound it finds the minimum-weight solution.

To keep enumeration small it partitions primes into:

- `2` and `3` handled separately (they can appear many times because their weights are 1 and 2),
- `A = {5,7,11,13,17,19,23}` (small weights, many combinations),
- `B = primes >= 29` up to `W+1` (large weights, very few combinations).

For each partition it enumerates all prime products with total weight `<= W`:

- For `A` it stores a dictionary: `residue -> (best_weight, best_integer_product)`.
- For `B` it stores all states (there are only thousands), plus modular inverses.
- For `(2,3)` it precomputes power tables to generate all `(2^e2 * 3^e3)` states in `O(W^2)`.

A solution is found by combining three states:

- `r23 * rB * rA ≡ -1 (mod p)`.

Using precomputed modular inverses, the needed `rA` is computed with only
multiplications (no per-pair modular inverse).

Among all feasible combinations, the program keeps the smallest total weight, and the
corresponding integer product is the answer printed.
