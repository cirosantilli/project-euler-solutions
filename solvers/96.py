#!/usr/bin/env python

# Generated by GPT-5.2 Thinking web UI on 2025-12-22.

from pathlib import Path

ALL = (1 << 9) - 1  # bits 0..8 represent digits 1..9


def bit_to_digit(bit: int) -> int:
    # bit is power-of-two
    return (bit.bit_length() - 1) + 1


def iter_bits(mask: int):
    while mask:
        b = mask & -mask
        yield b
        mask -= b


def build_peers_units():
    units = []
    # rows
    for r in range(9):
        units.append([r * 9 + c for c in range(9)])
    # cols
    for c in range(9):
        units.append([r * 9 + c for r in range(9)])
    # boxes
    for br in range(3):
        for bc in range(3):
            box = []
            for r in range(br * 3, br * 3 + 3):
                for c in range(bc * 3, bc * 3 + 3):
                    box.append(r * 9 + c)
            units.append(box)

    peers = [set() for _ in range(81)]
    for u in units:
        s = set(u)
        for i in u:
            peers[i] |= s - {i}
    return peers, units


PEERS, UNITS = build_peers_units()


def reduce_cands(cands):
    """Constraint propagation: propagate singles + 'only place for digit in a unit'."""
    changed = True
    while changed:
        changed = False

        # Propagate singles
        queue = [i for i in range(81) if cands[i].bit_count() == 1]
        while queue:
            i = queue.pop()
            val = cands[i]
            for p in PEERS[i]:
                if cands[p] & val:
                    cands[p] &= ~val
                    if cands[p] == 0:
                        return False
                    if cands[p].bit_count() == 1:
                        queue.append(p)
                    changed = True

        # Only-choice in each unit
        for unit in UNITS:
            # For each digit bit, see where it can go
            for dbit in (1 << k for k in range(9)):
                places = [i for i in unit if (cands[i] & dbit)]
                if not places:
                    return False
                if len(places) == 1 and cands[places[0]] != dbit:
                    cands[places[0]] = dbit
                    changed = True

    return True


def solve_cands(cands):
    if not reduce_cands(cands):
        return None
    # solved?
    if all(x.bit_count() == 1 for x in cands):
        return cands

    # choose cell with fewest candidates > 1
    _, idx = min(
        (cands[i].bit_count(), i) for i in range(81) if cands[i].bit_count() > 1
    )

    for b in iter_bits(cands[idx]):
        nxt = cands.copy()
        nxt[idx] = b
        res = solve_cands(nxt)
        if res is not None:
            return res
    return None


def parse_puzzles(text: str):
    lines = [ln.strip() for ln in text.splitlines() if ln.strip()]
    i = 0
    while i < len(lines):
        if lines[i].startswith("Grid"):
            grid = lines[i + 1 : i + 10]
            i += 10
            yield grid
        else:
            i += 1


def grid_to_cands(grid_lines):
    cands = [ALL] * 81
    for r in range(9):
        row = grid_lines[r]
        for c in range(9):
            ch = row[c]
            if ch != "0":
                d = int(ch)
                cands[r * 9 + c] = 1 << (d - 1)
    return cands


def top_left_number(solution_cands):
    a = bit_to_digit(solution_cands[0])
    b = bit_to_digit(solution_cands[1])
    c = bit_to_digit(solution_cands[2])
    return 100 * a + 10 * b + c


def main(path="0096_sudoku.txt"):
    text = Path(path).read_text(encoding="utf-8")
    total = 0
    for grid in parse_puzzles(text):
        cands = grid_to_cands(grid)
        solved = solve_cands(cands)
        if solved is None:
            raise ValueError("Unsolvable puzzle encountered")
        total += top_left_number(solved)
    print(total)


if __name__ == "__main__":
    main()
