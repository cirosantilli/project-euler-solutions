# Project Euler 305 Solution - Reflexive Position

<https://projecteuler.net/problem=305>:

* [305.py](305.py)

We work with the infinite string:

`S = 123456789101112131415...`

For each positive integer `n`, let `f(n)` be the **1-indexed starting position** of the **n-th occurrence** of the decimal string `str(n)` in `S`.
The task is:

\[
\sum_{k=1}^{13} f(3^k)
\]

## Main techniques used

### 1) KMP automaton (streaming substring counting)
For a fixed pattern `p = str(n)` (length ≤ 7 in this problem), we build a Knuth–Morris–Pratt automaton:

- State = how many prefix characters of `p` are currently matched.
- Transition by next digit `0..9`.
- When the automaton reaches a full match, we count it and fall back using the prefix-function to allow overlaps.

This gives an O(1) per digit way to count matches while reading digits.

### 2) Convert “start positions” to “prefix match counting”
To locate `f(n)` we need a monotone predicate. If the pattern length is `m`, then

- an occurrence that **starts** at position `s` **ends** at position `s + m - 1`.

So the number of occurrences with **start ≤ L** equals the number of matches whose **end ≤ L + m - 1**, i.e. the number of matches fully contained in the first `P = L + m - 1` digits of `S`.

### 3) Map a digit-prefix length to a whole-number boundary
Given `P`, we compute:

- `N_full`: the largest integer such that the concatenation `123…N_full` fits entirely in `P` digits,
- `rem`: how many leading digits of `N_full+1` are also included.

This uses digit-length block sums (1-digit numbers contribute `9*1`, 2-digit contribute `90*2`, etc.).

### 4) Brute small prefix; count the rest analytically
Early in `S`, a match can span multiple number boundaries (e.g. across `9999|10000|10001`).
For pattern length `m`, once numbers have at least `m-1` digits, any length-`m` match spans **at most one boundary**.

We exploit this by:

- brute-scanning `123…A` where `A = 10^(m-2)` (tiny: at most `100000` when `m=7`),
- then for the remainder, counting matches as the sum of:

**(a) Internal matches inside single numbers**

Count total occurrences of `p` inside the decimal strings of all integers `1..N` using a digit-DP running the KMP automaton.

**(b) Boundary matches spanning `i|i+1`**

For each split `p = p1 + p2` with `|p1|=k`:

- `i` must end with `p1`  ⇒  `i ≡ p1 (mod 10^k)`
- `i+1` must start with `p2` ⇒ `i+1` lies in a prefix-defined interval

Counting `i` becomes counting an arithmetic progression inside an interval, done in O(1) per digit-length block.

### 5) Binary search for `f(n)`
`count_starts_leq(L)` is monotone, so we:

1. find an upper bound by doubling,
2. binary search the smallest `L` with `count_starts_leq(L) ≥ n`.

## Built-in checks
The implementation includes the problem statement examples:

- `f(1)=1`
- `f(5)=81`
- `f(12)=271`
- `f(7780)=111111365`

Run:

```bash
python3 main.py
```

It prints the final answer.
