# Project Euler 917 Solution - Minimal Path Using Additive Cost

<https://projecteuler.net/problem=917>:

* [917.py](917.py)

This repository contains a single-file solution (`main.py`) with no third‑party dependencies.

## Core idea

The matrix is

\[
M_{i,j} = a_i + b_j \qquad (1 \le i,j \le N)
\]

and we want the minimum sum along any monotone path from \((1,1)\) to \((N,N)\) using only **right** and **down** moves.

## Technique 1: Remove a constant part

Along any such path:

- Every row index \(i\) appears at least once (the path visits all rows in order), so each \(a_i\) contributes **at least once**.
- Extra contributions of \(a_i\) happen exactly when we take a **right** step while staying in row \(i\).
- Symmetrically, each \(b_j\) contributes once, plus extra contributions when we take a **down** step while staying in column \(j\).

So the path sum can be rewritten as

\[
A(N) = \sum_{i=1}^N a_i \; + \; \sum_{j=1}^N b_j \; + \; D(N)
\]

where \(D(N)\) is a shortest path problem on grid **nodes** \((i,j)\):

- \((i,j)\to(i,j+1)\) has cost \(a_i\)
- \((i,j)\to(i+1,j)\) has cost \(b_j\)

Now we only need \(D(N)\).

## Technique 2: Keep only “useful” rows/columns via a lower convex hull

The full dynamic program for \(D(N)\) is \(O(N^2)\), which is impossible for \(N=10^7\).

A key geometric property of this cost structure is:

- If you plot points \((i, a_i)\) in the plane, then only indices that lie on the **lower convex hull** can matter as turning points for an optimal path.
- The same holds for \((j, b_j)\).

Intuitively, a row that sits strictly above the lower hull is never the best place to spend horizontal distance: its cost can be matched or improved by shifting horizontal movement to nearby hull rows.

Because the sequences behave like pseudorandom values, the lower hulls are tiny (tens of points) even when \(N\) is ten million. `main.py` builds both lower hulls in one streaming pass, without storing all \(a_i\) and \(b_j\).

## Technique 3: Dynamic programming on the compressed grid

Let the kept row indices be \(r_0 < r_1 < \dots < r_{R-1}\) and kept column indices be \(c_0 < c_1 < \dots < c_{C-1}\), including endpoints.

Moving from \(c_{k}\) to \(c_{k+1}\) in a fixed kept row \(r\) costs

\[
a_r \cdot (c_{k+1}-c_k)
\]

and moving from \(r_{t}\) to \(r_{t+1}\) in a fixed kept column \(c\) costs

\[
b_c \cdot (r_{t+1}-r_t)
\]

That produces a very small \(R\times C\) grid, where a standard DP finds \(D(N)\) quickly.

## Complexity

- Sequence generation + hull construction: **\(O(N)\)** time, **\(O(H)\)** memory where \(H\) is hull size.
- Compressed DP: **\(O(RC)\)** with \(R,C \approx H\) (small).
