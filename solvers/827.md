# Project Euler 827 Solution - Pythagorean Triple Occurrence

<https://projecteuler.net/problem=827>:

* [827.py](827.py)

This repository contains a pure-Python solution for Project Euler 827 (no third-party libraries).

## Key ideas

### 1) Count triples containing a given number `x`
A Pythagorean triple satisfies `a² + b² = c²` with `a < b < c`.  
A number `x` can appear either as a **leg** or as the **hypotenuse**, so the total count is:

- `L(x)` = number of triples where `x` is a leg
- `H(x)` = number of triples where `x` is the hypotenuse
- `T(x) = L(x) + H(x)`

**Leg count.**  
Rearrange `x² + b² = c²` into `(c-b)(c+b) = x²`. Let `u=c-b`, `v=c+b`, then `uv = x²`,
and `b=(v-u)/2`, `c=(v+u)/2` require `u` and `v` to have the same parity.

- If `x` is odd, every divisor pair is odd → parity is automatic.
- If `x` is even, both `u` and `v` must be even → reduce by a factor of `4`.

This yields:
- `L(x) = (d(x²) - 1)/2` for odd `x`
- `L(x) = (d((x/2)²) - 1)/2` for even `x`

where `d(n)` is the divisor-count function.

**Hypotenuse count.**  
`H(x)` is tied to representations of `x²` as a sum of two squares. Using the classical
formula for the number of representations and removing the degenerate ones with a zero,
one gets:

`H(x) = ( Π_{p≡1 (mod 4)} (2e_p + 1) - 1 ) / 2`

where `e_p` is the exponent of prime `p` in `x`.

### 2) Turn `T(x)=n` into a multiplicative constraint
Write:

- `B = Π_{p≡1 (mod 4)} (2e_p + 1)`  
- `A = d(m²) = Π_{all primes}(2e'_p + 1)`, where `m = x` if `x` is odd, else `m = x/2`

Then:
- `L(x) = (A - 1)/2`
- `H(x) = (B - 1)/2`
- so `T(x) = (A + B - 2)/2`

Setting `T(x)=n` gives the key identity:

`A + B = 2(n + 1)`

Because `B` is always odd, `B` must divide `(n+1)`. The solver enumerates every odd
divisor `B | (n+1)` and derives the remaining factor `D` that must be accounted for by
primes `≡ 3 (mod 4)` and the special handling of the prime `2`.

### 3) “Smallest number with a given product of (2e+1)” via DFS
The remaining subproblem is:

> Given an odd target `P`, build the smallest integer using allowed primes such that  
> `Π(2e_i + 1) = P`.

This is similar in spirit to constructing the smallest number with a given divisor count.
A depth-first search tries factor choices `f = 2e+1` of `P`, enforcing non-increasing
exponents (`e`) across increasing primes (the standard minimality rule).

### 4) Avoid constructing enormous integers
For large targets, `Q(10^k)` becomes astronomically big. We only need the final sum
**modulo** `409120391`, so the implementation:

- compares candidates using high-precision `log2` values (`decimal.Decimal`)
- computes the result modulo `MOD` using modular exponentiation, without materializing
  the full integer

### 5) Fast factorization for 64-bit integers
To enumerate divisors and run the DFS efficiently, the solution factors numbers up to
about `2·10^18` using:

- deterministic Miller–Rabin for 64-bit primality testing
- Pollard’s Rho for composite factor splitting

## Running

```bash
python3 main.py
