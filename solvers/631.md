# Project Euler 631 Solution - Constrained Permutations

<https://projecteuler.net/problem=631>:

* [631.py](631.py)

This solution counts permutations with two restrictions:

- **No** occurrence of the pattern **1243** (in the usual permutation-pattern sense).
- **At most `m` inversions**, i.e. at most `m` occurrences of the pattern **21**.

The goal is to compute `f(n, m)` for `n = 10^18` and `m = 40` modulo `1,000,000,007`, where `f(n,m)` counts valid permutations of **any length ≤ n** (including the empty permutation).

## Key ideas

### 1) Symmetry to swap the forbidden pattern
Using the reverse-and-complement bijection on permutations (rotate the permutation matrix by 180°), the inversion count is preserved and the pattern **1243** is mapped to **2134**.  
So we can count **2134-avoiding** permutations instead of 1243-avoiding ones.

### 2) A “last value” insertion encoding
For each length `i`, build the permutation by deciding the **value of the last element** in standardized form:

- Choose `x ∈ {1..i}`.
- Take a permutation of `{1..i-1}` and increase every old value `≥ x` by `1`.
- Append `x` as the new last element.

This is a bijection with permutations of size `i`, and it has a big benefit: the number of inversions created by appending `x` is exactly `i - x`, independent of the internal arrangement.

### 3) Small state that is enough to enforce 2134-avoidance
The pattern **2134** can be seen as a **213** pattern followed later by a larger element.  
So once any 213 has occurred, appending a value larger than the **smallest** possible “3” from any 213 would immediately create a 2134.

The dynamic program tracks:

- `inv`: current inversion count (capped by `m`).
- `j`: the minimum value that has appeared as the **‘2’** in any inversion (21), or “∞” if none yet.
- `k`: the minimum value that has appeared as the **‘3’** in any 213, or “∞” if none yet.

When choosing the next `x`, we forbid `x > k` (after accounting for relabeling), because that would complete a 2134.

### 4) Stabilization for large `n`
Let `g(L,m)` be the number of valid permutations of **exact** length `L`. For `L > 3m`, one can show:

- Every valid permutation of length `L+1` must end in `L+1`.
- Appending `L+1` at the end never creates new inversions or a new 1243 pattern.

So `g(L+1,m) = g(L,m)` for all `L > 3m`; exact-length counts become constant from that point onward.  
Since `f(n,m)` is the sum of `g(0,m) + g(1,m) + … + g(n,m)`, it becomes a linear function of `n` after `3m`.

For `m = 40`, we only need to compute exact-length counts up to `3m + 1 = 121`, then apply the linear tail formula modulo `1,000,000,007`.

## Complexity

With `m = 40` the DP explores a moderate number of states. The runtime is dominated by the transitions for lengths up to `121`, and fits comfortably in a fast interpreted implementation.

## Files

- `main.py` — implementation and the required asserts for the sample values.
- `README.md` — this summary.
