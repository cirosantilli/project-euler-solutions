# Project Euler 662 Solution - Fibonacci Paths

<https://projecteuler.net/problem=662>:

* [662.py](662.py)

This repository contains a pure-Python solver for Project Euler **Problem 662**.

## Problem recap

From a lattice point \((a,b)\), Alice may step to \((a+x,b+y)\) if:

- \(x \ge 0\), \(y \ge 0\)
- the Euclidean step length \(\sqrt{x^2+y^2}\) is a Fibonacci number \(\{1,2,3,5,8,13,\dots\}\)

Let \(F(W,H)\) be the number of such paths from \((0,0)\) to \((W,H)\), counted with order of steps (so different step sequences are different paths). The final answer is requested modulo \(1\,000\,000\,007\).

The implementation asserts the two example values from the statement.

## Main techniques used

### 1) Enumerating legal step vectors

A step \((dx,dy)\) is allowed when:

\[
dx^2 + dy^2 = f^2
\]

for some Fibonacci number \(f\), with \(0 \le dx \le W\) and \(0 \le dy \le H\).

Key detail: the largest usable Fibonacci *radius* can exceed \(\max(W,H)\), so we generate Fibonacci numbers up to:

\[
\left\lfloor\sqrt{W^2+H^2}\right\rfloor
\]

For each Fibonacci radius \(f\), we iterate \(dx\) and compute \(dy\) via integer square root (`math.isqrt`), keeping only exact squares.

### 2) Dynamic programming on the grid

Let `dp[y][x]` be the number of paths to \((x,y)\). Then:

\[
dp[y][x] = \sum_{(dx,dy)\in S,\ x\ge dx,\ y\ge dy} dp[y-dy][x-dx]
\]

with base case \(dp[0][0]=1\).

All arithmetic is done modulo \(1\,000\,000\,007\).

### 3) Rolling buffer over rows

Only rows \(y-dy\) are referenced when computing row \(y\). We keep a ring buffer of rows with size `max_dy + 1`, where `max_dy` is the largest `dy` among allowed steps for the given \((W,H)\).

Rows are stored using `array('I')` (a standard library typed array) to significantly reduce memory compared to Python integer lists.

## How to run

```bash
python3 main.py
```

The script will:

1. Assert the two provided sample values.
2. Print \(F(10000,10000)\bmod 1\,000\,000\,007\).
