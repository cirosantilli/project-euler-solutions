# Project Euler 878 Solution - XOR-Equation B

<https://projecteuler.net/problem=878>:

* [878.py](878.py)

This solution works entirely with **GF(2)** arithmetic on bitstrings.

## 1) XOR-product is carryless multiplication

The “XOR-product” `x ⊗ y` is exactly **polynomial multiplication over GF(2)**:

- write `x = Σ x_i t^i`, `y = Σ y_i t^i` with coefficients `x_i,y_i ∈ {0,1}`
- define `x ⊗ y` as the product polynomial, with coefficients reduced mod 2
- mapping back to integers uses `t = 2`, i.e. bits are coefficients

So `⊗` can be implemented as “shift-and-xor” over set bits.

Also, `2 ⊗ z` is just `z << 1` (multiplication by `t`).

## 2) The equation is a norm form

The expression

(a⊗a) ⊕ (2⊗a⊗b) ⊕ (b⊗b)
= A(t)^2 + t A(t)B(t) + B(t)^2

css
Copy code

(where `A,B` are the GF(2) polynomials for `a,b`) is a **norm** in a quadratic extension:

Let `u` satisfy `u^2 + t u + 1 = 0`.  
Then:

Norm(A + B u) = (A + B u)(A + B(u+t)) = A^2 + tAB + B^2

perl
Copy code

This implies that for a fixed value of `k`, the solutions form **orbits** under multiplication by units of norm 1.

## 3) Unit action gives a simple recurrence on (a,b)

Because `Norm(u) = 1`, multiplying by `u` preserves `k`.

In coefficients, `(A + B u) * u = B + (A + tB)u`, which translates to the integer recurrence:

T(a,b) = ( b, a ⊕ (b<<1) )

yaml
Copy code

and an inverse:

T⁻¹(a,b) = ( b ⊕ (a<<1), a )

r
Copy code

So for each `k`, all solutions lie on a bi-infinite chain generated by repeatedly applying `T` and `T⁻¹`.

## 4) Reduce the search to a small “fundamental box”

We don’t enumerate up to `N = 10^17`.  
Instead:

- all solutions with `k ≤ m` intersect a relatively small region of `(a,b)` (a “fundamental domain” for the unit action)
- for `m ≤ 10^6` this box is small enough to brute force

The code picks:

B = 2^(((bitlen(m)+1)//2) + 2)

markdown
Copy code

and brute-forces all `(a,b)` with `a,b < B` to find every orbit that can contribute.

## 5) Orbit counting up to N

Once each orbit is identified (deduplicated with a canonical representative),
counting solutions up to the huge bound `N` is cheap:

- step forward and backward along the orbit using `T` and `T⁻¹`
- count those with `0 ≤ a ≤ b ≤ N`

The orbit values grow rapidly in bit-length, so only `O(bitlen(N))` steps are needed per orbit.

## 6) Built-in verification

The program includes asserts for the statement’s check values:

- `7 ⊗ 3 = 9`
- `(3,6)` gives `k = 5`
- `G(1000,100) = 398`

The final answer is **computed and printed**, not embedded or asserted.
