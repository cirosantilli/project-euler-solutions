# Project Euler 950 Solution - Pirate Treasure

<https://projecteuler.net/problem=950>:

* [950.py](950.py)

This solution targets the instances used in the problem:
the bloodthirstiness is always of the form **p = 1/√D** where *D* is a positive non‑square integer.
That guarantees irrationality and lets us do all comparisons exactly with integers (no floating point).

## Key ideas

### 1) Backward induction becomes “buy the cheapest votes”
For a given `n`, the most senior pirate compares:

- **Accept:** everyone lives, so `w = 0`, and a pirate’s happiness is just the coins they receive.
- **Reject:** the senior dies, the game continues with `n-1` pirates, and every survivor gains an extra
  `p` in happiness per execution.

Because `p` is the same for everyone, the “extra happiness from executions” is a **single offset**
added to the alternative outcome. So the senior only needs to bribe the minimum number of surviving
pirates, and will always pick the pirates who are cheapest to satisfy.

### 2) A long “death cascade” between reset points
Define a **reset** as an `n` where the most senior pirate survives immediately (`w(n)=0`).
Empirically (and provably for this setting), after the early phase:

- from a reset `L`, for every `n = L+1, L+2, …` until the next reset, the most senior pirate dies,
  so `w(n) = n-L` and `c(n)` stays constant;
- at the next reset `x`, the senior can finally afford enough votes.

That means the sum `∑(c(n)+w(n))` can be accumulated **interval‑by‑interval** using arithmetic series,
instead of iterating up to `N`.

### 3) Finding the next reset with an inequality
Let `d = x - L` be the length of the cascade from the previous reset `L` to the next reset `x`.
In the vote at `x`:

- `d` votes are “free” (the senior plus the `d-1` pirates who would die if he dies),
- additional votes can be bought, and each purchased vote costs at least `ceil(d/√D)` coins.

This yields a feasibility condition of the form

`2d + 2 * floor(C / ceil(d/√D))  ≥  L + d`.

Rearranging shows that if we guess `y = floor(C / ceil(d/√D))`, the smallest possible `x` is `x = 2L - 2y`.
So we iterate only over the **distinct values of** `floor(C / k)` (there are `O(√C)` of them),
check the implied candidate `x`, and pick the first consistent one.

### 4) Exact `ceil(d/√D)` without floats
For non‑square `D`, `d/√D` is never an integer, so

`ceil(d/√D) = floor(d/√D) + 1`.

We compute `floor(d/√D)` using integer square roots and the inequality

`t = floor(d/√D)  ⇔  t²·D ≤ d² < (t+1)²·D`.

A tiny correction loop fixes any off‑by‑one from the initial estimate.

## Complexity
Let `C ≤ 10^6+1` and `N = 10^16`.

- The number of reset points grows roughly logarithmically with `N`.
- Each “next reset” search inspects `O(√C)` quotient values.

So the overall running time is about `O(√C · log N)` per `T`, which is easily fast enough in pure Python.
