# Project Euler 726 Solution - Falling Bottles

<https://projecteuler.net/problem=726>:

* [726.py](726.py)

This repository contains a direct implementation for computing

\[
S(n)=\sum_{k=1}^{n} f(k)\pmod{1{,}000{,}000{,}033}
\]

for **Problem 726**.

## Key idea: encode the process as a Young-diagram slide

A stable bottle configuration can be viewed as a *downward-closed* subset of positions in the triangular stack:
a bottle can only exist if its two supports below exist.

When a bottle is removed, the “hole” moves upward. If there are:

- **0** bottles touching from above, the hole stops,
- **1** bottle touching from above, it must fall into the hole,
- **2** bottles touching from above, either can be chosen to fall.

So each move is a “slide” of a hole upward in the triangular grid, with choices exactly when the hole has two parents.
This is closely analogous to the **jeu de taquin** sliding operation in Young diagrams.

## Factorization of the count

Let \(N=n(n+1)/2\) be the number of bottles in an \(n\)-layer stack.

The total number of full histories \(f(n)\) factorizes into two independent parts:

1. **Which positions become empty (the “removal order”)**  
   The sequence of “topmost available” positions removed forms a linear extension of the staircase poset,
   which is equivalent to a **standard Young tableau (SYT)** of staircase shape \((n,n-1,\dots,1)\).

   By the **hook-length formula** for this staircase shape, the SYT count is
   \[
   \mathrm{SYT}(n)=\frac{N!}{\prod_{k=1}^{n} (2k-1)^{\,n-k+1}}.
   \]

2. **How the hole slides (choice multiplicities)**  
   For each diagonal level \(k\), the local “binary choice” structure contributes a Mersenne factor \((2^k-1)\),
   and the total exponent with which it appears is \((n-k+1)\). This yields
   \[
   \prod_{k=1}^{n} (2^k-1)^{\,n-k+1}.
   \]

Multiplying both parts gives:
\[
f(n)=N!\cdot \prod_{k=1}^{n}\left(\frac{2^k-1}{2k-1}\right)^{n-k+1}.
\]

## Efficient recurrence for \(f(n)\)

From the closed form, the ratio \(f(n)/f(n-1)\) becomes simple:

- \(N_n! / N_{n-1}!\) is the product of the next \(n\) integers.
- The exponent change in the product contributes exactly one copy of every \((2^k-1)/(2k-1)\) for \(k\le n\).

So we can iterate \(n=2..10^4\) with only about \(1+2+\dots+10^4\approx 5\times 10^7\) modular multiplications.

## Modular arithmetic

The modulus \(1{,}000{,}000{,}033\) is prime (so every nonzero number has a multiplicative inverse),
and inverses are computed with Fermat’s little theorem:

\[
a^{-1}\equiv a^{p-2}\pmod p.
\]

The implementation keeps running prefix products:

- \(\prod_{k\le n}(2^k-1)\)
- \(\left(\prod_{k\le n}(2k-1)\right)^{-1}\)

and accumulates \(S(n)\) as it goes.
