# Project Euler 812 Solution - Dynamical Polynomials

<https://projecteuler.net/problem=812>:

* [812.py](812.py)

This problem asks for the number `S(n)` of **monic** integer polynomials `f(x)` of degree `n` such that

- `f(x)` divides `f(x^2 - 2)` in `ℤ[x]`.

The program computes `S(10_000)` modulo `998244353` and checks the small values given in the statement.

## 1) Dynamics viewpoint and factor classification

If `f | f∘g` where `g(x)=x^2-2`, then every root `α` of `f` must satisfy:

- `f(g(α)) = 0`  ⇒  `g(α)` is also a root of `f`.

So the multiset of roots is **forward-invariant** under `g`.

A key identity is the semiconjugacy

- `Φ(z) = z + z^{-1}`
- `Φ(z^2) = Φ(z)^2 - 2`

so `g` corresponds to **squaring** `z ↦ z^2` after the change of variables `x = Φ(z)`.

Finite forward-invariant sets under squaring arise from **roots of unity**. This implies every irreducible factor of a dynamical polynomial is the minimal polynomial of a value `ζ + ζ^{-1}` where `ζ` is a root of unity (the “cyclotomic cosine” factors).

These factors are naturally indexed by the order `m` of `ζ`, and their degrees are:

- `deg(P_m) = φ(m)/2` for `m > 2` (with a few small linear exceptions).

## 2) Component decomposition by removing powers of 2

Under squaring, the order of a root of unity behaves as:

- `ord(ζ^2) = ord(ζ) / gcd(ord(ζ), 2)`.

So for odd `m` the order stays the same, while for even `m` it drops by a factor of 2.

That means the “factor graph” splits into independent components indexed by the odd part `m₀` of `m`:

- `m = 2^k m₀`, with fixed odd `m₀`.

For each component with odd `m₀ > 1`, the divisibility constraint becomes a simple **monotonicity condition** on exponents along the chain
`m₀ → 2m₀ → 4m₀ → …`:
exponents cannot increase when moving away from `m₀`.

This converts each component into a partition-type generating function whose allowed part-sizes are cumulative degree sums
`W_t = Σ_{k=0..t} deg(P_{2^k m₀})`.

## 3) The special orbit `{2, -2, 0}`

There is exactly one critical point for `g(x)=x^2-2`, at `x=0`, which creates a slightly different multiplicity constraint on the component
`m = 1,2,4,8,…`.

This component can still be expressed as an explicit 1‑variable generating function, built from products over powers of two and two simple geometric-series factors.

## 4) From a huge product to coefficients via power-series `exp`

All the “regular” components combine into a product of the form

- `F(x) = Π_{a≥1} (1 - x^a)^{-c[a]}`

where `c[a]` counts how many components contribute a geometric factor with part-size `a`.

Instead of multiplying thousands of factors directly, we use the logarithm:

- `log F(x) = Σ_{m≥1} (g[m]/m) x^m`
- `g[m] = Σ_{d|m} d · c[d]`

Then recover `F` by computing the **formal power series exponential**:

- `F(x) = exp(log F(x)) (mod x^{N+1})`.

## 5) Fast polynomial arithmetic with NTT

To compute series `exp`, `ln`, and `inv` efficiently, the code implements:

- Number Theoretic Transform (NTT) over `998244353`
- Newton iteration for series inverse
- Standard identity `ln A = ∫ A'/A`
- Newton iteration for series exponential

Finally, the total generating function is a single convolution between:

- the “regular” product `F(x)`
- the special component series

and the coefficient of `x^N` gives `S(N)`.

---

Files:

- `main.py` — full implementation and built-in asserts for `S(2)`, `S(5)`, `S(20)`
- `README.md` — this summary
