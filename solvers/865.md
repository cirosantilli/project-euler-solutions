# Project Euler 865 Solution - Triplicate Numbers

<https://projecteuler.net/problem=865>:

* [865.py](865.py)

This repository contains a single-file Python solution (`main.py`) that computes
\(T(10^4)\bmod 998244353\) with no external libraries.

## Key ideas

### 1) Lengths must be multiples of 3
Each operation removes exactly 3 digits, so a triplicate string must have length
\(\equiv 0 \pmod 3\). For \(T(n)\) we therefore only count lengths
\(3,6,9,\dots,3\lfloor n/3\rfloor\).

To speed things up we index states by \(m=\text{length}/3\) rather than by the
raw digit length.

### 2) Canonical “last-deletion” decomposition
Any reducible string can be seen as:

- an arbitrary triplicate prefix, followed by
- a **final block** whose reduction finishes with deleting three equal digits.

Focus on the **leftmost** of those three equal digits in the final block.
From that position to the end, the three equal digits can be arranged in only
three shapes:

1. `ddd` (the last three digits are already consecutive)
2. `d  X  dd` or `dd  X  d` (two symmetric shapes)
3. `d  X  d  Y  d` (two non-empty inner parts)

The inner parts `X` and `Y` must reduce to empty **without ever letting the
symbol `d` reach an end**, otherwise the “final block” would not be uniquely
identifiable.

### 3) Auxiliary DP for “protected” inner parts
Let `f[m]` count protected reducible strings of length `3*m` (the protected
symbol is treated abstractly; by symmetry it doesn’t matter which digit it is).

Let `dp0[m]` count all triplicate strings of length `3*m` (no leading rule), and
`dp1[m]` those with first digit nonzero.

The decomposition above yields recurrences that build `dp0`, `dp1`, and `f` from
smaller values.

### 4) Maintaining the needed convolution
Shape (3) needs the number of ways to split the inner length into two non-empty
protected parts:

\[
\text{mul}[t] = \sum_{a=1}^{t-1} f[a]\,f[t-a].
\]

This is computed incrementally in \(O(m^2)\) total time.

## Complexity
Let \(M=\lfloor 10^4/3 \rfloor = 3333\). The implementation performs two nested
loops over these indices and runs in \(O(M^2)\) time (about 10–12 million simple
integer operations) and \(O(M)\) memory.

## Correctness checks
The problem statement provides two values, which `main.py` asserts:

- \(T(6)=261\)
- \(T(30)=5576195181577716\)
