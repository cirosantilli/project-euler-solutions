# Project Euler 591 Solution - Best Approximations by Quadratic Integers

<https://projecteuler.net/problem=591>:

* [591.py](591.py)

This solution computes, for every non‑square integer `d < 100`, the quadratic integer

\[
BQA_d(\pi,n)=a+b\sqrt d,\qquad |a|\le n,\ |b|\le n
\]

that minimizes \(|a+b\sqrt d-\pi|\) for \(n=10^{13}\), and returns

\[
\sum_{2\le d<100,\ d\ \text{non-square}} |a|.
\]

## 1) Reducing to a rotation problem on the unit circle

Write \(\sqrt d = \lfloor\sqrt d\rfloor + \alpha\) with \(\alpha \in (0,1)\). Then

\[
b\sqrt d \bmod 1 = b\alpha \bmod 1.
\]

For a fixed integer \(b\), the best choice of \(a\) is the nearest integer to \(\pi-b\sqrt d\)
(as long as \(|a|\le n\), which restricts the feasible range of \(b\)). The resulting error is the
distance from \(\{b\alpha\}\) to \(\{\pi\}\) on the circle.

So we need: for a given bound \(B\), find \(b\in[0,B]\) that makes \(\{b\alpha\}\) as close as possible to a target
\(\beta=\{\pi\}\) (and also handle negative \(b\) via the target \(1-\beta=\{-\pi\}\)).

That is a classic *Kronecker sequence* / circle rotation problem.

## 2) Continued fractions and the α‑numeration of a real

Because \(\alpha = \{\sqrt d\}\) is a quadratic irrational, its continued fraction is purely periodic:

\[
\alpha = [0; a_1, a_2, \dots]\quad\text{(periodic)}.
\]

From the partial quotients \(a_k\) we build convergent denominators \(q_k\) and the associated
positive “error” sequence (notation from Cabanillas‑López & Labbé):

\[
\delta_k = (-1)^k(q_k\alpha - p_k) > 0,
\]
computed via the recurrence
\(\delta_k = -a_k\delta_{k-1} + \delta_{k-2}\) with \(\delta_{-1}=1,\ \delta_0=\alpha\).

Then the **α‑numeration** of a target \(\beta\in[0,1)\) is a digit sequence \((b_k)\) defined by the greedy algorithm:

- \(b_k = \min(a_k, \lceil \beta_{k-1}/\delta_{k-1}\rceil)\)
- \(\beta_k = b_k\delta_{k-1}-\beta_{k-1}\)

This is an Ostrowski‑style numeration system adapted to rotations.

## 3) Best left/right approximations from the digits

A key theorem (Propositions 9 and 10 in arXiv:1904.01874) characterizes all **best right** and **best left**
approximations of \(\beta\) by the Kronecker sequence \(\{n\alpha\}\) using only the digits \(b_k\) and denominators \(q_k\).

These approximations are exactly the points that can become the closest successor / predecessor of \(\beta\) as \(n\) grows.
So, with an upper bound \(B\), the closest point to \(\beta\) among \(\{n\alpha: 0\le n\le B\}\) must be one of those
explicit candidates.

The solver:
1. Computes enough continued fraction data \((a_k,q_k,\delta_k)\) for the needed bound.
2. Computes the α‑numeration digits \((b_k)\) of \(\beta\).
3. Enumerates the candidate indices described by the propositions (only **O(log B)** many, because digits are bounded).
4. Evaluates their circle distance to \(\beta\) and picks the best \(b\).

Negative \(b\) is handled by running the same routine with target \(1-\{\pi\}\).

## 4) High‑precision arithmetic

We need reliable comparisons around \(\approx 10^{-13}\) scales, so we compute \(\pi\) with the **Chudnovsky series**
using Python’s standard `decimal` module at ~140 digits of precision.

## 5) Complexity

For each \(d<100\), only ~60–80 continued fraction steps and a few hundred candidate checks are needed.
Overall runtime is easily fast enough in pure Python.

## Result

The program prints the Project Euler #591 answer:

\[
526007984625966
\]
