# Project Euler 437 Solution - Fibonacci Primitive Roots

<https://projecteuler.net/problem=437>:

* [437.py](437.py)

A number `g` is a **Fibonacci primitive root** modulo a prime `p` if:

1. `g` is a primitive root mod `p` (its multiplicative order is `p−1`), and
2. the powers of `g` satisfy Fibonacci’s recurrence, which is equivalent to  
   `g² ≡ g + 1 (mod p)`.

The task is to compute the sum of all primes `p < 100,000,000` that have **at least one** Fibonacci primitive root.

## Key techniques used

### 1) Reduce the “Fibonacci” condition to a quadratic congruence
From `g² ≡ g + 1 (mod p)`, multiplying by `gⁿ` yields `gⁿ + gⁿ⁺¹ ≡ gⁿ⁺²`, so it’s enough to solve:

- `g² − g − 1 ≡ 0 (mod p)`

Thus any Fibonacci primitive root must be one of the two roots of this quadratic (when roots exist).

### 2) Use quadratic reciprocity to pre-filter primes
The quadratic has solutions iff its discriminant is a quadratic residue:

- Discriminant = `5`
- Since `5 ≡ 1 (mod 4)`, we have `(5/p) = (p/5)`
- Quadratic residues mod `5` are `1` and `4`

So for `p ≠ 5`, solutions exist only when:

- `p ≡ 1 or 4 (mod 5)`  

This eliminates about half of all primes immediately.

### 3) Modular square roots with Tonelli–Shanks
For primes with `p ≡ 1 (mod 4)`, computing `√5 (mod p)` uses the **Tonelli–Shanks** algorithm.
For `p ≡ 3 (mod 4)`, a shortcut exists:

- `√5 ≡ 5^((p+1)/4) (mod p)`

The two roots are then:

- `(1 ± √5) / 2 (mod p)` (using `inv2 = (p+1)/2` for division by 2)

### 4) Primitive root test via factorization of `p−1`
An element `g` is a primitive root iff for every prime divisor `q` of `p−1`:

- `g^((p−1)/q) ≠ 1 (mod p)`

So the algorithm factors `p−1` into distinct prime factors and performs these modular exponentiation checks for each of the (at most) two quadratic roots.

To keep factorization fast, the code:
- strips small primes quickly, then
- uses a deterministic 32-bit Miller–Rabin test to stop early when the remaining cofactor is already prime.

### 5) Segmented sieve for primes up to `1e8`
Generating primes up to `100,000,000` is done with a **segmented sieve of Eratosthenes** over odd numbers only. This keeps memory usage manageable while still being fast.

## Built-in checks from the statement

The solution asserts the two values given in the problem statement:

- `8` is a Fibonacci primitive root of `11`
- There are `323` such primes below `10,000` and their sum is `1,480,491`

Run:

```bash
python3 main.py
```

or test a smaller limit:

```bash
python3 main.py 10000
```
