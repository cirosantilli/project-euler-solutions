# Project Euler 442 Solution - Eleven-free Integers

<https://projecteuler.net/problem=442>:

* [442.py](442.py)

This solution finds **E(10¹⁸)**, where **E(n)** is the *n-th positive “eleven-free” integer* (a base‑10 number whose digit string contains **no substring equal to 11ᵏ for any k ≥ 1**).

## Key techniques

### 1) Finite forbidden set (length cutoff)
For any target `x`, only forbidden strings with length `≤ len(str(x))` can appear as substrings.
So we only generate powers `11¹, 11², …` until their decimal length exceeds the current digit length.

### 2) Aho–Corasick automaton (multi-pattern substring detection)
All forbidden decimal strings are inserted into a trie, then failure links are built (BFS).
This produces a DFA-like automaton that can scan digits left-to-right and track the longest suffix that is also a prefix of some forbidden pattern.

Each automaton state is marked **bad** if it corresponds to having matched a forbidden pattern (directly or via failure links). Any digit transition into a bad state is disallowed.

### 3) Digit DP (count valid numbers ≤ X)
To compute how many eleven-free positive integers are `≤ X`, we do a standard digit DP over:
- position in the decimal string,
- automaton state,
- whether the number has “started” (to ignore leading zeros),
- tightness (whether the prefix equals `X`’s prefix).

This gives `count(X)` efficiently even for large `X` (≈ 20 digits).

### 4) Binary search for the n-th valid integer
`count(X)` is monotone non-decreasing, so we:
1. grow an upper bound `high` until `count(high) ≥ n`,
2. binary search the smallest `X` with `count(X) ≥ n`, which equals `E(n)`.

## Complexity
Let:
- `D = number of digits` (≈ 19–20 for this problem),
- `S = number of automaton states` (a few hundred at most).

Each `count(X)` is `O(D · S · 10)`, and binary search needs ~60 calls, so the whole run is fast in pure Python.
