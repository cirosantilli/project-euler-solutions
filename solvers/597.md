# Project Euler 597 Solution - Torpids

<https://projecteuler.net/problem=597>:

* [597.py](597.py)

This solution uses two ideas:

## 1) Convert speeds into exponentials with convenient rates

Each boat’s speed is `V = -log(U)` where `U ~ Uniform(0,1)`, so `V ~ Exp(1)`.

For a “target” located upstream, a boat at index `i` must cover a distance proportional to `(t - i)` (in units of the fixed starting gap).  
Define the *relative speed to the target*:

\[
W_i = \frac{V_i}{t-i}.
\]

If `V_i ~ Exp(1)`, then scaling gives

\[
W_i \sim \text{Exp}(\text{rate}=t-i).
\]

So within any set of boats racing toward a fixed target, the “slowest” boat is the one with the **minimum** `W_i`, and the probability that boat `m` is that minimum is

\[
\Pr(m \text{ is minimum})=\frac{t-m}{\sum_j (t-j)}.
\]

## 2) Recursive decomposition + track only permutation parity

The boat with the minimum `W` cannot bump anyone and becomes the **lowest** boat in the final ordering.

If boat `m` is lowest, then:

- Boats below `m` form an independent subproblem whose effective target becomes **boat `m`**.
- Boats above `m` form an independent subproblem whose target stays the original finish line.

This gives a Catalan-shaped recursion over outcomes — but we do **not** enumerate outcomes.

Instead we track only the **parity** of the resulting permutation using its sign:

- `+1` for even permutations
- `-1` for odd permutations

When `m` is moved to the front of the current interval `[l..r]`, it crosses `(m-l)` boats, flipping the sign by `(-1)^(m-l)`.
Because left and right subproblems are independent after conditioning, expected signs multiply.

So the expected sign satisfies:

\[
E(l,r,t) = \sum_{m=l}^{r}
\Pr(m)\cdot (-1)^{m-l}\cdot E(l,m-1,m)\cdot E(m+1,r,t).
\]

Finally,

\[
p_{\text{even}} = \frac{1 + E(1,n,t_0)}{2}.
\]

## Complexity

For `n = 13` this memoized recursion is tiny (milliseconds) and produces an **exact rational** result using Python’s `fractions.Fraction`.

The program asserts the two test values given in the statement:

- `p(3,160) = 56/135`
- `p(4,400) = 0.5107843137` (rounded to 10 digits)

and prints `p(13,1800)` rounded to 10 digits after the decimal point.
