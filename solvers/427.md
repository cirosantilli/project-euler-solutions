# Project Euler 427 Solution - $n$-sequences

<https://projecteuler.net/problem=427>:

* [427.py](427.py)

We sum, over all length-`n` sequences with values in `{1..n}`, the length of the longest contiguous run of equal values.

## 1) Run-length (composition) viewpoint

Any sequence can be uniquely described by its **run lengths**:

- Example: `1,1,1,4,4,2` has run lengths `(3,2,1)`.

So every sequence corresponds to a **composition** of `n` (ordered positive parts summing to `n`).

For a fixed composition with `b` runs:

- Choose the value of the first run: `n` choices
- Each subsequent run must differ from the previous run’s value: `(n-1)` choices each

So the number of sequences with that run-length composition is:

`n · (n-1)^(b-1)`.

This gives a clean exact checker for small `n` by iterating all `2^(n-1)` compositions.

## 2) Tail-sum identity for the maximum

Let `A_k` be the number of sequences with longest run `< k` (i.e. **no run of length `k`**).

For any integer-valued `L`:

`L = Σ_{k≥1} [L ≥ k]`.

Summing over all sequences:

`f(n) = Σ_{k=1..n} count(L ≥ k)`
`     = Σ_{k=1..n} (n^n - A_k)`
`     = n^(n+1) - Σ_{k=1..n} A_k`.

So the problem becomes computing all `A_k` efficiently.

## 3) Counting `A_k` via a recurrence and a closed form

Fix `k`. Let `h_i` satisfy:

- `h_0 = 1`
- `h_i = n^i` for `0 ≤ i < k`
- `h_i = n·h_{i-1} + (1-n)·h_{i-k}` for `i ≥ k`

Then the desired count is:

`A_k = h_n - h_{n-k}`.

A standard “weighted steps” interpretation (steps of size `1` with weight `n`, or size `k` with weight `1-n`) yields a closed form:

`h_N = Σ_{t=0..⌊N/k⌋} n^(N-tk) (1-n)^t · C(N-tk+t, t)`.

## 4) Fast modular evaluation

We need `f(7,500,000) mod 1,000,000,009`.

To evaluate the binomial terms quickly:

- Precompute factorials `fact[i]` and inverse factorials `invfact[i]` modulo `MOD`
- Precompute helper arrays
  - `A[m] = n^m / m!`
  - `B[t] = (1-n)^t / t!`

Then each summand becomes:

`n^(N-tk) (1-n)^t · C(N-tk+t, t) = fact[m+t] · A[m] · B[t]`.

The total work is dominated by `Σ_{k=1..n} ⌊n/k⌋`, i.e. `O(n log n)` modular operations.

## 5) Tests

The statement provides:

- `f(3)=45`
- `f(7)=1403689`
- `f(11)=481496895121`

`main.py` asserts these using the exact composition-based computation (only `2^(n-1)` compositions, so it is fast for these small `n`).
