# Project Euler 923 Solution - Young's Game B

<https://projecteuler.net/problem=923>:

* [923.py](923.py)

This solution counts **ordered** selections of `m` staircase-shaped Young diagrams (weight ≤ `w`) for which the horizontal player **Right** (who moves first) wins under optimal play.

## 1) Reduce each staircase to a hook

A staircase `(a,b,k)` can be written as a partition whose row lengths are

- `k·b` repeated `a` times,
- `(k-1)·b` repeated `a` times,
- …,
- `b` repeated `a` times.

A key simplification is that the game value is unchanged if we repeatedly remove the first row and the first column **together** (this corresponds to one player “answering” the other so the token effectively moves diagonally). Removing as much as possible leaves a **hook** shape:

- a single row `(M)`  
- a single column `(1^N)`  
- or an L-shape `(M, 1^(N-1))` with `M,N ≥ 2`

For a partition `λ`, if `d` is its Durfee size (`max r with λ_r ≥ r`), then the reduced hook is determined by the `d`-th row/column:

- `M = λ_d - d + 1`
- `N = (#rows with λ_i ≥ d) - d + 1`

The staircase’s block structure lets `d`, `M`, and `N` be computed in **O(k)** time without building the full diagram.

## 2) Hook values become integers or “hot” components

For the reduced hook `(M, 1^(N-1))`:

- If `N = 1` (a row), the value is the integer `M - 1`.
- If `M = 1` (a column), the value is the integer `-(N - 1)`.
- If `M,N ≥ 2`, the value is a hot component `{L | R}` with  
  `L = M - 2` and `R = -(N - 2)`.

These hot components behave like “switches”: the first move on that component freezes it into an integer.

## 3) Resolve hot components by descending temperature

For a hot component `{L | R}`, define its **temperature** as `t = L - R` (nonnegative here).

In an optimal-play sum, while any hot components remain, both players always play on a hottest remaining one. Processing hot components in descending `t` gives the correct final numeric value. The only extra detail needed is the **parity** of how many hot components have been played so far (it determines whose turn it is when each hot component is taken).

After all hot components are resolved, the game is purely numeric:

- Right wins if the final sum is `> 0`.
- If the final sum is `0`, Right wins exactly when an **odd** number of hot components were present (then the opponent is to move in a zero position).

## 4) Count ordered selections via an EGF-style DP

Many different staircases collapse to the same reduced value type. If a type occurs `c` times among all staircases with weight ≤ `w`, choosing `k` copies of that type contributes a factor:

- `c^k / k!`

Using these factors lets us count multisets cleanly, and then convert to ordered sequences by multiplying by `m!`.

Two small DPs are used:

- one over hot types (tracking `used`, `parity`, and current sum),
- one over integer types (tracking `used` and current sum),

followed by a merge step applying the win rule.

All arithmetic is done modulo `1_000_000_007`.
