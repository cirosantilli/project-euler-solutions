# Project Euler 466 Solution - Distinct Terms in a Multiplication Table

<https://projecteuler.net/problem=466>:

* [466.py](466.py)

This repo contains a pure-Python solution for **Project Euler 466: _Distinct Terms in a Multiplication Table_**.

## Core idea: partition by the maximal “row factor”

Let

- `P(m, n)` be the number of distinct values in `{ i*j | 1 ≤ i ≤ m, 1 ≤ j ≤ n }`.
- For any positive integer `x`, define `d(x)` as the **largest divisor of `x` that is ≤ m**.

Two key facts:

1. **Membership test**
   - If `x` appears in the table, then there exists some `i ≤ m` dividing `x` with `x/i ≤ n`.
   - Among such divisors, the largest possible one is exactly `d(x)`.
   - Therefore:  
     **`x` appears iff `x / d(x) ≤ n`.**

2. **Unique partition**
   - Every `x` has a unique `d(x)`, so we can count distinct products by summing over all possible `d`:
     - write `x = d * r`
     - require `1 ≤ r ≤ n`
     - require `d(x) = d` (i.e. no larger divisor ≤ m divides `x`)

So we compute:

\[
P(m,n) \;=\; \sum_{d=1}^{m} \#\{ r \le n \;:\; d(r\cdot d)=d \}
\]

## Turning “no larger divisor divides x” into a condition on r

Fix `d` and write `x = d*r`.

For any `e` with `d < e ≤ m`:

- `e | x`  ⇔  `e | d*r`
- Let `g = gcd(e, d)`.
- Then `e | d*r` ⇔ `(e/g) | r`.

So to ensure `d(x) = d`, we must avoid all divisibility constraints:

- `r` must **not** be divisible by any value in  
  `F_d = { e / gcd(e,d) | e = d+1..m }`.

Many elements of `F_d` are redundant: if `a | b` then “divisible by b” is already covered by “divisible by a”.
We reduce `F_d` to its minimal elements under divisibility to speed up inclusion-exclusion.

## Counting numbers not divisible by a set

For each `d`, we need:

- `good(d) = # { r ≤ n : r is not divisible by any f in F_d }`
- which equals `n - (# divisible by at least one forbidden f)`

We compute “divisible by at least one” using:

- **inclusion–exclusion over LCMs**
- with a recursive formula
- and **memoization** on `(start_index, current_lcm)`

Any branch where `lcm > n` contributes `0` and is pruned.

Because `m = 64`, the forbidden numbers are small and LCMs grow quickly, so this is fast.

## Implementation highlights

- `F_d` construction: `e // gcd(e, d)` for `e = d+1..m`
- redundancy removal: keep only numbers that are not multiples of earlier kept numbers
- inclusion–exclusion recursion:
  - adds `⌊n / lcm⌋` for a chosen divisor
  - subtracts the contribution of deeper subsets
- caching:
  - many `d` share the same reduced `F_d`, so the code caches results per `F_d`

## Files

- `main.py` — computes the requested value and includes asserts for all sample/test values from the statement.
- `README.md` — this explanation.
