# Project Euler 765 Solution - Trillionaire

<https://projecteuler.net/problem=765>:

* [765.py](765.py)

This solution uses two key ideas to turn a seemingly “continuous control” problem into a finite combinatorial calculation.

## 1) Change of measure: make the game fair

If we temporarily evaluate the game under a *hypothetical* fair-coin model (win/lose each with probability 1/2), then **no matter what betting strategy you use**, your wealth after each round satisfies:

- After betting `b` with current wealth `x`, you move to `x+b` or `x-b`.
- With win/lose equally likely, the conditional expectation is exactly `x`.

So under the fair-coin model, the wealth process is a **martingale** and the expected final wealth is fixed:
`E[X_N] = X_0 = 1`.

## 2) “Success paths” are limited by a budget

To be a trillionaire at the end, your terminal wealth on a successful outcome-path must be at least `M = 10^12`.

Under the fair-coin model, every length-`N` sequence of wins/losses has probability `1 / 2^N`. If you guarantee `X_N ≥ M` on a set `S` of outcome-paths, then:

`E[X_N] ≥ M * |S| / 2^N`.

But `E[X_N]` must equal `1`, so:

`|S| ≤ floor(2^N / M)`.

That is: there’s a hard cap on how many different win/loss sequences can be made “successful”, regardless of how cleverly you vary bets.

## 3) Spend the budget on the most likely paths

We want to maximize the *real* success probability, where the coin is biased (`p=0.6` for a win).

Because the coin tosses are i.i.d., the probability of any specific outcome-path depends only on how many wins it contains. Paths with **more wins** are more likely when `p > 1/2`.

So the optimal use of the limited budget `floor(2^N / M)` is:

- Take all paths with very high win counts (starting from `N` wins downwards),
- then take as many as needed from the next win-count level to fill the remaining budget.

This reduces the answer to:

- computing binomial coefficients `C(N,k)`,
- finding the threshold win count `k0` where the budget runs out,
- summing exact probabilities over:
  - all `k > k0` (full levels), plus
  - a partial number of `k0`-win paths.

## 4) Exact arithmetic and rounding

The final probability is a rational number. With `p = 3/5` and `q = 2/5`, each path with `k` wins has probability:

`3^k * 2^(N-k) / 5^N`.

The code keeps all computations as Python big integers and performs “round half up” to 10 digits after the decimal point using integer division (no floating point error).
