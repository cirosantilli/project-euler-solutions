# Project Euler 627 Solution - Counting Products

<https://projecteuler.net/problem=627>:

* [627.py](627.py)

We want

- `S = { x1*x2*…*xn | 1 ≤ xi ≤ m }`
- `F(m,n) = |S|`
- compute `F(30,10001) mod 1_000_000_007`.

## 1) Turn products into lattice points

Every integer `x ≤ 30` can be written as

\[
x = \prod_{p \le 30} p^{e_p(x)}
\]

so it corresponds to an exponent vector `v(x) = (e_p(x))` in \(\mathbb{Z}^{10}\) (there are 10 primes ≤ 30).

Multiplying numbers adds exponent vectors:

\[
v(x_1x_2\cdots x_n) = v(x_1)+\cdots+v(x_n)
\]

So **distinct products** correspond to **distinct sums of `n` vectors**.

Because `1` is allowed, we can always pad with ones, so the set of achievable exponent vectors is “closed downward” and behaves nicely under scaling.

## 2) Ehrhart polynomial viewpoint

Let \(P\) be the convex hull of the exponent vectors \(v(1), v(2), \dots, v(30)\).
For this problem, the set of achievable exponent vectors for length `n` coincides with the lattice points in the dilate \(nP\).
Hence

\[
F(30,n) = |nP \cap \mathbb{Z}^{10}|
\]

A key theorem (Ehrhart’s theorem) says that for a lattice polytope in dimension \(d\),

\[
|nP \cap \mathbb{Z}^d|
\]

is a **polynomial in `n` of degree `d`** for all integers \(n \ge 0\).  
Here \(d=10\), so \(F(30,n)\) is a degree‑10 polynomial.

## 3) Using Ehrhart reciprocity to find many roots

Ehrhart reciprocity relates negative inputs to interior lattice points:

\[
L_P(-t) = (-1)^d \, L_{\mathrm{int}(P)}(t)
\]

For `m = 30`, there are **7 primes greater than \(\sqrt{30}\)**:

\[
7, 11, 13, 17, 19, 23, 29
\]

In any number ≤ 30, each of these primes appears with exponent **either 0 or 1**, and never together with another of these “large primes” in the same factor.  
That forces every point in \(tP\) to have the **sum** of those 7 coordinates ≤ \(t\).  
Therefore, for \(t = 1,2,\dots,7\), there cannot be an *interior* lattice point (an interior point would need all 7 of those coordinates to be ≥ 1 simultaneously).

So:

\[
L_{\mathrm{int}(P)}(t) = 0 \quad (t=1..7)
\quad\Rightarrow\quad
F(30,-t)=0 \quad (t=1..7)
\]

Hence \((n+1)(n+2)\cdots(n+7)\) divides the degree‑10 polynomial, and we can write

\[
F(30,n) = (n+1)(n+2)\cdots(n+7)\;\; C(n)
\]

where \(C(n)\) is only a **cubic** polynomial.

## 4) Recover the cubic from a few small values

A cubic is determined by 4 points. We compute `F(30,n)` exactly for small `n` by brute force:

- `n=0..3` is tiny (`30^3 = 27,000` products)

Then:

1. Divide out the rising factorial factor to get `C(0..3)` in modular arithmetic.
2. Evaluate the cubic at `n=10001` using finite differences (equivalently, interpolation).
3. Multiply back by `(n+1)(n+2)…(n+7)` modulo \(10^9+7\).

We also verify the fitted polynomial against additional brute-force values (`n=4,5`) as a sanity check.

## Complexity

- Brute forcing up to `n=5` does a few hundred thousand set insertions: tiny.
- The final evaluation is \(O(1)\).

No external libraries are used (only Python’s standard library).
