# Project Euler 684 Solution - Inverse Digit Sum

<https://projecteuler.net/problem=684>:

* [684.py](684.py)

This solution computes

\[
\sum_{i=2}^{90} S(f_i) \pmod{1{,}000{,}000{,}007}
\]

where:

- `s(n)` is the smallest integer whose **digit sum** is `n`
- \(\displaystyle S(k) = \sum_{n=1}^k s(n)\)
- \(f_i\) are Fibonacci numbers: \(f_0=0\), \(f_1=1\), \(f_i=f_{i-1}+f_{i-2}\)

## Main techniques

### 1) Constructing the minimal number with a given digit sum

Write \(n = 9q + r\) with \(0 \le r \le 8\). To minimize the value of the number:

- use as many trailing `9`s as possible (they are “cheap” in more significant digits),
- put the remaining digit \(r\) (if any) in the most significant position.

This yields the closed form:

\[
s(n) = (r+1)\cdot 10^q - 1
\]

(When \(r=0\), this is just \(10^q-1\), i.e., `q` digits of `9`.)

### 2) Block summation + geometric series

For a fixed \(q\), the nine values \(r=0..8\) form a block:

\[
s(9q+r) = (r+1)\cdot 10^q - 1
\]

Summing over a full block:

\[
\sum_{r=0}^{8} s(9q+r) = 45\cdot 10^q - 9
\]

So \(S(k)\) becomes:

- a sum of full blocks for \(q'=0..q-1\)
- plus one partial block for the final \(q\)

The full-block contribution involves \(\sum 10^{q'}\), a geometric series. Since we only need the result **modulo** a prime, we can compute powers \(10^q \bmod M\) using fast modular exponentiation (`pow(10, q, M)`) and do all arithmetic mod \(M\).

### 3) Fibonacci generation

Fibonacci numbers up to \(f_{90}\) are generated iteratively with constant memory, and for each \(f_i\) we compute `S(f_i)` in \(O(\log f_i)\) time (because modular exponentiation is logarithmic in the exponent).

## Quick checks

The code includes asserts for the statement’s check values:

- `s(10) = 19`
- `S(20) = 1074`
