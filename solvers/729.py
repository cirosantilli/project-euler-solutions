#!/usr/bin/env python3
"""
Project Euler 729
Range of periodic sequence

We must compute S(25) (rounded to 4 decimals), where S(P) is the sum of the ranges
(max - min) of all real periodic sequences generated by:
    a_{n+1} = a_n - 1/a_n
with period <= P.

No third-party libraries are used.
"""

import math


def sum_ranges_upto(P: int) -> float:
    """
    Return S(P): sum of ranges of all real periodic sequences with period <= P.
    """
    if P < 2:
        return 0.0

    hypot = math.hypot
    fsum = math.fsum
    half = 0.5
    tol = 1e-16
    fp_max_iter = 12
    chunk_size = 50_000  # chunked exact summation

    total = 0.0

    for n in range(2, P + 1):
        # a[1..n] holds a binary Lyndon word (aperiodic necklace representative)
        a = [0] * (n + 1)
        chunk: list[float] = []

        def flush() -> None:
            nonlocal total
            if chunk:
                total += fsum(chunk)
                chunk.clear()

        def handle_one_necklace() -> None:
            """
            For the current a[1..n] (aperiodic necklace rep), compute its cycle range
            and add n * range to the running chunk.
            """
            # Fixed point of the composed inverse branches:
            #   x = inv_{a[1]}(inv_{a[2]}(... inv_{a[n]}(x) ...))
            x = 0.0
            for _ in range(fp_max_iter):
                y = x
                # apply composed inverses
                for i in range(1, n + 1):
                    s = hypot(y, 2.0)  # sqrt(y*y + 4)
                    if a[i] == 0:
                        y = half * (y + s)
                    else:
                        y = half * (y - s)
                if abs(y - x) <= tol * (1.0 + abs(y)):
                    x = y
                    break
                x = y

            # Compute range by walking the cycle via the same inverse branches.
            # This produces the same set of orbit values (in reverse order) but is
            # numerically stable.
            y = x
            mn = y
            mx = y
            for i in range(1, n):
                s = hypot(y, 2.0)
                if a[i] == 0:
                    y = half * (y + s)
                else:
                    y = half * (y - s)
                if y < mn:
                    mn = y
                if y > mx:
                    mx = y

            chunk.append(n * (mx - mn))
            if len(chunk) >= chunk_size:
                flush()

        # Fredricksen–Kessler–Maiorana recursion for binary necklaces.
        # When t>n, p==n selects the aperiodic necklaces (Lyndon words),
        # which correspond to cycles of exact period n.
        def rec(t: int, p: int) -> None:
            if t > n:
                if p == n:
                    handle_one_necklace()
                return

            a[t] = a[t - p]
            rec(t + 1, p)

            if a[t - p] == 0:
                a[t] = 1
                rec(t + 1, t)

        rec(1, 1)
        flush()

    return total


def _self_test() -> None:
    # Values given in the problem statement (rounded to 4 decimals).
    assert f"{sum_ranges_upto(2):.4f}" == "2.8284"
    assert f"{sum_ranges_upto(3):.4f}" == "14.6461"
    assert f"{sum_ranges_upto(5):.4f}" == "124.1056"


def main() -> None:
    _self_test()
    ans = sum_ranges_upto(25)
    print(f"{ans:.4f}")


if __name__ == "__main__":
    main()
