# Project Euler 920 Solution - Tau Numbers

<https://projecteuler.net/problem=920>:

* [920.py](920.py)

This repository contains a self-contained Python solution (`main.py`) for Project Euler problem 920.

## Key ideas

### 1) Work with prime-exponent vectors
Any positive integer can be written as:

\[
 n = \prod_i p_i^{a_i}
\]

Then the divisor-count function is:

\[
 \tau(n) = \prod_i (a_i + 1)
\]

So fixing the multiset of exponents \((a_1, a_2, \dots)\) fixes the value of \(k = \tau(n)\), independent of which primes are used.

### 2) Turn “\(\tau(n) \mid n\)” into prime-power constraints
We need \(k = \tau(n)\) to divide \(n\). For each prime \(q\), this means:

\[
 v_q(n) \ge v_q(k)
\]

In particular, if a prime \(q\) divides \(k\), then \(q\) must appear among the primes in \(n\)’s factorization, and its exponent in \(n\) must be at least \(v_q(k)\).

Because \(k\) is built from small factors \((a_i+1)\), we can factor \(k\) cheaply by precomputing the factorizations of the small integers \(2,3,\dots\).

### 3) Enumerate only feasible exponent multisets
For a fixed exponent multiset, the smallest possible number (ignoring the divisibility constraint) is obtained by assigning the largest exponents to the smallest primes (rearrangement principle). That gives a strong lower bound.

The program generates all non-increasing exponent vectors \(a_1 \ge a_2 \ge \dots \ge 1\) such that this *unconstrained* minimum is \(\le 10^{16}\). There are only a few tens of thousands of such vectors.

### 4) For each exponent multiset, find the minimal valid assignment
Given the required primes (from factoring \(k\)):

- those primes must be included
- each must receive an exponent large enough to satisfy its \(v_q(k)\) requirement

The remaining primes (if the exponent list is longer than the number of required primes) should be filled with the smallest primes not already required.

Only the mapping from exponents to required primes needs search; after that, the remaining exponents are paired greedily with filler primes (largest exponents to smallest primes). A small backtracking search over required primes is enough.

### 5) Build `m(k)` and sum to get `M(16)`
Whenever a valid number \(n\) is found for some \(k\), we keep the smallest such \(n\) as `m(k)`.
Finally, `M(16)` is the sum of all stored `m(k)` values (they are all \(\le 10^{16}\) by construction).

## Correctness checks
The script includes assertions for the sample values given in the problem statement:

- `m(8) = 24`
- `m(12) = 60`
- `m(16) = 384`
- `M(3) = 3189`

## Running

```bash
python3 main.py
```

It will print the computed value of `M(16)`.
