# Project Euler 386 Solution - Maximum Length of an Antichain

<https://projecteuler.net/problem=386>:

* [386.py](386.py)

We want:

\[
\sum_{1 \le n \le 10^8} N(n)
\]

where \(N(n)\) is the maximum size of an *antichain* in the divisor set \(S(n)\) under divisibility.

## 1) Divisors form a product-of-chains poset

If

\[
n=\prod_{i=1}^r p_i^{a_i},
\]

then each divisor corresponds to a vector \((e_1,\dots,e_r)\) with \(0\le e_i\le a_i\), ordered componentwise.
So the divisor poset is a direct product of chains of lengths \((a_i+1)\).

A classic fact (Sperner-type results for products of chains) implies the poset is **Sperner**: the largest antichain
is attained by a single rank level.

The natural rank is the total exponent sum:

\[
\text{rank}(e_1,\dots,e_r)=e_1+\cdots+e_r.
\]

## 2) Reduce \(N(n)\) to a tiny generating-function DP

The number of divisors of rank \(k\) is the coefficient of \(x^k\) in:

\[
\prod_{i=1}^r (1+x+\cdots+x^{a_i}).
\]

Therefore:

*Compute all coefficients (degree \(\sum a_i\)), then take the maximum.*

Since \(n\le 10^8\) implies \(\sum a_i\) is small (at most 26 for \(2^{26}\)), this DP is extremely fast.

## 3) Group by exponent multisets

The value \(N(n)\) depends only on the multiset \(\{a_1,\dots,a_r\}\), not on which primes appear.

So we:

1. Enumerate all feasible exponent multisets for \(n \le 10^8\) (there are few, because at most 9 distinct primes fit).
2. For each multiset:
   - compute its antichain width \(N(\cdot)\) via the DP above,
   - count how many integers \(n\le 10^8\) have exactly that multiset,
   - add `count * width` to the final sum.

## 4) Counting how many numbers realize a given multiset

For a multiset of exponents sorted non-increasing, we assign distinct primes to those exponents.
To avoid overcounting when some exponents are equal, we impose an ordering only *within equal-exponent groups*
(primes strictly increasing there).

The counting itself is done with a short recursion over prime choices, using strong numeric bounds so that only
small primes are explicitly iterated.

When the recursion reaches the last prime, the remaining count is obtained via a fast prime-counting function \(\pi(x)\).

## 5) Fast \(\pi(x)\) with Lehmer prime counting

Direct sieving to \(10^8\) in pure Python is memory/time heavy.
Instead, the solution uses a standard **Meisselâ€“Lehmer** prime counting implementation:

- sieve primes up to \(10^6\),
- use the Lehmer formula plus a cached `phi(x, s)` to compute \(\pi(x)\) for \(x \le 10^8\) quickly,
- cache \(\pi(x)\) values across calls (the recursion asks for many repeats).

This makes the overall approach feasible without iterating over all \(n \le 10^8\).
