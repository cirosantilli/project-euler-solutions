# Project Euler 847 Solution - Jack's Bean

<https://projecteuler.net/problem=847>:

* [847.py](847.py)

This repository contains a standalone solution (`main.py`) that computes **H(R₁₉) mod 1,000,000,007**.

## Key ideas

### 1) Reduce the problem to counting by total bean count
For a fixed total number of beans

- \(s = a+b+c\)
- the number of triples \((a,b,c)\) with that sum is \(\binom{s+2}{2}\).

So

\[
H(N) = \sum_{s=1}^{N} \Big(\binom{s+2}{2} \cdot \overline h(s)\Big)
\]

where \(\overline h(s)\) is the average contribution per triple. The trick is that we can avoid per-triple computation entirely.

### 2) Only two possible values for \(h(a,b,c)\)
Let \(m = \lceil \log_2(s) \rceil\). Because each question is yes/no, information theory says we need at least \(m\) questions.

Empirically (and provably via the structure of allowed splits), for **three plates** we always have:

\[
 h(a,b,c) \in \{ m,\; m+1 \}.
\]

So for each sum \(s\), we only need to count how many triples are **“bad”** (need \(m+1\)) versus “good” (need \(m\)).

### 3) The base bad cases are exactly “no plate is large enough”
When \(m=\lceil\log_2(s)\rceil\), let \(M = 2^{m-1}\). Any first question must choose a subset of size \(k\) such that both branches remain solvable in \(m-1\) questions:

- YES branch: subset size \(k \le M\)
- NO branch: remaining candidates \(s-k \le M\)

The second condition forces \(k \ge s-M\). Define \(L = s-M\).

If **every** plate has fewer than \(L\) beans (i.e. \(\max(a,b,c) < L\)), then such a first question is impossible, and the triple is automatically bad.

For the special parameters in this problem (cap = \(L-1\) and sum = \(M+L\)), the count of these “too-balanced” triples simplifies to a plain stars-and-bars value:

\[
\#\{(a,b,c): a+b+c=M+L,\; 0\le a,b,c\le L-1\}
= \binom{2L-M-1}{2}
\]

whenever it is nonzero.

### 4) A clean recursion for the remaining bad cases
When \(L\) is large enough, even if some plate *is* large enough, the first move is effectively forced to take a full half-block of size \(M\). In that situation, bad configurations “lift” from smaller sums:

- If a sum-\(L\) triple is bad, then adding \(M\) beans to **one** plate yields a bad sum-\((M+L)\) triple.
- There are 3 choices of which plate receives the added \(M\), so this contributes a factor of 3.

This produces a recursion of the form:

\[
\text{bad}(M+L) = \binom{2L-M-1}{2} + 3\,\text{bad}(L)
\]

once \(L\) is beyond a simple threshold (derived in code as `t_k`).

Crucially, this recursion uses the **binary decomposition** of the sum: each step replaces \(s\) by a remainder \(L\le s/2\), so it runs in \(O(\log N)\) time.

### 5) Fast prefix sums
The final answer needs

- \(\sum_{s\le N} \binom{s+2}{2}\,\lceil\log_2(s)\rceil\), and
- \(\sum_{s\le N} \text{bad}(s)\).

Both are computed by splitting \([1,N]\) into power-of-two blocks and using polynomial closed forms for

- \(\sum s\)
- \(\sum s^2\)

plus the recursion above for the bad-prefix function.

## Complexity

- Time: \(O(\log N)\)
- Memory: \(O(\log N)\) (memoized recursion)

## Running

```bash
python3 main.py
```

The script runs the problem-statement asserts and prints the required value modulo 1,000,000,007.
