# Project Euler 723 Solution - Pythagorean Quadrilaterals

<https://projecteuler.net/problem=723>:

* [723.py](723.py)

This solution computes:

\[
S(n)=\sum_{d\mid n} F(d)
\]

where `F(d)` counts *pythagorean lattice grid quadrilaterals* whose vertices lie on the circle:

\[
x^2+y^2 = d
\]

and whose side lengths satisfy:

\[
a^2+b^2+c^2+d^2 = 8d
\]

(when the circumradius is \(\sqrt{d}\)).

---

## 1. Key Geometry Transformation

Let the quadrilateral vertices be lattice points \(A,B,C,D\) on the circle centered at the origin.

A known identity converts the side constraint into a diagonal-midpoint condition:

\[
(A+C)\cdot(B+D)=0
\]

That means the **midpoints of the two diagonals are orthogonal**.

Define:

- \(s_1 = A+C\)
- \(s_2 = B+D\)

Then the condition becomes:

- \(s_1 \perp s_2\)

Additionally, for non-diameter diagonals, the diagonals cross iff:

\[
|s_1|^2 + |s_2|^2 < 4d
\]

The strict inequality excludes endpoint collisions (shared vertices).

---

## 2. Counting via Gaussian Integers

Points on the circle correspond to Gaussian integers:

\[
x+iy \quad \text{with norm } x^2+y^2=d
\]

For integers using only primes \(p\equiv 1 \pmod 4\) (and powers of 2), all representations can be generated multiplicatively from prime power representations in \(\mathbb{Z}[i]\).

We generate all solutions to:

\[
x^2+y^2 = m
\]

by building Gaussian products from prime powers and rotating by the four unit multiples.

---

## 3. The `Q(m)` Core Count

For each integer \(m\), define `Q_plain(m)`:

- Count representations \((x,y)\) with:
  - \(x^2+y^2=m\)
  - \(y>0\)
  - \(x\neq 0\)

Group them by \(|x|=G\), giving weights `c[G]`.

Then the number of **ordered** diagonal pairs that produce a valid quadrilateral (non-diameter case) is:

\[
Q(m)=\sum_{G_1^2+G_2^2<m} c[G_1]c[G_2]
\]

This is evaluated efficiently using a sorted two-pointer sweep (rather than \(O(k^2)\)).

---

## 4. Primitive Direction Weights

Orthogonal midpoint vectors share a *primitive lattice direction* of squared length \(L\).

The number of primitive directions of norm \(L\) is `r2_prim(L)`, computed via:

\[
r_2^\*(n)=\sum_{k^2\mid n} \mu(k)\,r_2(n/k^2)
\]

We use only primes whose exponent â‰¥ 2, so this sum is tiny.

---

## 5. Swapped-Sum Optimization for S(n)

Naively computing `F(d)` for each divisor `d|n` would repeat many divisor loops.

Because `n` is **odd**, we exploit:

- Only `L=t` and `L=2t` contribute
- A divisor sum convolution reduces the total cost to about \(O(\tau(n)^2)\), where \(\tau(n)=2688\)

This yields a feasible runtime without external libraries.

---

## 6. Validation

The code includes asserts for statement test values:

- `F(1)=1`
- `F(2)=1`
- `F(5)=38`
- `F(25)=167`

The final answer is computed and printed, **never hard-coded**.

---
