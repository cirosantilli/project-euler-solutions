# Project Euler 261 Solution - Pivotal Square Sums

<https://projecteuler.net/problem=261>:

* [261.py](261.py)

This solution computes the sum of all **distinct square pivots** `k ≤ 10^10`.

A square pivot is a number `k` for which there exist integers `m > 0` and `n ≥ k` such that:

- Left side: sum of consecutive squares from `(k-m)^2` up to `k^2` (inclusive, `m+1` terms)
- Right side: sum of consecutive squares from `(n+1)^2` to `(n+m)^2` (`m` terms)

---

## Core Techniques Used

### 1) Algebraic Reduction Using Closed Forms
Use the sum-of-squares formula:

\[
S(t)=\frac{t(t+1)(2t+1)}{6}
\]

Rewrite both sums with `S()` and simplify. After cancellation, the condition reduces to a **quadratic Diophantine constraint** that can be rearranged into:

\[
x^2 = ma,\quad t^2 = (m+1)(a+1)
\]

where `x = 2k - m` and `t = 2n + m + 1`.

---

### 2) Squarefree Decomposition
Write:

- \( m = s p^2 \) where `s` is squarefree
- \( m+1 = g r^2 \) where `g` is squarefree

This eliminates square factors and produces a cleaner Pell-type equation.

---

### 3) Pell-Type Equation Formulation
From the squarefree reductions, one obtains:

\[
g u^2 - s q^2 = 1
\]

which converts to:

\[
x^2 - D y^2 = g,\quad D = s g
\]

So for each `m`, we solve:

- a Pell-type equation with **squarefree discriminant** `D`
- iterate solutions using the **fundamental unit** of the Pell equation:

\[
x^2 - D y^2 = 1
\]

---

### 4) Fundamental Pell Solution via Continued Fractions
For each distinct `D`, compute the minimal `(x1, y1)` solving:

\[
x_1^2 - D y_1^2 = 1
\]

using the **continued fraction expansion** of `sqrt(D)`.

Results are cached since many `m` share the same `D`.

---

### 5) Solution Generation by Unit Multiplication
Given a starting solution `(x0, y0)` of:

\[
x^2 - D y^2 = g
\]

generate infinitely many via:

\[
(x + y\sqrt{D}) \leftarrow (x + y\sqrt{D}) (x_1 + y_1\sqrt{D})
\]

This produces all candidate `(q,u)` pairs for each `m`, and thus candidate pivots `k`.

---

### 6) Tight Bounding on `m`
A crucial monotonicity argument from `n ≥ k` implies:

\[
k \ge 2m(m+1)
\]

Thus for `k ≤ 10^10`, we only need:

\[
m \le 70710
\]

making iteration feasible.

---

## Correctness Checks
The problem statement lists small pivots:

- `4, 21, 24, 110`

The program asserts they appear in the computed pivot set.

---

## Performance
- Iterates only `m ≤ 70710`
- Each `m` produces a short Pell orbit (logarithmic growth)
- Caching Pell fundamentals ensures efficiency

Runs in well under a second in CPython on typical hardware.
