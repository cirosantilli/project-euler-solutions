# Project Euler 927 Solution - Prime-ary Tree

<https://projecteuler.net/problem=927>:

* [927.py](927.py)

This repository contains a pure-Python solution for **Project Euler 927**.

## Key observations

### 1) Tree counting recurrence
Let `t_k(n)` be the number of full `k`-ary trees of height at most `n`.
A tree is either
- a leaf, or
- a root with `k` ordered children, each itself a full `k`-ary tree of height at most `n-1`.

So

- `t_k(0) = 1`
- `t_k(n) = 1 + t_k(n-1)^k`

For a fixed `k`, the sequence modulo `m` is generated by iterating the map

`f_k(x) = 1 + x^k (mod m)`

starting at `x = 1`.

### 2) Reaching 0 is equivalent to being on the same cycle
`m ∈ S_k` means there exists `n` with `t_k(n) ≡ 0 (mod m)`, i.e. the orbit of `1` under `f_k` reaches `0`.
Since `f_k(0) = 1`, if `0` is ever reached then the orbit immediately returns to `1`, so the orbit is purely periodic
(there is no “tail”). In particular, `0` and `1` lie on the same cycle.

### 3) Big simplification for prime moduli
When the modulus is a prime `q`, we work in the finite field `F_q`.

If `gcd(k, q-1) = 1`, then the map `x ↦ x^k` permutes `F_q`, so `f_k(x) = 1 + x^k` is also a permutation.
In a permutation, if `0 → 1` then `0` and `1` are automatically in the same cycle, which means starting from `1`
we must eventually reach `0`.

**Consequence:** for prime `q`, the only exponents `k` that can possibly fail are those with `k | (q-1)`.

The problem requires intersection over **prime exponents** `p`, so for a prime modulus `q` we only need to test
prime divisors of `q-1` (and for odd `q`, that always includes `p = 2`).

### 4) Building composite solutions by multiplicativity (squarefree products)
For coprime moduli, the iteration modulo the product is just the CRT product of the iterations modulo each factor.
Because reaching `0` forces a pure cycle with `0` immediately before returning to `1`, the “hit time” is congruent to `-1`
modulo the cycle length for each prime factor. Those congruences always align, so if every prime factor is “good” then their
(squarefree) product is also good.

So after collecting all primes `q ≤ N` that work for every required prime exponent, we generate all subset products of these
primes that are `≤ N`, and sum them.

## Algorithms used

- **Odd-only sieve** to list primes up to `N`.
- **Cycle detection (Brent’s algorithm)** to decide whether the orbit of `1` under `x ↦ 1 + x^p (mod q)` reaches `0`,
  without storing visited values.
- **Trial division factorization** of `q-1` (only for the very small set of candidate primes that pass the `p=2` test).
- **Subset-product enumeration** to sum all squarefree products `≤ N`.

## How to run

```bash
python3 main.py
```

This prints `R(10^7)`.

You can also pass a custom `N`:

```bash
python3 main.py 1000
```

The code includes the two assertions given by the problem statement.
