# Project Euler 879 Solution - Touch-screen Password

<https://projecteuler.net/problem=879>:

* [879.py](879.py)

README.md
# Project Euler 879 — Touch-screen Password

This repository contains a standalone Python solution (no third-party libraries) for counting the number of valid “touch-screen passwords” on an `n × n` grid.

## Core ideas

### 1) Model moves with line-of-sight on a lattice
For two grid points `A` and `B` with coordinate difference `(dx, dy)`, the segment `A→B` passes through intermediate lattice points **iff** `gcd(|dx|, |dy|) > 1`.

- Let `g = gcd(|dx|, |dy|)`.
- The intermediate points are exactly the `g-1` points at steps `(dx/g, dy/g)`.

The problem’s “auto-insert intermediate spots” rule becomes:

> From the current spot `A`, an unvisited spot `B` can be selected next **only if** every intermediate lattice point between `A` and `B` has already been visited (and thus has disappeared).

### 2) Precompute “between” masks
For each ordered pair `(A, B)`, the program precomputes a bitmask `between[A][B]` that contains **all** intermediate grid points strictly between them.

During the search, a candidate next move `A→B` is valid when:
- `B` is unvisited, and
- `between[A][B]` contains no unvisited points.

Bitmasks make this check a single fast `&` operation.

### 3) Dynamic programming over subsets (bitmask DP)
Because each spot can be used at most once, the state can be represented as:
- `cur`: current spot (index), and
- `mask`: bitmask of visited spots.

Let `dp[cur][mask]` be the number of **non-empty** valid continuations from that state. Then:



dp[cur][mask] = Σ over valid next spots nxt of ( 1 + dp[nxt][mask ∪ {nxt}] )


The `+1` counts the password that ends immediately after choosing `nxt`.

To avoid recursion overhead, the implementation fills `dp` in an order where supersets are already computed (processing masks by decreasing popcount).

### 4) Total answer
Every password starts at some spot `s` and must have length ≥ 2, so the final count is:



answer = Σ_s dp[s][{s}]


## Included correctness checks
The solution includes assertions for the examples and the provided 3×3 total from the problem statement, and prints the 4×4 result.
