# Project Euler 547 Solution - Distance of Random Points Within Hollow Square Laminae

<https://projecteuler.net/problem=547>:

* [547.py](547.py)

This repository contains a `main.py` that computes:

- **S(n)**: the sum (over all hollow square laminae of size `n`) of the expected Euclidean distance between two uniformly random points chosen inside that lamina.
- The script prints **S(40)** rounded to **4 decimal places**, and includes asserts for the sample values `S(3)` and `S(4)`.

## Main techniques

### 1) Inclusion–exclusion on the region
A lamina is an outer `n×n` square **minus** an inner `x×y` rectangle (placed strictly inside).

Let:

- `O` = outer square
- `H` = the removed inner rectangle
- `R = O \ H` = the lamina region

For the *distance double integral*:

\[
I(A) = \iint_{p\in A}\iint_{q\in A} \|p-q\| \,dq\,dp
\]

we have:

\[
I(R) = I(O) - 2I(O,H) + I(H)
\]

where \( I(O,H) = \iint_{p\in O}\iint_{q\in H} \|p-q\|\,dq\,dp \).

Then the expected distance inside the lamina is:

\[
\mathbb{E}[\|p-q\|] = \frac{I(R)}{\text{area}(R)^2}
\]

and `S(n)` is the sum of these expectations over all hole sizes and placements.

### 2) Convolution in “difference space”
For axis-aligned rectangles, the cross integral can be rewritten using differences:

- \(dx = x_1 - x_2\)
- \(dy = y_1 - y_2\)

\[
I(A,B) = \iint \sqrt{dx^2+dy^2}\; L_x(dx)\; L_y(dy)\; d(dy)\,d(dx)
\]

where \(L_x(dx)\) is the **overlap length** of the x-intervals after shifting by `dx` (and similarly for y).

Because the inner rectangle is nested, each overlap function is a **trapezoid** (piecewise linear with up to 3 segments).

### 3) Piecewise polynomial weights → 4 basis integrals
On each `(dx,dy)` rectangle piece, the weight is a product of two linear functions:

\[
(m_x dx + c_x)\,(m_y dy + c_y)
\]

Expanding gives just four types of integrals over a rectangle in `(dx,dy)` space:

- \(\iint r\)
- \(\iint dx\,r\)
- \(\iint dy\,r\)
- \(\iint dx\,dy\,r\)

with \( r=\sqrt{dx^2+dy^2} \).

Each has a closed form in terms of `sqrt` and `asinh` evaluated at rectangle corners.

### 4) Precomputation for speed
All segment endpoints are **integers** in a small range (for `n=40`, within `[-40, 40]`), so `main.py` precomputes:

- a 2D table for \(\iint r\) primitives,
- a table for \(\int (a^2+t^2)^{3/2} dt\),
- a table for \((a^2+b^2)^{5/2}\).

This reduces the heavy math (`sqrt`, `asinh`) to a small one-time cost, making the full enumeration of ~549k laminae fast enough in pure Python.

## How to run

```bash
python3 main.py
```

It will run the sample asserts and print the numeric answer for `S(40)` to 4 decimals.
