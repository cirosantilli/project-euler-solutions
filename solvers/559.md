# Project Euler 559 Solution - Permuted Matrices

<https://projecteuler.net/problem=559>:

* [559.py](559.py)

This implementation computes

- **P(k, r, n)**: the number of `r × n` matrices whose rows are permutations of `1..n`, with the “descent” pattern constrained as in the statement.
- **Q(n) = Σ P(k, n, n)** modulo `1000000123`.

## 1) Inclusion–exclusion on constrained boundaries

For a fixed `k`, the only allowed row-descents are at positions `k, 2k, 3k, ...`.

- If we **force** a subset `U` of those positions to be *ascents*, then the row must be increasing inside each induced block.
- If the block lengths are `L1, L2, ...`, then the number of valid permutations for one row is the multinomial count:

\[
\frac{n!}{L_1! L_2! \cdots}
\]

Because rows are independent, the matrix count becomes that quantity raised to `r`.

Applying inclusion–exclusion over all subsets `U` turns `P(k,r,n)` into a signed sum over ways to merge consecutive blocks.

## 2) A block-DP that becomes a power-series inverse

Let `inv_fac_pow[m] = (m!)^{-r} (mod MOD)` and `fac_pow[n] = (n!)^r`.

For `k`, the natural block decomposition of `n` is:

- `q = n // k` full blocks of size `k`
- an optional final remainder block `rem = n % k`

The inclusion–exclusion over “merge cuts” yields a DP over the block prefix.  
When all blocks have the same size (the `q` full blocks), this DP is **Toeplitz** and can be expressed as:

\[
g(x) = \frac{(n!)^r}{p(x)},\quad
p(x) = \sum_{d=0}^{q} (-1)^d \cdot ((dk)!)^{-r} \, x^d
\]

So we need the coefficients of `1/p(x)` — i.e. a **formal power series inverse**.

If there is a remainder block, the final step is a single `O(q)` alternating sum using already computed coefficients.

## 3) Newton iteration for series inversion

To compute `s(x) = 1/p(x) mod x^{q+1}`, we use Newton’s method:

- start `g0 = 1/p(0)`
- repeatedly double precision with  
  `g ← g · (2 − p·g)  (mod x^m)`

This needs `O(log q)` polynomial multiplications.

## 4) Fast polynomial multiplication via “Kronecker substitution” + Karatsuba split

The modulus `1000000123` is not NTT-friendly. Instead, multiplication is accelerated by:

1. **Splitting coefficients** into low/high 23-bit parts.
2. Using a **Karatsuba** trick to get the cross-term with **3** convolutions.
3. Performing each convolution by packing coefficients into base `2^64` limbs and relying on Python’s highly optimized **big-integer multiplication**:
   - pack with `array('Q').tobytes()` → `int.from_bytes(...)`
   - multiply huge integers
   - unpack with `to_bytes(...); array('Q').frombytes(...)`

The code ensures each raw convolution coefficient stays `< 2^64`, so there are no carries between limbs, and the unpacked limbs are the exact convolution coefficients.

## 5) Hybrid strategy across k

For `Q(50000)`:

- For **small `k`** (large `q = n//k`), use the fast series-inversion method.
- For **large `k`** (small number of blocks), use the direct `O(m^2)` block DP.

This keeps the total runtime practical in pure Python.
