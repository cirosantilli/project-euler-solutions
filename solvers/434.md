# Project Euler 434 Solution - Rigid Graphs

<https://projecteuler.net/problem=434>:

* [434.py](434.py)

## Key reduction: rigidity → connected bipartite graph

For an `m × n` grid of **square cells**, each cell can be “braced” by adding a diagonal.
In this problem, the diagonal’s orientation doesn’t matter, and adding both diagonals is treated
the same as adding just one — so each cell is simply **present/absent**.

A classical result for braced rectangular grids (Bolker–Crapo) gives an elegant criterion:

- Build a **bipartite graph** with:
  - `m` vertices representing the **rows** of cells,
  - `n` vertices representing the **columns** of cells.
- For every braced cell `(row i, col j)`, add an edge between the corresponding row-vertex and column-vertex.

Then the grid framework is rigid in the plane **iff** this bipartite graph is **connected**.

So:

- `R(m,n)` = number of **connected** bipartite graphs on a fixed labeled bipartition of sizes `(m,n)`
  (equivalently: connected subgraphs of the complete bipartite graph `K_{m,n}`).

## Counting connected bipartite graphs via a “rooted component” recurrence

Let:

- `F(m,n) = 2^(m*n)` be the number of *all* bipartite graphs on parts of sizes `(m,n)`
  (each of the `m*n` possible edges is independently present/absent).

To extract the connected ones, we use the standard “pick a root vertex and look at its component” trick:

1. Fix one specific vertex on the `m`-side.
2. Suppose its connected component contains:
   - `i` vertices from the `m`-side (including the fixed one),
   - `j` vertices from the `n`-side.
3. Choose which vertices these are: `C(m-1, i-1) * C(n, j)`.
4. Choose a **connected** bipartite graph on those vertices: `R(i,j)`.
   - A small technical base case is needed for the recurrence:
     `R(1,0)=1` (a single isolated root vertex).
5. The remaining vertices can have **any** bipartite graph among themselves: `F(m-i, n-j)`,
   and there must be **no** edges between the component and the remainder (enforced by construction).

Summing over all possible `(i,j)` gives `F(m,n)`. Solving for `R(m,n)` yields:

`R(m,n) = F(m,n) - Σ_{(i,j)≠(m,n)} C(m-1,i-1) C(n,j) R(i,j) F(m-i,n-j)`.

This can be computed with dynamic programming in increasing `m` and `n`.

## Performance tricks used

- Precompute `2^k mod M` for `k ≤ N^2` to get `F(m,n)` in O(1).
- Precompute binomial coefficients `C(n,k) mod M` with Pascal’s triangle.
- Overall complexity is about `O(N^4)` operations with `N=100`, which is fast enough in Python.

## Validation

The code includes `assert` checks for all sample values from the statement:

- `R(2,3) = 19`
- `R(5,5) = 23679901`
- `S(5) = 25021721`

Running `main.py` prints `S(100) mod 1000000033`.
