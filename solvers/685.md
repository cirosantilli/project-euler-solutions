# Project Euler 685 Solution - Inverse Digit Sum II

<https://projecteuler.net/problem=685>:

* [685.py](685.py)

This repository contains a pure-Python solution for Project Euler 685.

## Core ideas

### 1) Order by length then lexicographic
All positive integers with a fixed digit sum are naturally ordered by numeric value.
For a fixed digit length `L`, numeric order matches lexicographic order on the digit strings,
and all shorter lengths come first.  
So to find the *m-th* number with digit sum `s`:

1. Find the first length `L` where the cumulative count of valid `L`-digit numbers reaches `m`.
2. “Unrank” the `k`-th string among the `L`-digit strings whose digits sum to `s`.

### 2) Switch to a small “deficit” sum
Let a digit be `a` and define its *deficit* as `x = 9 - a` (so `x` is in `0..9`).

For an `L`-digit number with digit sum `s`:

```
sum(a_i) = s
sum(9 - x_i) = s
9L - sum(x_i) = s
sum(x_i) = 9L - s = deficit
```

In this problem the required length is close to `s/9`, so `deficit = 9L - s` stays relatively small.
Counting and unranking becomes much easier in terms of this small deficit.

### 3) Counting with inclusion–exclusion
We need the number of sequences `(x_1..x_L)` such that:

- `0 <= x_i <= 9`
- `x_1 + ... + x_L = deficit`

This is the coefficient of `z^deficit` in `(1 + z + ... + z^9)^L`, computed with a standard
bounded-composition inclusion–exclusion formula:

```
Σ (-1)^j * C(L, j) * C(deficit - 10j + L - 1, deficit - 10j)
```

Leading-zero handling is done by subtracting the sequences where the first digit is `0`
(which corresponds to first deficit digit being `9`).

### 4) Unranking without building the full integer
Once the correct length `L` is known, digits are chosen from most significant to least.
At each step, a digit choice is accepted if the number of completions for the suffix
covers the remaining rank `k`.

Sometimes the next digit is forced to be `9` for a very long stretch; instead of appending
those `9`s one-by-one, the code jumps over runs using a small binary search on the suffix length.

### 5) Modular construction for huge numbers
The answer only requires values modulo `1_000_000_007`.
When appending a block of repeated digits, modular arithmetic avoids materializing the
full number:

- Appending `t` digits multiplies the prefix by `10^t`.
- The value of the repeated-digit block `ddd...d` is:

```
d * (10^t - 1) / 9
```

(using the modular inverse of `9`).

## Complexity notes
For each `n`:

- Only a few digit lengths are tested to locate the correct length.
- The deficit is small, so counting uses short inclusion–exclusion sums.
- Unranking consumes deficit quickly and only uses occasional binary searches to skip runs.

Overall runtime is practical in pure Python.
