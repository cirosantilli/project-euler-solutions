# Project Euler 110 Solution - Diophantine Reciprocals II

<https://projecteuler.net/problem=110>:

* [110.py](110.py)

We need the least `n` such that the number of distinct positive integer solutions `(x, y)` of

\[
\frac{1}{x} + \frac{1}{y} = \frac{1}{n}
\]

exceeds 4,000,000.

## Key transformation

Rearrange:

\[
\frac{x+y}{xy}=\frac{1}{n} \Rightarrow xy = n(x+y)
\Rightarrow (x-n)(y-n)=n^2
\]

Let `a = x-n`, `b = y-n`. Then `a*b = n^2` with `a,b > 0`.  
Each factor pair corresponds to a solution, and counting **distinct** solutions up to symmetry `(x,y)` means counting unordered factor pairs `(a,b)`:

\[
\#\text{solutions} = \frac{d(n^2)+1}{2}
\]

where `d(m)` is the divisor count. Since `d(n^2)` is odd, the condition
`solutions > 4,000,000` is equivalent to:

\[
d(n^2) \ge 8,000,000
\]

## Using the prime exponents of `n`

If:

\[
n=\prod p_i^{e_i}
\]

then:

\[
d(n^2)=\prod (2e_i+1)
\]

To minimize `n` for a required divisor product, exponents should be assigned to primes in non-increasing order (`e_1 >= e_2 >= ...`) so that large exponents sit on small primes.

## Search strategy (branch and bound)

We perform a depth-first search over exponent choices for primes `2,3,5,...`, enforcing non-increasing exponents. We track:

- `cur_n = product(p_i^{e_i})`
- `cur_divs = product(2e_i+1)` which equals `d(n^2)` for the chosen partial factorization

Pruning:
- If `cur_n` already exceeds the best known solution, stop that branch.
- If even assigning the maximum allowable exponent to all remaining primes cannot reach the target divisor count, stop that branch.

An initial upper bound is obtained by taking `n` square-free with enough primes so that `3^k >= 8,000,000`.

This efficiently finds the minimal `n` in seconds on PyPy3.
