# Project Euler 432 Solution - Totient Sum

<https://projecteuler.net/problem=432>:

* [432.py](432.py)

This repository contains a pure-Python solution for Project Euler problem 432.

## Problem

Define:

- `S(n, m) = sum_{i=1..m} φ(n·i)` where `φ` is Euler's totient function.

Given:

- `S(510510, 10^6) = 45480596821125120`

Compute:

- `S(510510, 10^11)` and report the **last 9 digits**.

## Main techniques used

### 1) Inclusion–exclusion recursion for `S(n, m)`

For `n` that is squarefree with distinct prime factors `p1..pk` (here `k=7`), one can derive a recursion:

- `S(n, m) = φ(n)·Φ(m) + Σ_{∅≠A⊆{p1..pk}} (-1)^{|A|+1} · S(n, floor(m / Π_{p∈A} p))`

where `Φ(x) = Σ_{i≤x} φ(i)` is the **summatory totient**.

Because `n = 510510` has only 7 prime factors, the subset sum has only `2^7−1 = 127` terms, and memoization over the `m` values reached by repeated division makes the recursion fast.

### 2) Fast summatory totient `Φ(x)` via divisor splitting (hyperbola method)

Directly computing `Φ(10^11)` by sieving to `10^11` is impossible.

Instead, we use a standard “split around `sqrt(x)`” trick:

- values of `floor(x / t)` are *large* and mostly distinct for small `t`
- values of `floor(x / t)` are *small* and highly repetitive for large `t`

This lets us compute `Φ(x)` using:

- a precomputed table of `Φ(t)` for `t ≤ SIEVE_LIMIT`
- a memoized recursion that only visits the distinct quotient values

All computations for the final result are done **mod 1,000,000,000** (the “last 9 digits”).

### 3) Euler (linear) sieve for `φ` up to a moderate limit

We precompute:

- `φ(i)` for `i ≤ 5,000,000`
- the prefix sums `Φ(i) = Σ_{k≤i} φ(k) (mod 1e9)`

This table acts as a base case that dramatically reduces recursion work.

## Testing

The problem statement provides one check value:

- `S(510510, 10^6) = 45480596821125120`

`main.py` computes this case **exactly** (using 64-bit prefix sums up to `10^6`) and asserts it before computing the final answer.
