# Project Euler 674 Solution - Solving $\mathcal{I}$-equations

<https://projecteuler.net/problem=674>:

* [674.py](674.py)

## Core observation: ℐ behaves like an injective constructor

The operator is:

\[
\mathcal{I}(x,y) = (1+x+y)^2 + y - x
\]

Two key properties for non-negative integers:

1. **Injective**:  
   \[
   \mathcal{I}(a,b)=\mathcal{I}(c,d) \implies (a,b)=(c,d)
   \]
   (There is a unique way to “decode” an output back into its input pair — so equality forces equal components.)

2. **Strictly increasing** in each argument (for \(x,y\ge 0\)):  
   \[
   \mathcal{I}(x+1,y)-\mathcal{I}(x,y)=2(1+x+y)>0
   \]
   \[
   \mathcal{I}(x,y+1)-\mathcal{I}(x,y)=2(2+x+y)>0
   \]

## Turning `e1 = e2` into unification

Because ℐ is injective, it behaves like a *constructor symbol* in term algebra:

- To satisfy `I(A,B) = I(C,D)` you must satisfy **both** `A = C` and `B = D`.
- This is exactly the rule used in **first-order unification** (Robinson unification).

So for each pair of expressions:

1. Parse both expressions into trees:
   - `Var(name)`
   - `I(left, right)`
2. Run a standard unifier (with an occurs check to prevent cyclic substitutions).
   - If not unifiable ⇒ no nonnegative solution ⇒ least simultaneous value = `0`.
   - If unifiable ⇒ we obtain a **most-general unifier** (MGU).

## Why the minimum is “all free variables = 0”

After unification, the two expressions become the same term `T` (up to substitution), and *any* assignment to remaining free variables produces a valid solution.

Because ℐ is strictly increasing in each argument and variables are constrained to be nonnegative, the minimum value of `T` over all solutions is achieved by setting every remaining free variable to **0**.

That is exactly how `least simultaneous value` is computed in the code:
- unify ⇒ get substitution
- evaluate with all free vars = 0

## Modulo arithmetic

The final answer only needs the **last 9 digits**, so evaluation is done modulo:

\[
10^9
\]

This avoids enormous integers during the full computation.

## Included statement checks

The code asserts the example from the statement:

- For  
  `A = I(x, I(z,t))`  
  `B = I(I(y,z), y)`  
  `C = I(I(x,z), y)`  

  It checks:
  - LSV(A,B) = 23
  - LSV(A,C) = 0
  - total over {A,B,C} pairs = 26

## Running

Place `p674_i_expressions.txt` next to `main.py` and run:

```bash
python3 main.py
