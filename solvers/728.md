# Project Euler 728 Solution - Circle of Coins

<https://projecteuler.net/problem=728>:

* [728.py](728.py)

## 1) Turn the puzzle into linear algebra over GF(2)

Represent a coin state as a bit-vector in **GF(2)^n** (0 = heads, 1 = tails).  
Flipping `k` consecutive coins is XOR with a fixed length-`n` vector that has `k` ones in a row, and all its cyclic shifts are available moves.

So, starting from a state `x`, reaching all-heads means solving

- `x = sum_i a_i * move_i`  over GF(2)

The solvable states are exactly the **span** of the move vectors, so

- `F(n,k) = 2^rank(n,k)`

where `rank(n,k)` is the rank of the corresponding `n×n` circulant matrix over GF(2).

## 2) Circulant matrices ↔ polynomial gcd

A circulant “convolution by a length-`k` block of ones” corresponds to multiplication by

- `f(x) = 1 + x + ... + x^(k-1)`

in the ring `GF(2)[x] / (x^n - 1)`.

The kernel dimension equals `deg(gcd(x^n - 1, f(x)))`, so

- `rank(n,k) = n - deg(gcd(x^n - 1, f(x)))`.

In characteristic 2, this gcd collapses to a very simple arithmetic rule:

- Let `g = gcd(n,k)`
- Let `v2(t)` be the exponent of 2 in `t`

Then the gcd-degree is

- `deg_gcd = g - 1` if `v2(k) <= v2(n)`
- `deg_gcd = g`     otherwise

and therefore

- `F(n,k) = 2^(n - deg_gcd)`.

(Implementation tip: `v2(k) <= v2(n)` is equivalent to `(k & -k) <= (n & -n)`.)

## 3) Replace the inner sum over k using gcd-classes and φ

For fixed `n`, group `k` by `d = gcd(n,k)`.  
The count of `k` with `gcd(n,k)=d` is `φ(n/d)`.

The only subtlety is the extra `+1` in the exponent when `v2(k) <= v2(n)`, which turns out to depend only on whether `m = n/d` is even or odd:

- If `m` is even (or `m=1`), every valid `k` in that class contributes with the `+1`.
- If `m` is odd and `m >= 3`, exactly half contribute with `+1` and half without.

After algebraic simplification, the whole double sum becomes

\[
S(N) \equiv \sum_{m=1}^{N} A(m)\,\sum_{g=1}^{\lfloor N/m\rfloor} 2^{g\,(m-1)} \pmod{M},
\]

where

- `A(m) = 2*φ(m)` if `m` is even or `m=1`
- `A(m) = (3/2)*φ(m)` if `m` is odd and `m>=3`
- `M = 1_000_000_007`.

## 4) Fast evaluation via geometric series

For each `m`, the inner sum is a geometric series with ratio `r = 2^(m-1)`:

- If `r != 1 (mod M)`:

\[
\sum_{g=1}^{L} r^g = r\,(r^L-1)\,(r-1)^{-1}.
\]

- If `r == 1 (mod M)`, the sum is simply `L`.

To do this for all `m` up to `N=10^7` efficiently:

- Precompute `2^e mod M` for `e=0..N` in O(N).
- Precompute inverses of `(2^t - 1)` for `t=1..N-1` in O(N) using the **single inversion trick**:
  - build prefix products
  - invert the total product once with Fermat
  - sweep backwards to obtain every individual inverse.

## 5) Complexity

- Totient table (linear sieve): **O(N)** time, **O(N)** memory
- Powers of two: **O(N)** time, **O(N)** memory
- Inverses `(2^t-1)^{-1}`: **O(N)** time, **O(N)** memory
- Final summation over `m`: **O(N)** time

Overall: **O(N)** time and memory with `N = 10^7`.
