# Project Euler 770 Solution - Delphi Flip

<https://projecteuler.net/problem=770>:

* [770.py](770.py)

## Key ideas

### 1) Homogeneity (scaling)
If A has `y` grams and chooses `x ≤ y`, write `x = u·y` with `u ∈ [0, 1]`.
After B’s response, A’s gold becomes either `y(1-u)` (TAKE) or `y(1+u)` (GIVE).

Because every move scales linearly with `y`, the optimal guaranteed outcome is homogeneous:

- Let `F(t, g)` be the maximum factor A can guarantee starting from **1 gram** with  
  `t` TAKEs and `g` GIVEs remaining.
- Then starting from `y` grams, the guarantee is `y · F(t, g)`.

So the whole game reduces to computing `F(t, g)`.

---

### 2) Minimax step and a harmonic-mean recurrence
From state `(t, g)`, A chooses `u` and B chooses between:

- `(t-1, g)` with factor multiplied by `(1-u)`
- `(t, g-1)` with factor multiplied by `(1+u)`

So:
\[
F(t,g) = \max_{0\le u\le 1}\ \min\left((1-u)F(t-1,g),\ (1+u)F(t,g-1)\right).
\]

For `t,g>0`, the optimal `u` balances the two arguments of `min`, yielding a **harmonic mean**:
\[
F(t,g) = \frac{2}{\frac{1}{F(t-1,g)}+\frac{1}{F(t,g-1)}}.
\]

Define the reciprocal:
\[
R(t,g)=\frac{1}{F(t,g)}.
\]
Then the recurrence becomes a simple average:
\[
R(t,g)=\frac{R(t-1,g)+R(t,g-1)}{2},
\]
with boundary conditions
- `R(t,0)=1` (if only TAKEs remain, A can choose `x=0` and never lose),
- `R(0,g)=2^{-g}` (if only GIVEs remain, A doubles each round by choosing `x=y`).

---

### 3) Binomial probability closed form
The averaging recurrence with those boundaries is exactly the same as the recursion for
a binomial tail probability. One obtains:
\[
R(t,g)=2^{-(t+g)}\sum_{k=g}^{t+g}\binom{t+g}{k}
      =\Pr\big[\mathrm{Bin}(t+g,\tfrac12)\ge g\big].
\]

In particular, for the problem we need `t=g=n`:
\[
R(n,n)=\Pr[\mathrm{Bin}(2n,\tfrac12)\ge n]
      =\frac12+\frac{1}{2}\cdot\frac{\binom{2n}{n}}{2^{2n}}.
\]

Since `F(n)=1/R(n,n)`, the condition `F(n) ≥ X` is equivalent to a bound on
\[
p_n=\frac{\binom{2n}{n}}{4^n}.
\]

---

### 4) Handling huge `n` with Stirling asymptotics (log-space)
For `X` extremely close to `2`, the required `n` is enormous, so we cannot compute
`\binom{2n}{n}` directly.

Using the Stirling expansion for log-factorials, one gets a very accurate formula:
\[
\ln p_n = -\tfrac12\ln(\pi n)\;-\;\frac{1}{8n}\;+\;\frac{1}{192n^3}\;-\;\frac{1}{640n^5}\;+\;O(n^{-7}).
\]

The program compares `ln(p_n)` against `ln((2-X)/X)` to decide the minimal `n`, using:
- exact integer arithmetic for small `n`,
- the Stirling log-approximation for huge `n`.

That’s enough to compute `g(1.9999)` quickly and deterministically.
