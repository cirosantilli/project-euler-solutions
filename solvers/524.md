# Project Euler 524 Solution - First Sort II

<https://projecteuler.net/problem=524>:

* [524.py](524.py)

This repo contains a self-contained solution (no external libraries) that prints:

- **`R(12^12)`** for Project Euler 524.

Run:

```bash
python3 main.py
Key ideas used
1) Closed form for F(P)
The â€œFirst Sortâ€ algorithm repeatedly finds the first adjacent inversion and moves the smaller element to the front.
For a permutation P, the number of such moves is:

Scan left-to-right, tracking the current prefix maximum M.

For an element x:

If x is a new maximum (x > M), it contributes 0.

Otherwise let r = (# of earlier elements < x) and it contributes 2^r.

So:

ð¹
(
ð‘ƒ
)
=
âˆ‘
xÂ notÂ aÂ prefix-maximum
2
#
{
â€‰
earlierÂ elements
<
ð‘¥
â€‰
}
F(P)= 
xÂ notÂ aÂ prefix-maximum
âˆ‘
â€‹
 2 
#{earlierÂ elements<x}
 
In code we compute r with a Fenwick tree in O(n log n).

2) Building the lexicographically first permutation with F(P)=k
Let lex_first_perm(n,k) be the lexicographically first permutation of {1..n} with F(P)=k.
Three structural recurrences cover most cases:

Even k â‡’ starts with 1

Putting 1 first increases every later â€œsmaller-beforeâ€ count by 1, doubling F.

Therefore:

ð‘ƒ
(
ð‘›
,
2
ð‘š
)
=
[
1
]
â€…â€Š
+
â€…â€Š
(
ð‘ƒ
(
ð‘›
âˆ’
1
,
ð‘š
)
Â withÂ allÂ valuesÂ 
+
1
)
P(n,2m)=[1]+(P(nâˆ’1,m)Â withÂ allÂ valuesÂ +1)
High bit set â‡’ ends with n-1

If k â‰¥ 2^{n-2}, that bit can only come from the value n-1 contributing 2^{n-2}.

That forces all smaller values before it and also n before it â‡’ n-1 is last.

Removing it subtracts exactly 2^{n-2} and doesnâ€™t affect the rest:

ð‘ƒ
(
ð‘›
,
ð‘˜
)
=
(
replaceÂ 
(
ð‘›
âˆ’
1
)
â†’
ð‘›
Â inÂ 
ð‘ƒ
(
ð‘›
âˆ’
1
,
ð‘˜
âˆ’
2
ð‘›
âˆ’
2
)
)
â€…â€Š
+
â€…â€Š
[
ð‘›
âˆ’
1
]
P(n,k)=(replaceÂ (nâˆ’1)â†’nÂ inÂ P(nâˆ’1,kâˆ’2 
nâˆ’2
 ))+[nâˆ’1]
k â‰¡ 1 (mod 4) â‡’ starts with 2,1

For odd k, we canâ€™t start with 1.

If k â‰¡ 1 (mod 4), we must avoid any contribution of 2 (mod 4), so 1 must appear as early as possible â‡’ second position.

After the prefix [2,1], all remaining contributions are multiples of 4:

ð‘ƒ
(
ð‘›
,
4
ð‘š
+
1
)
=
[
2
,
1
]
â€…â€Š
+
â€…â€Š
(
ð‘ƒ
(
ð‘›
âˆ’
2
,
ð‘š
)
Â withÂ allÂ valuesÂ 
+
2
)
P(n,4m+1)=[2,1]+(P(nâˆ’2,m)Â withÂ allÂ valuesÂ +2)
The only remaining case is:

k odd, k < 2^{n-2}, and k â‰¡ 3 (mod 4).

For this â€œhardâ€ residue, the code uses a memoized lexicographic DFS over bitmasks, with strong min/max feasibility pruning per prefix. In the actual R(12^12) computation, the recurrences shrink the problem until this hard core is only n=16, so the DFS is fast.

3) Computing R(k)
R(k) is the minimum Q(n,k) over all valid n.

A crucial simplification:

If k is even, prepending 1 halves k without changing the lexicographic index inside the first block of permutations.

So repeatedly stripping factors of 2 keeps R(k) unchanged.

After stripping, we solve the remaining odd k at the minimal feasible n = bit_length(k)+1, then compute the 1-based lexicographic index using factorial numbering.

Correctness checks
main.py includes asserts for all values explicitly given in the problem statement:

F({4,1,3,2}) = 5

Q(4,k) for k = 0..7 as listed in the table.
