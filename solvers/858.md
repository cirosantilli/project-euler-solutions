# Project Euler 858 Solution - LCM

<https://projecteuler.net/problem=858>:

* [858.py](858.py)

We define:

\[
G(N) = \sum_{S \subseteq \{1,\dots,N\}} \mathrm{lcm}(S),
\qquad \mathrm{lcm}(\emptyset)=1
\]

The task is to compute \(G(800) \bmod (10^9+7)\).

---

## Key ideas

### 1) Totient expansion of an integer
A classic identity:

\[
n = \sum_{d \mid n} \varphi(d)
\]

Applying to the subset LCM:

\[
\mathrm{lcm}(S) = \sum_{d \mid \mathrm{lcm}(S)} \varphi(d)
\]

Summing over all subsets and swapping sums gives:

\[
G(N) = \sum_{d \mid L} \varphi(d)\cdot \#\{S : d \mid \mathrm{lcm}(S)\}
\]

where \(L = \mathrm{lcm}(1,\dots,N)\).

---

### 2) Inclusion–exclusion on “missing prime-power requirements”
For a fixed divisor \(d\), let its prime-power form be:

\[
d = \prod p^{a_p}
\]

Then \(d \mid \mathrm{lcm}(S)\) means:

> For each prime \(p\) with exponent \(a_p\), the subset contains **at least one**
> number divisible by \(p^{a_p}\).

Counting subsets satisfying “hit every required multiples-set” is done by inclusion–exclusion
over which prime requirements are *missed*.

After regrouping, the problem reduces to summing over sets \(Q\) of **one prime power per prime**
(e.g. \(Q=\{2^4, 3^1, 11^1\}\)):

\[
G(N) = L \sum_Q (-1)^{|Q|} \cdot 2^{N - F(Q)} \cdot \prod_{p^r \in Q}\frac{\varphi(p^r)}{p^{e_p}}
\]

where:

- \(F(Q)\) is the count of integers in \([1..N]\) divisible by at least one element of \(Q\)
- \(e_p\) is the maximum exponent of \(p\) in \(L\)

---

### 3) Prime split: small vs large primes
If \(p > \sqrt{N}\), then:

- \(p^2 > N\), so \(e_p = 1\)
- No number \(\le N\) can be divisible by **two** such primes (product would exceed \(N\))

This makes large primes essentially independent, once we know which **small multipliers**
are already “covered” by chosen small prime powers.

So we:

- brute-force all exponent choices for primes \(p \le \sqrt{N}\) (few combinations)
- for each choice, compute coverage with a bitmask
- fold in the large primes via a product of independent factors

---

### 4) Bitmask coverage + memoisation
Coverage sets are represented as Python integers (bitsets):

- one mask for numbers \(1..N\)
- one smaller mask for multipliers \(1..K_{\max}\) needed to evaluate large primes

The expensive “large prime product” depends only on the multiplier-mask, so it is memoised.
This yields a fast runtime.

---

## Complexity
Let \(P_s\) be primes \(\le \sqrt{N}\).
We enumerate \(\prod_{p \in P_s} (e_p+1)\) combinations — for \(N=800\), this is only **34,020**.

Each combination is processed with O(#large primes) arithmetic,
but memoisation reduces this dramatically in practice.

---

## Notes
- The program includes assertions verifying the given sample values:
  - \(G(5)=528\)
  - \(G(20)=8463108648960\)
- The final Euler answer is **not hard-coded**; it is computed and printed.
