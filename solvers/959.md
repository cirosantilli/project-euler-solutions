# Project Euler 959 Solution - Asymmetric Random Walk

<https://projecteuler.net/problem=959>:

* [959.py](959.py)

This solution is a standalone Python program (no third-party libraries).

A frog starts at 0 on the number line. Each step is either \(-a\) or \(+b\) with probability \(1/2\) each.  
Let \(c_n\) be the expected number of **distinct** positions visited in the first \(n\) steps, and define

\[
f(a,b)=\lim_{n\to\infty}\frac{c_n}{n}.
\]

## Main techniques used

### 1) Escape probability / Green function
When \(a\neq b\), the walk has nonzero drift and is **transient** in 1D (it eventually heads to \(+\infty\) or \(-\infty\)).  
In a transient, translation-invariant walk, the long-run rate of discovering new sites equals the **escape probability** from a site.

Let
\[
G=\sum_{n\ge 0}\Pr(S_n=0),
\]
the expected number of visits to the origin (the Green function at 0). For a transient walk this is finite, and the probability of **never returning** to the origin (starting from the origin) is
\[
\Pr(\text{no return}) = \frac{1}{G}.
\]

That escape probability is exactly the limit \(f(a,b)\).

### 2) Closed form for return probabilities via a binomial condition
Because each step is only \(-a\) or \(+b\), after \(n\) steps the position depends only on the number of “right” steps \(r\):
\[
S_n = r\cdot b - (n-r)\cdot a.
\]

So \(S_n=0\) happens iff
\[
r\cdot b = (n-r)\cdot a.
\]

After reducing by \(g=\gcd(a,b)\) (which just rescales the lattice and doesn’t change the count of distinct visited positions), this implies that returns to 0 occur only at times \(n=k(a+b)\), with exactly \(r=ka\) right steps. Therefore
\[
\Pr(S_{k(a+b)}=0) = \binom{k(a+b)}{ka}\,2^{-k(a+b)},
\]
and \(\Pr(S_n=0)=0\) for other \(n\).

Thus,
\[
G = \sum_{k\ge 0}\binom{k(a+b)}{ka}\,2^{-k(a+b)}.
\]

### 3) Efficient, accurate series summation (no huge binomials)
Rather than computing factorials or massive binomial coefficients directly, the code sums the series using a **term-to-term recurrence**:

- \(t_0 = 1\)
- \(t_k = \binom{k(a+b)}{ka}\,2^{-k(a+b)}\)
- compute \(t_{k+1}\) from \(t_k\) using a product ratio of consecutive factorial ranges.

The implementation uses Python’s `decimal.Decimal` with high precision and stops once the next term is far below what could affect rounding to 9 decimal places.

## Files
- `main.py`: computes and prints \(f(89,97)\) rounded to 9 digits after the decimal point, and includes asserts for the two values given in the statement.

## Run
```bash
python3 main.py
