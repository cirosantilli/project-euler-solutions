# Project Euler 460 Solution - An Ant on the Move

<https://projecteuler.net/problem=460>:

* [460.py](460.py)

This repository contains a pure-Python solution (no external libraries) for **Project Euler 460**.

## Core observations

### 1) The “constant velocity” equals a line integral

For a straight segment from \((x_0,y_0)\) to \((x_1,y_1)\), the problem defines a constant velocity

- \(v=y_0\) if \(y_0=y_1\)
- \(v=\dfrac{y_1-y_0}{\ln y_1-\ln y_0}\) otherwise (the **logarithmic mean**)

Then the travel time is

\[
t=\frac{\sqrt{\Delta x^2+\Delta y^2}}{v}.
\]

But notice that for a straight segment, \(y(t)=y_0+t\Delta y\), so

\[
\int_0^1 \frac{\sqrt{\Delta x^2+\Delta y^2}}{y_0+t\Delta y}\,dt
= \sqrt{\Delta x^2+\Delta y^2}\cdot\frac{\ln y_1-\ln y_0}{y_1-y_0}
= \frac{\sqrt{\Delta x^2+\Delta y^2}}{v}.
\]

So the problem is equivalent to finding a shortest path under the “metric”
\[
\text{time}=\int \frac{ds}{y}.
\]

In the continuous upper half-plane model, geodesics are semicircles orthogonal to the \(x\)-axis, which explains why the optimal lattice path clusters near a semicircle for large \(d\).

### 2) Symmetry and the “top height” \(h=d/2\) (for even \(d\))

For even \(d\), the optimal path is symmetric about \(x=d/2\) and reaches a maximum height near \(d/2\). In fact, for the values in the statement (\(d=4,10,100\)), the optimal lattice path reaches exactly
\[
h=\frac d2.
\]
The solution uses this for \(d=10000\).

## DP reduction to 1D (heights only)

Split an optimal symmetric path into:

1. a **climb** from \((0,1)\) up to height \(h\) (ending at some \(x=S\)),
2. a possible **cruise** along \(y=h\) (speed \(h\)),
3. a symmetric **descent**.

Let the climb take time \(T\) and advance horizontally by \(S\). Total time is

\[
F(d)=2T+\frac{d-2S}{h}.
\]

Rewrite as

\[
F(d)=2\left(T-\frac{S}{h}\right)+\frac{d}{h}.
\]

So for a fixed \(h\), we only need the minimal **excess cost**
\[
E = T-\frac{S}{h}.
\]
Then
\[
F(d)=2E+\frac{d}{h}.
\]

### Step cost and analytic optimization of \(\Delta x\)

During the climb we take steps that increase height from \(y_0\) to \(y_1>y_0\) while moving right by an integer \(\Delta x\ge 0\).

- time of the straight step: \(\dfrac{\sqrt{\Delta x^2+\Delta y^2}}{L(y_0,y_1)}\)
- cruising time “saved” at height \(h\): \(\dfrac{\Delta x}{h}\)

So the **excess** for that step is
\[
e(\Delta x)=\frac{\sqrt{\Delta x^2+\Delta y^2}}{L(y_0,y_1)}-\frac{\Delta x}{h}.
\]

For fixed \(y_0,y_1\), this is convex in \(\Delta x\). Minimizing over real \(\Delta x\) gives a closed-form optimum
\[
\Delta x^\*=\Delta y\cdot\frac{L}{\sqrt{h^2-L^2}}.
\]
Since we require integer \(\Delta x\), it’s enough to check \(\lfloor \Delta x^\*\rfloor\) and \(\lceil \Delta x^\*\rceil\).

### DP recurrence

Let `dp[y]` be the minimal excess cost to climb from \(y=1\) to \(y\). Then

\[
dp[1]=0,\qquad
dp[y]=\min_{1\le y_0<y}\left(dp[y_0]+\min_{\Delta x\in\mathbb{Z}_{\ge 0}} e(\Delta x)\right).
\]

Finally:
\[
F(d)=2\cdot dp[h]+\frac{d}{h}.
\]

## Speed trick: shrink the transition window

The optimal path stays near a semicircle, and around that curve typical vertical step sizes at height \(y\) behave like \(O(h/y)\).

So when computing `dp[y]`, we only consider predecessors `y0` in a window

\[
y_0 \in [y-M, y),\quad M \approx C\cdot \frac{h}{y}.
\]

Using a safe constant \(C=64\) makes the runtime about \(O(h\log h)\) in practice (around 1–2 million transitions for \(h=5000\)).

## Output

Running `main.py` prints **F(10000)** rounded to 9 decimal places, and includes asserts for the verification values from the problem statement.
