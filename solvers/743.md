# Project Euler 743 Solution - Window into a Matrix

<https://projecteuler.net/problem=743>:

* [743.py](743.py)

We count `2 × n` binary matrices where every contiguous `2 × k` window has total sum `k`, and we need the result modulo `1_000_000_007`.

## Key ideas

### 1) Reduce the matrix to a 1D sequence
Each column is one of `{00, 01, 10, 11}`. Let `s_i` be the number of ones in column `i`, so `s_i ∈ {0, 1, 2}`.

The window constraint becomes:

\[
\sum_{j=i}^{i+k-1} s_j = k \quad \text{for all valid } i.
\]

### 2) Sliding-window subtraction forces periodicity
Compare consecutive windows:

\[
\left(\sum_{j=i}^{i+k-1} s_j\right) - \left(\sum_{j=i+1}^{i+k} s_j\right) = s_i - s_{i+k} = 0
\]

So `s_i = s_{i+k}` whenever both indices exist, which makes the sequence `k`-periodic as soon as `n ≥ k`.

Thus the entire `s`-sequence is determined by the first `k` terms, and those terms must satisfy:

\[
s_1 + \cdots + s_k = k.
\]

### 3) Count patterns by how many 0/1/2 columns they use
Let there be `t` columns with `0` ones, `t` columns with `2` ones, and `k - 2t` columns with `1` one.  
(From `b + 2t = k` and `a + b + t = k`, we get `a = t`.)

For a fixed `t`, the number of `s`-patterns of length `k` is:

\[
\frac{k!}{t!\,t!\,(k-2t)!}.
\]

A column with `s_i = 1` can be either `01` or `10`, giving an extra factor of `2` per occurrence.

When `n` is a multiple of `k` (the Euler input and the given samples), each of the `k-2t` “one-columns” repeats exactly `n/k` times, so the orientation factor becomes:

\[
2^{(n/k)\,(k-2t)}.
\]

This yields a single sum over `t = 0..⌊k/2⌋`.

### 4) Avoid factorial tables with a term-to-term recurrence
Direct factorials up to `k = 10^8` are too big to store in Python.

Let:

\[
C_t = \frac{k!}{t!\,t!\,(k-2t)!}.
\]

Then:

\[
\frac{C_{t+1}}{C_t} = \frac{(k-2t)(k-2t-1)}{(t+1)^2}.
\]

So we can generate terms sequentially using modular arithmetic.

### 5) Batch modular inverses (one exponentiation per block)
The recurrence needs `1/(t+1)^2 mod MOD` for many consecutive `t`.

Instead of calling `pow(t+1, MOD-2, MOD)` every step, we compute inverses for a whole block
`[L..R]` with:

- prefix products modulo `MOD`,
- one modular inversion of the total product,
- a backward sweep to recover each individual inverse.

This reduces the number of expensive exponentiations from tens of millions to a few hundred.

## Files

- `main.py` contains the implementation and includes assertions for the sample values from the statement.
- Running `python3 main.py` prints the required answer (no hard-coded final value).
