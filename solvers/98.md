# Project Euler 98 Solution - Anagramic Squares

<https://projecteuler.net/problem=98>:

* [98.py](98.py)
* [98.lean](98.lean)

## Key idea
Two anagram words can map to two square numbers if there exists a **bijection** between letters and digits such that:
- the same letter always maps to the same digit,
- different letters map to different digits,
- no mapped number has a leading zero.

## Approach
1. **Load all words** and group them by their sorted letters (anagram classes).
2. For every word length `L` that occurs in an anagram group:
   - generate all `L`-digit square numbers,
   - store them in a set for fast membership tests,
   - additionally group these squares by a **pattern signature**.
3. The **pattern signature** encodes the equality structure of a string, e.g.:
   - `CARE -> (0,1,2,3)`
   - `NOON -> (0,1,1,0)`
   A word can only map to squares with the same signature.
4. For each anagram group and each word `w1` in it:
   - iterate over square candidates matching `w1`’s signature,
   - build the letter→digit mapping from `w1` to the square,
   - apply the same mapping to other anagrams `w2` and check if the resulting number is also in the square set.
5. Track the maximum square found.

This avoids brute-forcing all digit assignments by heavily pruning using length constraints and signature matching.
