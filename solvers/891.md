# Project Euler 891 Solution - Ambiguous Clock

<https://projecteuler.net/problem=891>:

* [891.py](891.py)

This solution counts all *ambiguous moments* in one 12‑hour cycle for a clock whose three hands are:

- **Identical** (unlabeled),
- **Continuously moving**, and
- Shown on a dial with **no reference mark** (the whole dial may be rotated by an unknown amount).

A time is *ambiguous* if the same observed configuration (up to global rotation and swapping which hand is which) can come from **at least two distinct times** in the 12‑hour cycle.

## Key ideas

### 1) Model hand angles with integer speeds

Over one 12‑hour cycle there are `L = 43200` seconds.

Measured in “revolutions per 12‑hour cycle”, the hand speeds are integers:

- hour: `1`
- minute: `12`
- second: `720`

At time `t` seconds, the three angles (in turns) are:

`angle_i(t) = V[i] * t / L   (mod 1)`.

### 2) Remove the unknown rotation

Two times `t` and `t'` are indistinguishable if, after some **global rotation** and some **permutation of the hands**, the three angles match.

A global rotation cancels out when you look at **differences between hands**. Using two independent differences gives two linear congruences that must be satisfied for a given permutation of the hands.

### 3) Turn congruences into a small integer search

Because everything is periodic with period `L`, the congruences introduce integer “wrap counts” (how many full turns are absorbed by the modulo).

Within one cycle (`0 ≤ t, t' < L`) those wrap counts are **bounded by small constants** derived from the coefficients (on the order of a few thousand), so we can enumerate them.

To keep it fast, for each fixed `k1` the constraints on `k2` are turned into **integer intervals** using `floor/ceil` arithmetic, and only the intersection is iterated.

### 4) Exact arithmetic and deduplication

Each valid `(k1, k2)` produces a pair of times `t` and `t'` as exact rationals. To count distinct ambiguous moments:

- Reduce each time to a simplest fraction using `gcd`.
- Pack `(numerator, denominator)` into one integer key for memory‑efficient storage.
- Insert keys into a set; the final set size is the required count.

### 5) Statement examples as asserts

The code includes asserts for moments explicitly mentioned in the problem statement:

- `12:00:00` is **not** ambiguous.
- `1:30:00` and `7:30:00` are ambiguous.
- `3:00:00` and `9:00:00` are **not** ambiguous.

## Complexity (roughly)

The computation enumerates a few million small integer combinations across 5 non‑identity permutations, performs only integer arithmetic and `gcd`s, and deduplicates via a hash set.
