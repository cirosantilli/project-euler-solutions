#!/usr/bin/env python3
"""Project Euler 673: Beds and Desks

We have n students labeled 1..n.

A bed arrangement and a desk arrangement each define an *involution* (a permutation
of order 2): listed pairs are swapped; all other students are fixed points.

After applying a permutation σ of students to both beds and desks, the conditions
"roommates stay roommates" and "desk partners stay desk partners" are equivalent to
commutation with both involutions:

    σB = Bσ   and   σD = Dσ

So we must count permutations commuting with two given involutions B and D.

Implementation notes
--------------------
By default this solution reads the pairing lists from files in the *current working
directory*:

* 0673_beds.txt
* 0673_desks.txt

Each file contains one pair per line: "a,b".

You can also pass custom paths:

    python3 main.py [beds_file] [desks_file] [n]

If n is omitted it defaults to 500 (Project Euler's input size).

No external libraries are used.
"""

from __future__ import annotations

import sys
from collections import defaultdict

MOD = 999_999_937


def parse_pairs(text: str) -> list[tuple[int, int]]:
    """Parse lines like 'a,b' into a list of integer pairs."""
    out: list[tuple[int, int]] = []
    for line in text.splitlines():
        line = line.strip()
        if not line:
            continue
        a_str, b_str = line.split(",")
        out.append((int(a_str), int(b_str)))
    return out


def read_text_file(path: str) -> str:
    with open(path, "r", encoding="utf-8") as f:
        return f.read()


def count_commuting_permutations(
    n: int,
    bed_pairs: list[tuple[int, int]],
    desk_pairs: list[tuple[int, int]],
    mod: int = MOD,
) -> int:
    """Count permutations σ of {1..n} that commute with both involutions."""

    # Build involutions B and D
    B = list(range(n + 1))
    D = list(range(n + 1))

    for a, b in bed_pairs:
        B[a] = b
        B[b] = a
    for a, b in desk_pairs:
        D[a] = b
        D[b] = a

    visited = [False] * (n + 1)
    type_count: dict[tuple, int] = defaultdict(int)
    type_aut: dict[tuple, int] = {}

    for start in range(1, n + 1):
        if visited[start]:
            continue

        # Explore the component in the undirected graph generated by B- and D-edges.
        stack = [start]
        visited[start] = True
        comp: list[int] = []
        while stack:
            v = stack.pop()
            comp.append(v)
            for u in (B[v], D[v]):
                if not visited[u]:
                    visited[u] = True
                    stack.append(u)

        k = len(comp)
        has_loop = any((B[v] == v) or (D[v] == v) for v in comp)

        if not has_loop:
            # Component is an even alternating cycle (no loops).
            key = ("C", k)
            aut = k
        else:
            # Component is an alternating path with loops at the endpoints
            # (or the isolated vertex with both loops).
            if k % 2 == 1:
                # Endpoints have different loop colours (or k==1 has both loops).
                key = ("P", k, "BD")
                aut = 1
            else:
                # Endpoints have the same loop colour, so reflection is allowed.
                end_colour = "BD"
                for v in comp:
                    if B[v] == v and D[v] != v:
                        end_colour = "B"
                        break
                    if D[v] == v and B[v] != v:
                        end_colour = "D"
                        break
                key = ("P", k, end_colour)
                aut = 2

        type_count[key] += 1
        if key in type_aut:
            assert type_aut[key] == aut
        else:
            type_aut[key] = aut

    # Factorials for permutations among identical components
    fact = [1] * (n + 1)
    for i in range(2, n + 1):
        fact[i] = (fact[i - 1] * i) % mod

    ans = 1
    for key, m in type_count.items():
        a = type_aut[key]
        ans = (ans * pow(a, m, mod)) % mod
        ans = (ans * fact[m]) % mod
    return ans


# --- Tests from the problem statement ---


def _run_tests() -> None:
    # n=4 example
    n = 4
    beds = [(2, 3)]
    desks = [(1, 3), (2, 4)]
    assert count_commuting_permutations(n, beds, desks) == 2

    # n=6 example
    n = 6
    beds = [(1, 2), (3, 4), (5, 6)]
    desks = [(3, 6), (4, 5)]
    assert count_commuting_permutations(n, beds, desks) == 8

    # n=36 example
    n = 36
    beds = [
        (2, 13),
        (4, 30),
        (5, 27),
        (6, 16),
        (10, 18),
        (12, 35),
        (14, 19),
        (15, 20),
        (17, 26),
        (21, 32),
        (22, 33),
        (24, 34),
        (25, 28),
    ]
    desks = [
        (1, 35),
        (2, 22),
        (3, 36),
        (4, 28),
        (5, 25),
        (7, 18),
        (9, 23),
        (13, 19),
        (14, 33),
        (15, 34),
        (20, 24),
        (26, 29),
        (27, 30),
    ]
    assert count_commuting_permutations(n, beds, desks) == 663_552


def solve_from_files(beds_path: str, desks_path: str, n: int = 500) -> int:
    """Solve using pair lists stored on disk.

    Default filenames:
    - beds_path  = '0673_beds.txt'
    - desks_path = '0673_desks.txt'

    Fallback: if desks_path cannot be opened, we also support a single file where
    the beds list comes first, then a blank line, then the desks list.
    """

    beds_text = read_text_file(beds_path)

    try:
        desks_text = read_text_file(desks_path)
    except FileNotFoundError:
        # Some mirrors bundle both lists in one file separated by a blank line.
        normalized = beds_text.replace("\r\n", "\n")
        parts = [p.strip() for p in normalized.split("\n\n") if p.strip()]
        if len(parts) != 2:
            raise FileNotFoundError(
                f"Could not open desks file '{desks_path}'. Provide it, or supply a "
                "single file containing beds then a blank line then desks."
            )
        beds_text, desks_text = parts

    beds = parse_pairs(beds_text)
    desks = parse_pairs(desks_text)
    return count_commuting_permutations(n, beds, desks)


def main(argv: list[str]) -> None:
    _run_tests()

    beds_path = "0673_beds.txt"
    desks_path = "0673_desks.txt"
    n = 500

    if len(argv) >= 2:
        beds_path = argv[1]
    if len(argv) >= 3:
        desks_path = argv[2]
    if len(argv) >= 4:
        n = int(argv[3])

    print(solve_from_files(beds_path, desks_path, n))


if __name__ == "__main__":
    main(sys.argv)
