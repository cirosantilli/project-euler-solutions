# Project Euler 539 Solution - Odd Elimination

<https://projecteuler.net/problem=539>:

* [539.py](539.py)

This repository contains a fast (logarithmic-time) solution for:

\[
S(n)=\sum_{k=1}^{n} P(k),\qquad \text{find } S(10^{18}) \bmod 987654321
\]

where `P(n)` is the last remaining number after repeatedly removing every other
number from the list `1..n`, alternating the direction each round.

## Key techniques

### 1) Elimination-game recurrence for `P(n)`
After the first left-to-right pass, the remaining numbers are:

\[
2,4,6,\dots,2\lfloor n/2\rfloor
\]

This is `2 × [1,2,...,⌊n/2⌋]`, and the direction flips for the next round. That
leads to the well-known recurrence:

\[
P(1)=1,\qquad
P(n)=2\left(1+\left\lfloor \frac{n}{2}\right\rfloor - P\left(\left\lfloor \frac{n}{2}\right\rfloor\right)\right)
\]

So `P(n)` is computed in `O(log n)` time.

### 2) Pairing property
For `m ≥ 1`:

\[
P(2m)=P(2m+1)
\]

because both depend on the same `⌊n/2⌋ = m` in the recurrence. This lets us sum
`P(k)` in chunks of size 2.

### 3) A divide-and-conquer recurrence for `S(n)`
Using the pairing and rewriting `P(2m)` in terms of `P(m)` gives:

\[
P(2m)=2(m+1-P(m))
\]

From there, summing over pairs and separating even/odd `n` yields closed recurrences:

- If `n = 2q + 1`:

\[
S(2q+1)=1+2q(q+3)-4S(q)
\]

- If `n = 2q`:

\[
S(2q)=2q^2+4q-1-4S(q-1)-2P(q)
\]

Each step halves the argument, so `S(n)` is also computed in `O(log n)` time.

### 4) Memoization and modular arithmetic
Both recurrences are evaluated with memoization (`functools.lru_cache`), and all
`S(n)` computations are reduced modulo `987654321` to keep numbers small and fast.

## Correctness checks
The implementation includes asserts for the values given in the problem statement:

- `P(1)=1`
- `P(9)=6`
- `P(1000)=510`
- `S(1000)=268271`

## Complexity
- Time: `O(log n)`
- Space: `O(log n)` (cache size and recursion depth)
