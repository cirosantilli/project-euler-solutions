# Project Euler 861 Solution - Products of Bi-Unitary Divisors

<https://projecteuler.net/problem=861>:

* [861.py](861.py)

This program computes:

\[
\sum_{k=2}^{10} Q_k(10^{12})
\]

where \(Q_k(N)\) counts integers \(n\) with \(1<n\le N\) such that the product of all **bi-unitary divisors** of \(n\) equals \(n^k\).

---

## 1) Turning the divisor product into a counting problem

For \(n>1\), every bi-unitary divisor \(d\) has a distinct partner \(n/d\), and both are bi-unitary.  
So the product of all bi-unitary divisors is:

\[
P(n)=n^{b(n)/2}
\]

where \(b(n)\) is the number of bi-unitary divisors of \(n\).  
Therefore:

\[
P(n)=n^k \quad \Longleftrightarrow \quad b(n)=2k
\]

So we only need to count \(n\le N\) with \(b(n)\in\{4,6,8,\dots,20\}\).

---

## 2) A multiplicative formula for \(b(n)\)

The function \(b(n)\) is multiplicative, and for a prime power \(p^e\):

- if \(e\) is even, one exponent choice is “forbidden” and  
  \[
  b(p^e)=e
  \]
- if \(e\) is odd, no exponent is forbidden and  
  \[
  b(p^e)=e+1
  \]

Equivalently:

\[
b(p^e)=e+(e\bmod 2)
\]

---

## 3) Splitting numbers into a powerful part and a squarefree part

Write:

\[
n = a\cdot s
\]

- \(a\) is **powerful**: every prime exponent \(\ge 2\)
- \(s\) is **squarefree**: every exponent is either 0 or 1
- \(\gcd(a,s)=1\)

Squarefree primes contribute \(b(p^1)=2\), so if \(s\) has \(m\) distinct primes:

\[
b(n)=b(a)\cdot 2^m
\]

Because we only need \(b(n)\le 20\), the squarefree part needs at most 4 primes.

The program enumerates all powerful \(a\le N\) with \(b(a)\le 20\), and for each \(a\) counts valid squarefree extensions \(s\).

---

## 4) Counting squarefree extensions using prime counting

For fixed \(a\), let \(L=\lfloor N/a\rfloor\).  
We need the number of squarefree products of \(m\) distinct primes \(\le L\), excluding primes that already divide \(a\).

This reduces to combinatorial counts like:

- \(m=1\): count primes \(\le L\)
- \(m=2\): \(\sum_{p} (\pi(L/p)-\pi(p))\)
- \(m=3,4\): small-depth recursion with pruning

So the bottleneck becomes **fast \(\pi(x)\)** queries.

---

## 5) Precomputing \(\pi(x)\) on the hyperbola set (Lucy / hyperbola method)

A classic trick is to precompute \(\pi(x)\) only for the values:

\[
\left\{ \left\lfloor \frac{N}{i}\right\rfloor : 1\le i\le \lfloor\sqrt{N}\rfloor \right\}
\;\cup\;
\{1,2,\dots,\lfloor\sqrt{N}\rfloor\}
\]

There are only about \(2\sqrt{N}\) distinct values.

The program initializes \(g(v)=v-1\) for each \(v\) in that set, then applies the recurrence:

\[
g(v)\; \mathrel{-}= \; g(\lfloor v/p\rfloor)-g(p-1)
\quad\text{for each prime }p\text{ and }v\ge p^2
\]

After processing all needed primes, \(g(v)=\pi(v)\) for every \(v\) in the set, and
\(\pi(x)\) lookups become \(O(1)\).

---

## 6) Practical pruning

To keep the squarefree recursion small, the code stops early when the smallest possible product of remaining primes would exceed the limit.  
For example, in the 2-prime case it stops when \(p^2 > L\), because then no \(q>p\) can satisfy \(pq\le L\).

---

## Output

Running `main.py` prints the required value for \(N=10^{12}\).  
The example checks from the problem statement are enforced via `assert`.
