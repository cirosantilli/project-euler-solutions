# Project Euler 759 Solution - A Squared Recurrence Relation

<https://projecteuler.net/problem=759>:

* [759.py](759.py)

## Key observations

The recurrence is:

- `f(1) = 1`
- `f(2n) = 2 f(n)`
- `f(2n+1) = 2n+1 + 2 f(n) + f(n)/n`

Define `s(n) = f(n) / n`. Then:

- `s(2n) = s(n)`
- `s(2n+1) = 1 + s(n)`

Repeatedly halving an integer and adding `1` exactly when it is odd is the standard recursion for the **number of 1-bits** in its binary representation. Therefore:

- `s(n) = popcount(n)`
- `f(n) = n · popcount(n)`

So the required sum becomes:

`S(N) = Σ_{i=1..N} (i² · popcount(i)²)` (computed modulo `1,000,000,007`).

## Range DP over binary prefixes

`N` is huge, so we cannot iterate.

We compute aggregated “moments” over a range `[0..n]`:

For `t ∈ {0,1,2}` and `d ∈ {0,1,2}` store:

`M[t][d] = Σ i^d · popcount(i)^t`.

The answer we need is `M[2][2]` (since `i² · popcount(i)²`).

### Splitting by the highest bit

Let `p = 2^k` be the highest power of two with `p ≤ n`, and write numbers in `[p..n]` as `p + y`.

Then:

- `popcount(p + y) = 1 + popcount(y)`
- `(p + y)^d` expands with the binomial formula (only up to `d=2`)

So sums over `[p..n]` can be expressed using sums over `[0..(n-p)]`, plus small constant multipliers involving `p` and `p²`.

### Precomputing full blocks

For fast recursion, we precompute matrices for complete blocks:

`full[m] = aggregates over [0 .. 2^m − 1]`

Using a simple recurrence that appends a leading `0` half and a leading `1` half, where the leading `1` half is handled by the same “shift by p and add 1 to popcount” transformation.

## Complexity

Only ~54 bits are needed for `10^16`, so the algorithm runs in essentially **O(log N)** time with constant-sized (3×3) arithmetic.
