# Project Euler 319 Solution - Bounded Sequences

<https://projecteuler.net/problem=319>:

* [319.py](319.py)

We count sequences of integers \(x_1,\dots,x_n\) with \(x_1=2\), strictly increasing, and

\[
(x_i)^j < (x_j+1)^i \quad \text{for all } i,j.
\]

The program in `main.py` prints \(t(10^{10}) \bmod 10^9\) and includes assertions for the sample values from the statement.

## Key ideas

### 1) Turn the pairwise inequality into a single “gap” condition
Take logs:

\[
\frac{\ln x_i}{i} < \frac{\ln(x_j+1)}{j} \quad (\forall i,j).
\]

This is equivalent to

\[
\max_i \frac{\ln x_i}{i} \;<\; \min_j \frac{\ln(x_j+1)}{j}.
\]

So there exists a real \(r\) such that for every \(i\):

\[
\ln x_i < ir < \ln(x_i+1) \;\Longleftrightarrow\; x_i < e^{ir} < x_i+1.
\]

Let \(\alpha=e^r\). Then **every valid sequence is exactly**

\[
x_i = \lfloor \alpha^i \rfloor\qquad\text{for some } \alpha\in(2,3).
\]

Because \(\alpha>2\), the sequence of floors is automatically strictly increasing, so the monotonicity constraint is redundant.

### 2) Counting sequences = counting boundary points
As \(\alpha\) varies in \((2,3)\), the vector \((\lfloor\alpha\rfloor,\dots,\lfloor\alpha^n\rfloor)\) is constant on open intervals.
It only changes when **some** \(\alpha^k\) hits an integer.

So \(t(n)\) equals:

*1 plus the number of distinct \(\alpha\in(2,3)\) such that \(\alpha^k\in\mathbb{Z}\) for some \(1\le k\le n\).*  

These boundary points can be written as \(\alpha = m^{1/k}\).

### 3) Möbius inversion to remove duplicates
The same boundary \(\alpha\) can arise from many \((m,k)\). The trick is to classify each boundary by the **minimal** exponent \(k\) such that \(\alpha^k\) is an integer.

That leads to a clean arithmetic formula:

\[
c(k)=\sum_{d\mid k} \mu(d)\,\bigl(3^{k/d}-2^{k/d}-1\bigr),
\]

where \(c(k)\) is the number of boundaries whose minimal exponent is exactly \(k\), and \(\mu\) is the Möbius function.

Then

\[
t(n)=1+\sum_{k=1}^n c(k).
\]

### 4) Fast evaluation with the Mertens function and quotient grouping
Rewriting the double sum gives

\[
t(n)-1 = \sum_{d=1}^n \mu(d)\,G\!\left(\left\lfloor\frac{n}{d}\right\rfloor\right),
\]

where

\[
G(m)=\sum_{k=1}^m (3^k-2^k-1).
\]

Now group ranges of \(d\) where \(\lfloor n/d\rfloor\) is constant. Each block needs

\[
\sum_{d=L}^R \mu(d) = M(R)-M(L-1),
\]

where \(M(x)=\sum_{k\le x}\mu(k)\) is the **Mertens function**.

Computing \(M(x)\) for large \(x\) is done with a classic *Dujiao sieve* recursion plus memoization, after precomputing \(\mu\) up to about \(n^{2/3}\).
The outer sum uses only \(O(\sqrt n)\) distinct quotients.

### 5) Geometric series modulo an even modulus
We need sums of powers modulo \(10^9\) (even), so \((3^{m+1}-3)/2\) can’t use a modular inverse of 2.
Instead compute the numerator modulo \(2\cdot 10^9\), then do an **integer** divide by 2.

## Complexity

For \(n=10^{10}\):

* Sieve to \(\lfloor n^{2/3}\rfloor\) is a few million operations.
* The grouped summation and memoized Mertens recursion run in roughly \(O(\sqrt n)\) distinct states.

This is fast enough in pure Python.
