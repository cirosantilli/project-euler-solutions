# Project Euler 868 Solution - Belfry Maths

<https://projecteuler.net/problem=868>:

* [868.py](868.py)

This solution computes how many **adjacent swaps** are performed by the bell-ringers' permutation method before a given target ordering appears.

## Key idea

The described rule generates permutations in the **Steinhaus-Johnson-Trotter (SJT)** (also called **plain changes**) order:

- Start from the letters sorted alphabetically.
- Each step performs **one adjacent transposition**.
- Therefore, the number of swaps needed to *reach* a target permutation equals its **0-based index** in this SJT listing.

## Direct ranking (no simulation)

Simulating the process would require visiting `n!` permutations, which is infeasible for `n = 18`.
Instead, the solution computes the SJT **rank** of the target permutation.

SJT has a convenient recursive structure:

- Build `SJT(n)` from `SJT(n-1)` by inserting the new largest element `n` into each `(n-1)`-permutation.
- The insertion direction alternates with the `(n-1)`-permutation's rank:
  - rank even: insert `n` from **right to left**
  - rank odd: insert `n` from **left to right**

To rank a permutation of size `n`:

1. Remove `n` to obtain a permutation of size `n-1`.
2. Recursively rank that smaller permutation (`i`).
3. Let `p` be the position of `n` in the original permutation.
4. Convert `p` into the within-block offset `t` depending on the parity of `i`.
5. Combine: `rank = i * n + t`.

## Mapping letters to numbers

Because the method compares letters by alphabetical order, the code maps the letters to `1..n` according to sorting, then ranks the resulting numeric permutation.

## Complexity

For `n` letters, the implementation is `O(n^2)` time (due to repeated `index` lookups and list slicing) and `O(n)` space, which is easily fast enough for `n = 18`.
