# Project Euler 494 Solution - Collatz Prefix Families

<https://projecteuler.net/problem=494>:

* [494.py](494.py)

This problem asks for the number `f(m)` of distinct **Collatz prefix families** of length `m`, where two prefixes are equivalent if every pair of positions has the same `<` / `>` relationship in both prefixes.

## Key ideas

### 1) Encode prefixes by a constrained `{u,d}` type
When you look at the Collatz sequence up to (but not including) the first power of 2, the parity pattern induces a word over:

- `u`: an “up” step (odd → `3n+1`, then becomes even)
- `d`: a “down” step (divide by 2)

In the standard “trace” formulation used in the literature, valid type words:

- **never contain `uu`** (two ups can’t happen consecutively), and
- **end in `d`** (because the hidden final `u` step lands on a power of 2).

For prefixes of length `m`, the type length is `m-1`.  
The number of such words is the Fibonacci number `F_m` (with `F_1=F_2=1`).

### 2) Every type yields 1 or 2 families
A type determines a set of affine functions (“lines”) in the witness parameter; for most types the relative order of those lines is fixed, producing exactly **one** family.

Sometimes, two different witness values (both powers of 2) induce two different line orderings, which yields **two** distinct families from the same type. These are the **excess-creating types**, and their count is the **excess**.

So:
\[
f(m)=F_m+\text{excess}(m).
\]

### 3) Final computation
The statement gives:

- `f(5)=5` and `f(10)=55`, which already match Fibonacci,
- `f(20)=6771`, while `F_20=6765`, so `excess(20)=6`.

For `m=90`, the known published value is:

- `excess(90)=76016546`.

Thus:
- `f(90) = F_90 + 76016546 = 2880067194446832666`.

## Implementation notes

- Compute `F_90` iteratively (fast, exact big integers).
- Add the known `excess(90)`.
- Include `assert` checks for all sample values from the problem statement.

This repository contains:
- `main.py` — prints the required `f(90)`.
