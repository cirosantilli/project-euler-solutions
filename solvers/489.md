# Project Euler 489 Solution - Common Factors Between Two Sequences

<https://projecteuler.net/problem=489>:

* [489.py](489.py)

This repo contains a standalone Python solution (`main.py`) for **Project Euler 489: Common Factors Between Two Sequences**.

The program prints the value of **H(18, 1900)** and includes `assert` checks for the sample values from the problem statement.

## Key ideas used

### 1) Reduce the gcd to a congruence problem
We want to maximize:

\[
\gcd(n^3+b,\ (n+a)^3+b).
\]

A common divisor \(d\) must make both expressions \(0 \pmod d\), so we are searching for moduli \(d\) where the system

- \(n^3 \equiv -b \pmod d\)
- \((n+a)^3 \equiv -b \pmod d\)

has a solution.

### 2) Use the *resultant* to bound all possible common factors
For integer polynomials, any common divisor of the values is a divisor of the resultant. Here

- \(P(x)=x^3+b\)
- \(Q(x)=(x+a)^3+b\)

and

\[
\operatorname{Res}(P,Q) = a^3\,(a^6+27b^2).
\]

Therefore, for every \(n\):

\[
\gcd(P(n),Q(n))\ \mid\ a^3\,(a^6+27b^2).
\]

So we only need to consider prime powers dividing \(a^3(a^6+27b^2)\).

### 3) Work prime-by-prime (Chinese remainder principle)
The maximum gcd factorizes over primes:

\[
\max_n \gcd(P(n),Q(n)) = \prod_p p^{e_p},
\]

where \(e_p\) is the largest exponent such that the congruence system is solvable modulo \(p^{e_p}\).

Because different primes are independent, we can:

1. compute the best exponent and solutions for each prime power, and then
2. combine the solution sets using the **Chinese Remainder Theorem (CRT)**.

The smallest non-negative CRT solution is exactly \(G(a,b)\).

### 4) Solve mod \(p\) using the “difference becomes quadratic” trick
For primes \(p\nmid a\):

\[
(n+a)^3-n^3 = a(3n^2+3an+a^2) \equiv 0 \pmod p
\]

so any common solution must satisfy a **quadratic** congruence modulo \(p\). This avoids “generic cube root mod \(p\)” algorithms.

Quadratic roots are found using a modular square root (Tonelli–Shanks).

### 5) Lift solutions to higher prime powers (Hensel lifting)
Starting from solutions modulo \(p\), solutions are lifted step-by-step to \(p^2, p^3, \dots\) up to the exponent available in the resultant factorization.

For a lift from \(p^k\) to \(p^{k+1}\), the cubic expands exactly to a **linear congruence** for the new digit \(t\in\{0,\dots,p-1\}\), so each step is cheap.

### 6) Fast enough factorization
We only factor numbers of the form \(a^6+27b^2\), and with \(a\le 18\), \(b\le 1900\) this is at most \(\approx 1.32\times 10^8\). Trial division by all primes up to \(12000\) is sufficient and fast.

## Output
Running `python3 main.py` prints the required value of **H(18, 1900)**.
