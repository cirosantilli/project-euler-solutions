# Project Euler 619 Solution - Square Subsets

<https://projecteuler.net/problem=619>:

* [619.py](619.py)

## Idea
For each integer `n`, write its prime factorisation

- `n = ∏ p^{e_p}`

Only the parity of each exponent matters when asking if a product is a perfect square.
Define the **squarefree kernel**

- `k(n) = ∏ p` over primes where `e_p` is odd.

A subset product is a square **iff** the XOR (mod 2) of all parity-vectors is the zero vector.

So if we have `m = b-a+1` vectors and their rank over **GF(2)** is `r`, the linear map

- choose subset → XOR-sum

has kernel size `2^{m-r}`. That is exactly the number of subsets whose product is a square, including the empty subset.
Therefore

- `C(a,b) = 2^{m-r} - 1`.

The whole problem becomes: **compute the rank** of the squarefree-kernel vectors.

## Key optimisation: split primes into “small” and “big”
Let `T = ⌊√b⌋`.

- **Small primes**: `p ≤ T` (there are only ~200 of these for `b ≈ 1.2e6`)
- **Big primes**: `p > T`

For any `n ≤ b`, its squarefree kernel contains **at most one** big prime:
if two factors were both `> T`, their product would be `≥ (T+1)^2 > b`.

So every vector looks like:

- just a **small-bitmask**, or
- `e_p + small_bitmask` for a single big prime `p`.

This special structure makes the rank computation cheap.

## Rank computation strategy
1. **Pivot on big primes first**: every distinct big prime `p` that appears contributes `+1` to the rank, because it is a unique column that no other big prime touches.
2. Extra occurrences with the same big prime `p` can be XORed to cancel `e_p`:

   - `(e_p + s1) XOR (e_p + s2) = s1 XOR s2` (a purely-small vector)

   These differences are added into the small subspace.
3. The **small subspace rank** is computed with standard incremental Gaussian elimination over GF(2), but with an integer bitmask (fast XOR), and the basis size is ≤ `π(T)` (~200).

Overall:

- `rank = (#distinct big primes) + rank_small`.

## Implementation notes
- A linear-time **smallest prime factor (SPF)** sieve factors all numbers quickly.
- Small primes are mapped to bit positions in an integer mask.
- The algorithm streams through `n=a..b` once, and maintains only:
  - a dictionary of first-seen small masks per big prime
  - a tiny GF(2) basis for small masks

This runs comfortably fast for the target range.
