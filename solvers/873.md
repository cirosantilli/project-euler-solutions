# Project Euler 873 Solution - Words with Gaps

<https://projecteuler.net/problem=873>:

* [873.py](873.py)

## Key idea

Let `S` be the word obtained by deleting all `C` letters from a valid word.  
Then `S` is a string of `p` `A`s and `q` `B`s.

Whenever two consecutive letters of `S` are different (`AB` or `BA`), the original word must place **at least two `C`s** between them. If the consecutive letters are the same (`AA` or `BB`), there is no extra requirement.

So the whole problem is controlled by:

- `t` = the number of **transitions** in `S` (positions where `S[i] != S[i+1]`)
- distributing `r` `C`s into the `p+q+1` gaps around the letters of `S`, with a lower bound of `2` `C`s on each transition gap.

## Counting strategy

### 1) Count `A/B` strings by number of transitions

A binary string with `t` transitions has `t+1` **runs** (maximal blocks of identical letters).

If it starts with `A`, the number of `A`-runs is `ceil((t+1)/2)` and the number of `B`-runs is `floor((t+1)/2)` (and vice versa if it starts with `B`).

For fixed numbers of runs, the number of strings is:

- choose a positive composition of `p` into `a_runs` parts: `C(p-1, a_runs-1)`
- choose a positive composition of `q` into `b_runs` parts: `C(q-1, b_runs-1)`

Summing over the two possible starting letters gives the number of `A/B` strings with exactly `t` transitions.

### 2) Distribute the `C`s (stars and bars)

There are `p+q+1` gaps around the `A/B` letters.  
Each of the `t` transition gaps needs at least `2` `C`s, so after reserving `2t` `C`s, the remaining

`r' = r - 2t`

`C`s are distributed freely among the gaps:

`C(r' + (p+q), (p+q))`.

This depends only on `t`, not on the exact `A/B` string.

### 3) Sum over `t`

The final answer is:

`W(p,q,r) = sum_{t}  (#AB-strings with t transitions) * C((r-2t)+(p+q), (p+q))`.

Only values with `t <= floor(r/2)` can contribute.

## Making it fast modulo 1,000,000,007

The implementation uses three performance tricks:

1. **Binomial rows by recurrence**  
   `C(n,k+1) = C(n,k) * (n-k)/(k+1)` allows building `C(p-1,·)` and `C(q-1,·)` up to the needed `k` using only modular inverses of `1..p+1`.

2. **A recurrence for the changing binomial**  
   Let `B_t = C((r-2t)+(p+q), (p+q))`.  
   Since the top parameter drops by `2` each step, we can update:

   `B_{t} = B_{t-1} * (r-2(t-1))*(r-2(t-1)-1) / ((r+p+q-2(t-1))*(r+p+q-2(t-1)-1))`.

3. **Batch modular inverses for a consecutive range**  
   To avoid calling `pow(x, MOD-2)` millions of times, the code precomputes inverses for the required consecutive integers using a single exponentiation and prefix products.

## Complexity (for the target inputs)

Let `p = 10^6`, `q = 10^7`, `r = 10^8`.  
The sum runs up to `t_max = 2*min(p,q) = 2,000,000`.

The total runtime is essentially linear in:

- `p` (for binomial precomputation),
- `p+q` (for the initial `B_0` computation),
- and `t_max` (for the main summation),

with memory dominated by the inverse tables for a ~4,000,000-long consecutive range.
