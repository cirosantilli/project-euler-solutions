#!/usr/bin/env python3
# Generated by GPT-5.2 Thinking web UI on 2025-12-24.
"""
Project Euler 176
Right-angled triangles that share a cathetus.

Let L be a leg length. Count the number of integer right triangles having one leg exactly L.

Known counting reduction:
- If L is odd, count(L) = (tau(L^2) - 1) / 2
- If L is even, count(L) = (tau((L/2)^2) - 1) / 2

We need the smallest L such that count(L) = 47547.
"""

from __future__ import annotations

from math import isqrt
from typing import List, Tuple


def _factorize(n: int) -> List[Tuple[int, int]]:
    """Trial division factorization."""
    x = n
    f: List[Tuple[int, int]] = []
    p = 2
    while p * p <= x:
        if x % p == 0:
            e = 0
            while x % p == 0:
                x //= p
                e += 1
            f.append((p, e))
        p = 3 if p == 2 else p + 2
    if x > 1:
        f.append((x, 1))
    return f


def _divisors_from_factors(factors: List[Tuple[int, int]]) -> List[int]:
    divs = [1]
    for p, e in factors:
        pe = 1
        new = []
        for _ in range(e + 1):
            for d in divs:
                new.append(d * pe)
            pe *= p
        divs = new
    divs.sort()
    return divs


def tau_of_square(n: int) -> int:
    """tau(n^2) from factorization of n: if n=∏p^e, then tau(n^2)=∏(2e+1)."""
    x = n
    prod = 1
    p = 2
    while p * p <= x:
        if x % p == 0:
            e = 0
            while x % p == 0:
                x //= p
                e += 1
            prod *= 2 * e + 1
        p = 3 if p == 2 else p + 2
    if x > 1:
        prod *= 3
    return prod


def count_triangles_with_cathetus(L: int) -> int:
    """
    Number of integer right triangles having a leg of length exactly L.
    """
    m = L if (L % 2 == 1) else (L // 2)
    return (tau_of_square(m) - 1) // 2


def _minimal_m_for_tau_square(target: int, primes: List[int]) -> int:
    """
    Find minimal m such that tau(m^2) = target (target is odd),
    by assigning nonincreasing exponents to primes.
    """
    best = None

    def rec(rem: int, idx: int, max_e: int, cur: int) -> None:
        nonlocal best
        if rem == 1:
            best = cur if best is None else min(best, cur)
            return
        if idx >= len(primes):
            return
        if best is not None and cur >= best:
            return

        # factors (2e+1) must divide rem
        ds = _divisors_from_factors(_factorize(rem))
        for d in reversed(ds):
            if d == 1:
                continue
            e = (d - 1) // 2
            if 2 * e + 1 != d:
                continue
            if e > max_e:
                continue
            nxt = cur * (primes[idx] ** e)
            if best is not None and nxt >= best:
                continue
            rec(rem // d, idx + 1, e, nxt)

    rec(target, 0, 10**9, 1)
    assert best is not None
    return best


def solve() -> int:
    k = 47547
    target = 2 * k + 1  # tau(m^2) must equal this

    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]

    # Either L is odd with m=L (so m must be odd),
    # or L is even with m=L/2 (m can be anything).
    m_any = _minimal_m_for_tau_square(target, primes)
    m_odd = _minimal_m_for_tau_square(target, primes[1:])  # exclude 2 => odd m

    if m_any % 2 == 1:
        return m_any  # L=m
    return min(2 * m_any, m_odd)


def _assert_examples() -> None:
    # Statement example: cathetus 12 is shared by exactly 4 right triangles.
    assert count_triangles_with_cathetus(12) == 4


if __name__ == "__main__":
    _assert_examples()
    print(solve())
