# Project Euler 428 Solution - Necklace of Circles

<https://projecteuler.net/problem=428>:

* [428.py](428.py)

This solution solves Project Euler 428 efficiently in pure Python (no external libraries)
and avoids brute force for `T(10^9)`.

---

## 1) Geometry → Arithmetic (Steiner Necklace Criterion)

The problem asks when a triple `(a,b,c)` forms a valid **Steiner necklace** between
two circles determined by collinear points. A classical result gives that
`(a,b,c)` is a necklace iff:

\[
\frac{b(a+b+c)-ac}{b(a+b+c)+ac} \in \left\{-1,-\frac12,0,\frac12,1\right\}.
\]

The cases `±1` are impossible with positive integers, leaving only:

- `0`
- `-1/2`
- `+1/2`

Each produces a Diophantine equation that factors neatly.

---

## 2) Three Factorisation Cases

For fixed `b`, each allowable value yields:

### Case 1: ratio = 0
\[
(a-b)(c-b)=2b^2
\]
Number of ordered solutions: `τ(2b²)`.

### Case 2: ratio = −1/2
\[
(a-3b)(c-3b)=12b^2
\]
Number of ordered solutions: `τ(12b²)`.

### Case 3: ratio = +1/2
\[
(3a-b)(3c-b)=4b^2
\]
Solutions depend on `b mod 3`.

- If `3 | b`, only divisors with a **3-adic exponent strictly between**
  `1` and `2v3(b)-1` are valid.
- If `3 ∤ b`, solutions correspond to divisors of `4b²` in one residue class mod 3,
  handled via a Dirichlet character.

This introduces a mod-3 character `χ` and divisor sum
\[
S(n)=\sum_{d|n}\chi(d).
\]

---

## 3) Reducing to Two Summatory Functions

Write:

\[
b = 2^i 3^j m,\quad (m,6)=1.
\]

All contributions become weighted sums of `τ(m²)` and `χ(m)S(m²)`.

Define:

- **F(x)**  
  \[
  F(x)=\sum_{m\le x,\ (m,6)=1}\tau(m^2)
  \]

- **G(x)**  
  \[
  G(x)=\sum_{m\le x,\ (m,6)=1}\chi(m)S(m^2)
  \]

Then `T(n)` is expressed as a short double sum over exponents `i,j`
(only ~600 terms for `n=10^9`), provided we can evaluate `F` and `G` quickly.

---

## 4) Fast Evaluation of F and G (Min_25-Style Sieve)

The core bottleneck is computing `F(x)` and `G(x)` for large `x`.

Both functions are **multiplicative** with simple prime-power rules
(depending only on the exponent and `p mod 3`), so we compute prefix sums via:

1. **Prime block tables** (Min_25 / Legendre-style):
   - `π(x)` for block values
   - `Σ_{p≤x} χ(p)` for block values

2. A **recursive multiplicative summatory** over primes:
   - enumerating smallest prime factor
   - memoizing `(n, idx)` states

This runs in about `O(n^(2/3))` preprocessing and a small recursion tree.

---

## 5) Final Assembly

Once `F(x)` and `G(x)` are available, we evaluate:

- `Σ τ(2b²)`
- `Σ τ(12b²)`
- `Σ` of the `+1/2` case (split by `v3(b)=0` vs `≥1`)

using the decomposition `b = 2^i 3^j m`.

---

## 6) Correctness Checks

The code includes asserts for the statement's test values:

- `T(1) = 9`
- `T(20) = 732`
- `T(3000) = 438106`

---

## Notes

- No brute forcing over `b ≤ 10^9`
- No external libraries
- All heavy computation is number-theoretic and relies on multiplicativity and prime sieving.
