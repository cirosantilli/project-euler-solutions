# Project Euler 558 Solution - Irrational Base

<https://projecteuler.net/problem=558>:

* [558.py](558.py)

This repository contains a **pure-Python** solution to Project Euler 558 with no third‑party libraries.

## Core idea

Let `r` be the real root of `x³ = x² + 1`. Every positive integer has a unique finite representation as:

- digits in `{0,1}` (sum of distinct powers of `r`), and
- **spacing constraint**: no two `1` digits may appear within distance `< 3`  
  (equivalently `b_k + b_{k+1} + b_{k+2} ≤ 1` for all `k`).

Define `w(n)` as the number of `1` digits (terms) in that representation, and:

\[
S(N) = \sum_{n=1}^{N} w(n^2)
\]

## Techniques used

### 1) Incremental squares via odd numbers
We avoid recomputing `n²` each time:

\[
n^2 = (n-1)^2 + (2n-1)
\]

So we maintain two representations:

- `f` = representation of the current odd increment `(2n-1)`
- `g` = representation of the current square `n²`

and update `g ← g + f` each step.

### 2) Bitset representation
A digit string is stored as a Python `int` bitset:

- bit index `i` corresponds to exponent `(i - SHIFT)`
- `SHIFT` is a constant offset (chosen as `256`, i.e. **8-bit aligned**) so indices stay non‑negative

This makes `w(n)` extremely fast via `int.bit_count()`.

### 3) Stack-based “insertion automaton” (local rewrite rules)
The key operation is to **insert** a `1` at a given exponent and renormalize to restore the spacing constraint.

This is implemented as a deterministic local rewrite system driven by a stack:

- try to set a bit at position `x`
- if it conflicts with existing bits (or creates forbidden patterns),
  rewrite using identities implied by `r³ = r² + 1`
- push a small number of nearby positions back onto the stack

This behaves like a small automaton operating on a local neighborhood (constant-sized rule set),
and it is fast because each insertion only triggers a short chain of local rewrites.

### 4) Batch insertion for fast addition
To add the current odd increment `f` into the square `g`, we **push all `1` positions of `f`** into a single stack and run the same insertion automaton once. This reduces Python function-call overhead compared to inserting each bit via separate calls.

## Correctness checks (from the statement)

`main.py` includes asserts for:

- `w(3) = 4`
- `w(10) = 3`
- `S(1000) = 19403`

## Running

```bash
python3 main.py
# or with a custom N:
python3 main.py 1000
```
