# Project Euler 257 Solution - Angular Bisectors

<https://projecteuler.net/problem=257>:

* [257.py](257.py)

We have an integer–sided triangle `ABC` with side lengths `a ≤ b ≤ c` where
`BC = a`, `AC = b`, `AB = c`. Let the angle bisectors hit the opposite sides at
`E, F, G` as in the problem picture. We want the number of such triangles with
perimeter `≤ 100,000,000` for which

`area(ABC) / area(AEG)` is an integer.

## Main ideas

### 1) Turn the geometry into arithmetic

Using the Angle Bisector Theorem:

* `AE = AB * AC / (AC + BC) = c * b / (a + b)`
* `AG = AC * AB / (AB + BC) = b * c / (a + c)`

Triangles `ABC` and `AEG` share angle `A`, so

`area(ABC) / area(AEG) = (AB * AC) / (AE * AG)`

which simplifies to the clean condition

`(a + b)(a + c) / (b c)` is an integer.

Call that integer `k`.

### 2) `k` can only be 2, 3, or 4

With `a ≤ b ≤ c` we have `a + b ≤ 2b` and `a + c ≤ 2c`, hence

`(a + b)(a + c) ≤ 4bc`.

So `k ≤ 4`. Also `k ≠ 1` (that would force `a = 0`). Therefore:

* `k ∈ {2, 3, 4}`.

This finite case split is the key complexity reduction.

### 3) Algebraic rearrangement and a “shape + scale” decomposition

From `(a + b)(a + c) = kbc` we get

`a(a + b + c) = (k - 1)bc`.

Let `t = k - 1 ∈ {1, 2, 3}` and define `d = tb - a`.
Writing `g = gcd(a, d)` and `x = a/g`, `y = d/g` yields coprime `x, y` and

* `a = g x`
* `b = g(x + y)/t`
* `c = g·x((t + 1)x + y)/(t y)`

All triangles sharing the same coprime `(x, y)` are obtained just by scaling
`g`. This lets us count by summing

`floor(limit / perimeter_of_minimal_triangle)`

over “primitive” shapes.

### 4) Ordering + triangle inequality become simple bounds on `y/x`

Enforcing `a ≤ b ≤ c` and `a + b > c` translates into:

* `y > x`
* `y² ≤ (t + 1) x²`

So for each `t` we only need coprime pairs `(x, y)` in a narrow interval:

* `t = 1`: `x < y ≤ ⌊√2·x⌋`
* `t = 2`: `x < y ≤ ⌊√3·x⌋`
* `t = 3`: forces `y = 2x`, and with `gcd(x, y)=1` this is only `(x, y)=(1, 2)` ⇒
  **equilateral triangles only**.

### 5) Minimal scaling factors become “tiny number theory”

For each `(t, x, y)` we need the smallest `g₀` making `b` and `c` integers.

Because `t` is just 1 or 2, the required divisibility collapses to simple
checks:

* For `t = 1` (`k = 2`): `g₀` depends only on the parity of `y`.
* For `t = 2` (`k = 3`): `g₀` depends only on parity of `x, y` and whether `y`
  is divisible by 3.

This removes extra `gcd` calls inside the tight loops.

## Complexity

The enumeration runs over coprime pairs `(x, y)` with `y/x` bounded by a small
constant and with `x` bounded by `O(√limit)`. For each primitive triangle we add
`⌊limit / p₀⌋`.

In practice the provided `main.py` computes the answer for `100,000,000` in a
few seconds in CPython.
