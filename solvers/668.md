# Project Euler 668 Solution - Square Root Smooth Numbers

<https://projecteuler.net/problem=668>:

* [668.py](668.py)

## Core idea

A number `n` is **square root smooth** iff every prime factor `p` satisfies `p < sqrt(n)`.

Equivalently, `n` is **not** square root smooth iff it has a prime divisor `p >= sqrt(n)`.

### The “superior prime divisor” bijection

If `p` is a prime divisor of `n` with `p >= sqrt(n)`, then writing `n = p * m` gives `m <= p`.
Such a prime divisor is unique (two primes `>= sqrt(n)` would multiply to more than `n`).

So non-smooth numbers `<= N` are in bijection with pairs:

- `p` prime
- `1 <= m <= min(p, floor(N/p))`

This yields:

```
non_smooth(N) =  Σ_{p prime} min(p, floor(N/p))
smooth(N)     =  N - non_smooth(N)
```

### Splitting at `r = floor(sqrt(N))`

- If `p <= r`, then `floor(N/p) >= p`, so `min(p, floor(N/p)) = p`.
- If `p > r`, then `min(p, floor(N/p)) = floor(N/p)`.

So:

```
non_smooth(N) = Σ_{p <= r} p  +  Σ_{p > r} floor(N/p)
smooth(N)     = N - non_smooth(N)
```

## Summation over large primes by quotient grouping

For `p > r`, the quotient `q = floor(N/p)` is small.

All primes `p` with the same quotient `q` lie in:

- `p ∈ ( floor(N/(q+1)) , floor(N/q) ]`

Thus:

```
Σ_{p > r} floor(N/p)
= Σ_{q=1..floor(N/(r+1))}  q * ( π(floor(N/q)) - π(floor(N/(q+1))) )
```

where `π(x)` is the prime counting function.

## Computing many `π(x)` values at once

The program needs `π(x)` only for:

- `x = floor(N/k)` for small `k`
- all integers up to `floor(sqrt(N))`

It builds a descending list of these values (`vals`) and runs a sieve-like update on that list,
which results in `π(v)` for every `v` in `vals`.

This avoids calling an expensive prime-counting routine many times.
