# Project Euler 430 Solution - Range Flips

<https://projecteuler.net/problem=430>:

* [430.py](430.py)

## Key ideas

### 1) Reduce the problem to independent per-disk probabilities
Let disk `i` be flipped on a turn with probability `p_i`. We only care about the **parity** (even/odd)
of the number of flips applied to that disk:

- Start white.
- After `M` turns, it is white iff it was flipped an even number of times.

For independent turns, if a disk is flipped with probability `p` each turn, then

\[
P(\text{even flips})=\frac{1+(1-2p)^M}{2}.
\]

So by linearity of expectation,

\[
E(N,M)=\sum_{i=1}^{N}\frac{1+(1-2p_i)^M}{2}
      =\frac{N}{2}+\frac12\sum_{i=1}^{N} r_i^M,
\]
where `r_i = 1 - 2 p_i`.

### 2) Compute the one-turn flip probability
A disk at position `i` is **not** flipped iff both chosen endpoints are strictly left of `i`,
or both strictly right of `i`:

\[
p_i = 1 - \left(\frac{i-1}{N}\right)^2 - \left(\frac{N-i}{N}\right)^2.
\]

A useful algebraic simplification is that

\[
r_i = 1-2p_i = \frac{(2i-N-1)^2-(2N-1)}{N^2}.
\]

### 3) Recognize a midpoint Riemann sum for a smooth integral (for huge `N`)
Define

- \(x_i = \frac{2i-N-1}{N}\), which runs over the **midpoints** of `N` equal subintervals of `[-1,1]`
  with step \(h=\frac{2}{N}\),
- \(c = \frac{2N-1}{N^2}\).

Then \(r_i = x_i^2 - c\) and

\[
\sum_{i=1}^{N} r_i^M = \sum_{i=1}^{N} (x_i^2-c)^M
\]

is exactly the **composite midpoint rule** sample of the smooth function
\(f(x)=(x^2-c)^M\) on `[-1,1]`. Therefore,

\[
\sum_{i=1}^{N} r_i^M = \frac{1}{h}\int_{-1}^{1}(x^2-c)^M\,dx + \text{midpoint error}.
\]

The midpoint error is bounded by

\[
|I - hS| \le \frac{b-a}{24}h^2\max|f''|,
\]

so the corresponding error in the sum `S` is `O(M^2/N)`.  
For `N = 10^10` and `M = 4000` this bound is far below the `0.01` accuracy needed for rounding.

### 4) Expand the integral in the tiny parameter `c = O(1/N)`
Since \(c \approx \frac{2}{N}\) is extremely small for \(N=10^{10}\), expand:

\[
(x^2-c)^M = x^{2M} - M c\,x^{2M-2} + O(c^2).
\]

Integrating term-by-term on `[-1,1]`:

\[
\int_{-1}^{1}x^{2M}\,dx = \frac{2}{2M+1},\qquad
\int_{-1}^{1}x^{2M-2}\,dx = \frac{2}{2M-1}.
\]

So

\[
\int_{-1}^{1}(x^2-c)^M\,dx
= \frac{2}{2M+1} - \frac{2Mc}{2M-1} + O(c^2).
\]

Multiplying by \(1/h = N/2\) gives the closed form used in `main.py`:

\[
\sum_{i=1}^{N} r_i^M
= \frac{N}{2M+1} - \frac{NMc}{2M-1} + O\!\left(\frac{M^2}{N}\right).
\]

Finally,

\[
E(N,M)
= \frac{N}{2} + \frac{1}{2}\left(\frac{N}{2M+1} - \frac{NMc}{2M-1}\right),
\quad c=\frac{2N-1}{N^2}.
\]

This yields the required answer for \(E(10^{10},4000)\) when rounded to 2 decimals.

## What the code does
- Uses an `O(N)` exact summation routine for the small check values from the statement.
- Uses the derived `O(1)` closed form (with `Decimal`) for the large target instance.
- Prints the final answer rounded to 2 decimal places.
