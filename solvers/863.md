# Project Euler 863 Solution - Different Dice

<https://projecteuler.net/problem=863>:

* [863.py](863.py)

This write-up describes the techniques used in `main.py` to compute
\(S(1000)=\sum_{k=2}^{1000} R(k)\), where \(R(n)\) is the minimum expected number of
rolls needed to emulate a fair \(n\)-sided die using only fair 5- and 6-sided dice,
subject to the constraint that the *sequence of dice types rolled* is
predetermined.

## 1) Remainder-recycling state model

The key observation is that every such procedure can be expressed by repeatedly
maintaining a *uniform* integer over a contiguous range:

- The algorithm is in a state size \(s\), meaning it holds a value uniformly
  distributed in \(\{0,1,\dots,s-1\}\).
- Rolling an \(m\)-sided die (\(m\in\{5,6\}\)) expands the state to size \(t=s\cdot m\).
- From \(t\) equally likely outcomes, we can immediately allocate the largest
  multiple of \(n\), namely \(\lfloor t/n\rfloor\cdot n\) outcomes, evenly across the
  \(n\) final results.
- The remaining \(r=t\bmod n\) outcomes are “recycled” into a new uniform state of
  size \(r\) and the process continues.

Under this maximal-acceptance rule, the only information needed to continue is
the current remainder size \(s\in\{0,1,\dots,n-1\}\). State 0 means we are done.

## 2) Bellman optimality with two actions

From a nonterminal state \(s>0\), we choose which die to roll next:

- Action D5: \(m=5\)
- Action D6: \(m=6\)

Let \(r=(s\cdot m)\bmod n\). After one roll, we stop with probability
\(1-\frac{r}{s\cdot m}\) and otherwise continue in state \(r\). Therefore the
expected rolls from state \(s\) satisfy the Bellman equation:

\[
E(s)=\min_{m\in\{5,6\}}\left(1 + \frac{r}{s\cdot m}\,E(r)\right),\quad r=(s\cdot m)\bmod n.
\]

The desired quantity is \(R(n)=E(1)\).

## 3) Gauss–Seidel value iteration

For fixed \(n\), there are only \(n\) states and 2 actions per state, so we can
solve the Bellman equations numerically.

`main.py` uses **Gauss–Seidel value iteration**:

1. Initialize \(E(0)=0\) and \(E(s)=0\) for \(s>0\).
2. Repeatedly sweep states \(s=n-1,n-2,\dots,1\) and update
   \(E(s)\leftarrow\min\bigl(1+\alpha_5 E(r_5),\;1+\alpha_6 E(r_6)\bigr)\), where
   \(\alpha_m=\frac{r_m}{s\cdot m}\) and \(r_m=(s\cdot m)\bmod n\).
3. Stop when the maximum change in a sweep is below a tiny tolerance.

The descending sweep is helpful because when \(s\cdot m<n\), we have
\(r_m=s\cdot m\) and the transition goes to a *larger* state; updating larger
states first propagates information quickly.

In practice this converges in only a few dozen sweeps for all \(n\le 1000\).

## 4) Validation and final computation

The code includes assertions for the numerical values explicitly given in the
problem statement (formatted to 6 decimal places). Then it computes and prints
\(S(1000)=\sum_{k=2}^{1000} R(k)\) to 6 decimal places.

---

To run:

```bash
python3 main.py
```
