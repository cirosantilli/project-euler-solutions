# Project Euler 496 Solution - Incenter and Circumcenter of Triangle

<https://projecteuler.net/problem=496>:

* [496.py](496.py)

We want all integer‐sided triangles \(ABC\) such that:

- \(I\) is the incenter
- the line \(AI\) meets the circumcircle again at \(D \ne A\)
- \(AC = DI\)
- \(BC \le L\)

and we sum \(BC\) over all such triangles.

## 1) Geometry → a clean trig condition

A key trick is using **power of a point** at the incenter \(I\) with respect to the circumcircle.

Because \(A\) and \(D\) lie on the circumcircle and \(A,I,D\) are collinear:

\[
IA \cdot ID = \text{Pow}_{\odot ABC}(I).
\]

Also, using Euler’s classical relation between circumradius \(R\) and inradius \(r\):

\[
OI^2 = R^2 - 2Rr \quad \Rightarrow \quad \text{Pow}(I)=R^2-OI^2=2Rr.
\]

And from the right triangle at the incenter, \(IA = \dfrac{r}{\sin(A/2)}\). Combine:

\[
ID = \frac{2Rr}{IA} = 2R\sin(A/2).
\]

But \(AC=b = 2R\sin(B)\) (law of sines), so the condition \(AC=ID\) becomes:

\[
\sin(B) = \sin(A/2) \Rightarrow B=A/2 \Rightarrow A=2B.
\]

So we just need integer triangles with **angle \(A\) twice angle \(B\)**.

## 2) Angle condition → a Diophantine equation

Let \((a,b,c)=(BC,CA,AB)\). With \(A=2B\), trig identities give:

\[
c = \frac{a^2-b^2}{b} \quad\Longleftrightarrow\quad a^2 = b(b+c).
\]

Let \(g=\gcd(b,c)\). Write \(b=g u,\; b+c=g v\) with \(\gcd(u,v)=1\).
Then \(a^2=g^2uv\) forces \(u\) and \(v\) to be squares:

\[
u=p^2,\quad v=q^2,\quad \gcd(p,q)=1.
\]

Thus every solution is:

\[
a = t\,pq,\quad b=t\,p^2,\quad c=t\,(q^2-p^2),
\]
with constraints \(p<q<2p\) (triangle inequality) and \(t\ge 1\).

So for each primitive pair \((p,q)\), all multiples \(t\) work.

## 3) Turning the sum into something computable

For fixed \((p,q)\), \(BC=a=t\,pq \le L\) allows \(t \le \left\lfloor \frac{L}{pq}\right\rfloor\).
So its contribution to \(F(L)\) is:

\[
\sum_{t=1}^{\lfloor L/(pq)\rfloor} t\,pq
= pq \cdot \frac{n(n+1)}{2}, \quad n=\left\lfloor \frac{L}{pq}\right\rfloor.
\]

Therefore:

\[
F(L) = \sum_{\substack{p<q<2p\\ \gcd(p,q)=1}} pq \cdot \frac{n(n+1)}{2},\quad n=\left\lfloor \frac{L}{pq}\right\rfloor.
\]

## 4) Fast counting: floor-division grouping + Möbius / inclusion-exclusion

Directly iterating all valid \((p,q)\) is far too large. The implementation uses two standard speedups:

1. **Floor-division grouping (“harmonic lemma”)**  
   For fixed \(p\), let \(M=\lfloor L/p\rfloor\). Then
   \[
   \left\lfloor \frac{L}{pq}\right\rfloor = \left\lfloor \frac{M}{q}\right\rfloor,
   \]
   which is constant on intervals of \(q\). We iterate these intervals in \(O(\#\text{distinct quotients})\), not \(O(\text{range size})\).

2. **Summing \(q\) with \(\gcd(p,q)=1\)**  
   For an interval \([l,r]\), we need \(\sum_{l\le q\le r,\ \gcd(p,q)=1} q\).  
   Using Möbius inversion (equivalently inclusion–exclusion over prime factors of \(p\)):

   \[
   \sum_{\substack{q\le x\\ \gcd(p,q)=1}} q
   = \sum_{d\mid p} \mu(d)\, d \cdot \frac{\lfloor x/d\rfloor(\lfloor x/d\rfloor+1)}{2}.
   \]

   Because \(p \le \sqrt{L}\), it has few distinct prime factors, so enumerating squarefree divisors is cheap.

These two tricks together make \(F(10^9)\) run fast in pure Python.

## Output

Running `python3 main.py` prints the value of \(F(10^9)\), and it also checks the sample:

- `F(15) == 45` (given in the problem statement).
