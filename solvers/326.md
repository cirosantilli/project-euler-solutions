# Project Euler 326 Solution - Modulo Summations

<https://projecteuler.net/problem=326>:

* [326.py](326.py)

This solution computes **f(10^12, 10^6)** for Project Euler problem 326.

## Main ideas

### 1) Turn subarray sums into prefix-sum collisions
Define prefix sums modulo **M**:

- s_0 = 0
- s_n ≡ (a_1 + a_2 + ... + a_n) (mod M)

Then

  (a_p + a_{p+1} + ... + a_q) ≡ 0 (mod M)
  ⇔ s_q ≡ s_{p-1} (mod M)

So the answer is obtained by counting how often each residue appears among
{s_0, s_1, ..., s_N}:

  f(N, M) = Σ_x C(count[x], 2) = Σ_x count[x] * (count[x] - 1) / 2.

### 2) Closed form for a_n
Although a_n is defined recursively, it has a simple exact formula depending only on n mod 6:

- n % 6 == 0 → a_n = n/2
- n % 6 == 1 → a_n = (2n + 1)/3
- n % 6 == 2 → a_n = n/2
- n % 6 == 3 → a_n = (n - 3)/6
- n % 6 == 4 → a_n = n - 1
- n % 6 == 5 → a_n = (n - 5)/6

This lets us generate a_n in O(1) time per term.

### 3) Periodicity modulo M
For fixed M:

- a_{n+6M} ≡ a_n (mod M)
- and the sum of any full block of length 6M is 0 modulo M

Therefore the prefix sums s_n (mod M) are **periodic with period P = 6M**:

  s_{n+P} = s_n.

With N = qP + r, each index i in [0, P-1] contributes:

- q+1 occurrences if i ≤ r
- q occurrences otherwise

So we enumerate exactly one period (size 6M), add weighted counts into a frequency array,
then sum combinations.

## Complexity
For the target M = 10^6:

- Enumerating one period costs O(6M) ≈ 6,000,000 steps.
- The frequency array has size M (1,000,000) and uses 64-bit counters.

This fits comfortably in time and memory.
