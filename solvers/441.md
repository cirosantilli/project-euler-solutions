# Project Euler 441 Solution - The Inverse Summation of Coprime Couples

<https://projecteuler.net/problem=441>:

* [441.py](441.py)

This repository contains a standalone Python solution (no external libraries) for **Project Euler 441: The inverse summation of coprime couples**.

## Main techniques used

### 1) Rewriting the double constraint by swapping summations
The definition of `S(N)` is a sum over `M`, and inside it a sum over coprime pairs `(p, q)` that satisfy `p + q ≥ M`.

A key step is to **swap the order of summation**:
- Fix `(p, q)` first.
- Count how many `M` values include that pair.

This turns the original definition into a sum over coprime pairs with a **piecewise weight** depending on whether `p + q ≤ N` or `p + q > N`.

### 2) Möbius inversion to handle the coprime condition
The coprimality indicator is expanded using the Möbius function:

- `[(p, q) = 1] = Σ_{d | p, d | q} μ(d)`

This converts “coprime-only” sums into **divisor sums** that can be reorganized as sums over multiples.

### 3) Harmonic numbers and closed-form summatory identities
Many inner sums become harmonic-number expressions. The code precomputes harmonic arrays using **Kahan compensated summation** to keep enough precision for 4-decimal rounding at N = 10^7.

The code precomputes:

- `H(n)  = Σ 1/k`
- `H2(n) = Σ 1/k²`

and uses identities like:

- `Σ_{k=1..n} H_{k-1}/k = (H(n)² − H2(n)) / 2`
- `Σ_{k=1..n} H(k) = (n+1)·H(n) − n`

These avoid building large prefix-sum tables and reduce many “range sums” to **O(1)** computations.

### 4) A single remaining non-trivial half-convolution
One term reduces to a sum of the form:

- `Σ_{r=1..L} H(r)/(M−r)`

This is computed directly but is **cached by (M, L)**. For `N = 10⁷`, many `(M, L)` pairs repeat for large divisors, so caching saves noticeable work.

### 5) Efficient arithmetic and memory layout
- `array('d')` is used for harmonic tables (`H`, `H2`) to store doubles compactly.
- `array('b')` and a linear sieve compute Möbius values efficiently.

## Correctness checks
The problem statement provides:

- `S(2) = 1/2`
- `S(10) ≈ 6.9147`
- `S(100) ≈ 58.2962`

`main.py` includes asserts that verify these values via a small brute-force implementation.

## Running

```bash
python3 main.py
```

Optionally run for a smaller `N`:

```bash
python3 main.py 1000
```
