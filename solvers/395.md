# Project Euler 395 Solution - Pythagorean Tree

<https://projecteuler.net/problem=395>:

* [395.py](395.py)

This solution computes the **axis-aligned bounding rectangle** (parallel to the initial unit square) that contains the entire *infinite* 3–4–5 Pythagorean tree.

The program prints the area, rounded to **10 decimal places**.

## Key techniques

### 1) Similarity-based square representation
Each square is represented by:

- `p`: the **base-left** corner (origin)
- `u`: the **base** side vector
- `v`: the **outward** side vector (same length as `u`, 90° CCW rotation)

So the four corners are:

- `p`
- `p + u`
- `p + u + v`
- `p + v`

This handles all rotations and scales without trig.

### 2) Exact local construction for the 3–4–5 step
For a parent square of side length `s`, the triangle is attached to the **top** edge with:

- hypotenuse length `s`
- legs `4s/5` and `3s/5`
- *smaller leg on the right* (as required by the statement)

In the square’s local basis `(u, v)` the right-angle vertex is:

- `C = A + (16/25) u + (12/25) v`

where `A` is the **top-left** corner of the square.

Two child squares are built on legs `A–C` and `B–C`, and oriented so they lie **outside** the triangle.

### 3) Branch-and-bound pruning with a rigorous disk bound
A naive breadth-first generation grows as `2^n`. To avoid that, we prune subtrees that cannot affect the final bounding box.

We compute a safe constant `R` such that the entire unit tree lies inside a disk of radius `R` around the **root square’s center**. Using the fixed distances from parent-center to child-centers:

- `d_left  = sqrt(13/10)` (child scaled by `4/5`)
- `d_right = sqrt(29)/5`  (child scaled by `3/5`)

The radius must satisfy:

- `R >= sqrt(2)/2` (covers the root square)
- `R >= d_left  + (4/5) R`
- `R >= d_right + (3/5) R`

Solving gives:

- `R = 5 * sqrt(13/10)`

For any node square of side `s`, its entire infinite subtree lies inside a disk of radius `s * R` around that square’s center.  
If that disk is fully inside the current global bounds (with a tiny epsilon), that node **cannot** improve `xmin/xmax/ymin/ymax`, so we skip expanding it.

### 4) Priority-driven expansion
Squares are expanded in **decreasing side length** order (a max-heap), so the global bounds tighten quickly and pruning becomes effective.

## Output
Running `python3 main.py` prints the area to 10 decimal places.
