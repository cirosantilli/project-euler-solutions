#!/usr/bin/env python
"""Adapted from https://github.com/igorvanloo/Project-Euler-Explained/blob/19f85895945a2c9b688f85da142bae13f37dab65/Finished%20Problems/pe00618%20-%20Numbers%20with%20a%20given%20prime%20factor%20sum.py"""

"""
Created on Wed Jul 28 23:14:47 2021

@author: igorvanloo
"""

"""
Project Euler Problem 618

Given all primes < the 24th Fibonnaci number = 46368
We want to find all ways to construct the integer k

let d(k, p) = sum of numbers such that the sum of their prime facorization is = k and there is no larger prime factor than p

d(0,2) = 1              d(0,3) = 1
d(1,2) = 0              d(1,3) = 0
d(2,2) = 2 (2)          d(2,3) = 2
d(3,2) = 0              d(3,3) = 3 (3)
d(4,2) = 4 (2x2)        d(4,3) = 4
d(5,2) = 0              d(5,3) = 6 (2*3)    d(5,5) = 5 (5)
d(6,2) = 8 (2*2*2)      d(6,3) = 17 (3*3)

We need to find a relation between these number because clealy the anwser for each k is the sum of the rows

One thing to notice is that we only need to deal with primes p because otherwise d(k,p) = d(k,p-1)

So what about d(k,p) when p is a prime, we an see a pattern in the first column
d(k,2) = 2*d(k-2,2) and again in the second column d(k,3) = 3*d(k-3,3)
So we have found a general relation d(k,p) = p*(k-p,p) when p is a prime

"""

import math


def list_primality(n):
    result = [True] * (n + 1)
    result[0] = result[1] = False
    for i in range(2, int(n**0.5) + 1):
        if result[i]:
            step = i
            start = i * i
            result[start : n + 1 : step] = [False] * (((n - start) // step) + 1)
    return result


def list_primes(n):
    return [i for i, isprime in enumerate(list_primality(n)) if isprime]


def sieve(n):
    result = [0] * (n + 1)
    for i in range(2, int(n) + 1):
        if result[i] == 0:
            for j in range(i, len(result), i):
                result[j] += i
                remainder = j / i
                while remainder % i == 0:
                    result[j] += i
                    remainder //= i
    return result


def compute1():  # Method 1, tried to make a sieve with prime divisors but quickly realised it would never be fast enough
    numbers = sieve(5 * 10**6)
    total = 0
    for x in range(len(numbers)):
        if numbers[x] == 4181:
            total += x % 10**9
    return total


def compute(limit):
    d = [1] + [0] * limit
    primes = list_primes(limit)
    mod = 10**9
    fibonnaci_numbers = fibonacci_numbers_up_to(limit)

    for p in primes:
        for i in range(p, limit + 1):
            d[i] += p * d[i - p] % mod

    total = 0
    for x in fibonnaci_numbers:
        total += d[x] % mod

    return total % mod


def fibonacci_numbers_up_to(limit):
    numbers = []
    a, b = 1, 2
    while b <= limit:
        numbers.append(b)
        a, b = b, a + b
    return numbers


def S_small(k):
    d = [1] + [0] * k
    primes = list_primes(k)
    for p in primes:
        for i in range(p, k + 1):
            d[i] += p * d[i - p]
    return d[k]


if __name__ == "__main__":
    assert S_small(1) == 0
    assert S_small(2) == 2
    assert S_small(3) == 3
    assert S_small(5) == 11
    assert S_small(8) == 49
    print(compute(46368))
