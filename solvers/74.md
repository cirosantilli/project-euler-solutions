# Project Euler 74 Solution - Digit Factorial Chains

<https://projecteuler.net/problem=74>:

* [74.py](74.py)
* [74.lean](74.lean)

We iterate the function:

`next(n) = sum( factorial(d) for each digit d of n )`

Every sequence eventually enters a loop, so the “chain length” for a start value is the number of distinct terms before the first repeat.

## Key insights

- For a number with `d` digits, `next(n) <= d * 9!`.
- Starting numbers `< 1,000,000` have at most 6 digits, so the first step is `<= 6*9!` (a 7-digit number).
- After that, values are bounded by `7*9! = 2,540,160`.  
  This allows precomputing `next(n)` for all `n` up to this limit.

## Approach

1. Precompute `next(n)` for all `n <= 2,540,160` using the recurrence:
   `next(n) = next(n//10) + factorial(n%10)`.
2. Compute chain lengths with memoization:
   - While building a chain, track positions of numbers seen in the current walk to detect loops.
   - When a loop is found, assign loop nodes length = loop size, and prefix nodes length = remaining unique terms.
   - When reaching a number with known length, propagate lengths back through the current sequence.
3. Count how many starts `1 <= n < 1,000,000` have chain length exactly 60.

The implementation avoids per-chain hash maps by using stamp arrays (`seen_stamp`, `seen_pos`) to detect repeats efficiently.
