# Project Euler 654 Solution - Neighbourly Constraints

<https://projecteuler.net/problem=654>:

* [654.py](654.py)

We count the number of length-`m` sequences `(a1,…,am)` of positive integers such that every adjacent sum satisfies `ai + a{i+1} ≤ n`, and we need

- `T(5000, 10^12) mod 1_000_000_007`.

## Key ideas

### 1) Transfer matrix / walk interpretation
For `m ≥ 2`, every `ai` must lie in `{1,…,n−1}`.  
Define a graph on vertices `1..(n−1)` with an edge `i → j` iff `i + j ≤ n`. Then `T(n,m)` is the number of walks of length `m−1` where start and end are arbitrary:

- Let `A[i,j] = 1` if `i+j ≤ n`, else `0` (a symmetric “anti-triangular” 0/1 matrix).
- Then `T(n,m) = 1ᵀ · A^(m−1) · 1`.

A direct matrix exponentiation is impossible for `n=5000`.

### 2) Fast generation of initial terms in `O(n^2)`
A DP for fixed `n`:

- `dp[j] =` number of sequences of current length ending at value `j`.
- Transition: `new_dp[i] = sum_{j ≤ n−i} dp[j]`.

With prefix sums this update is `O(n)` per step, so the first `2(n−1)` terms can be generated in `O(n^2)` time (about 50 million adds for `n=5000`).

### 3) Berlekamp–Massey to discover the recurrence
Because `A` is an `(n−1)×(n−1)` matrix, the sequence `T(n,1), T(n,2), …` satisfies a linear recurrence over the field modulo `p=1_000_000_007` of order at most `n−1`.

We compute the first `2(n−1)` terms and run **Berlekamp–Massey** to obtain the shortest recurrence:
`a_k = c1*a_{k-1} + ... + cL*a_{k-L}  (mod p)`.

### 4) Bostan–Mori to jump to `m = 10^12`
A linear recurrence implies the generating function is rational:

- `F(x) = Σ a_k x^k = P(x) / Q(x)`,
- `Q(x) = 1 − c1 x − ... − cL x^L`.

**Bostan–Mori** computes the coefficient `[x^N] P(x)/Q(x)` in `O(M(L) log N)` polynomial operations (where `M(L)` is the cost of multiplying degree-`L` polynomials), using repeated transforms with `Q(−x)` and taking even/odd coefficients.

### 5) FFT-based polynomial multiplication (no external libs)
To keep polynomial multiplications fast in pure Python, the solution uses a hand-rolled complex FFT plus a 15-bit coefficient split so rounding is safe:

- represent each coefficient as `low + high * 2^15`,
- use two inverse FFTs to recover the needed convolutions,
- combine chunks back modulo `1_000_000_007`.

## Complexity (for `n=5000`)
- Term generation: `O(n^2)`.
- Berlekamp–Massey: `O(n^2)`.
- Bostan–Mori: `O(M(n) log m)` with `M(n)` implemented via FFT.

This comfortably avoids any `O(n^3)` matrix work.

## Output
Running `main.py` prints the required value `T(5000, 10^12) mod 1_000_000_007`.
