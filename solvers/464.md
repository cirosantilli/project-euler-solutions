# Project Euler 464 Solution - Möbius Function and Intervals

<https://projecteuler.net/problem=464>:

* [464.py](464.py)

This repository contains a **pure-Python** solution (standard library only) for Project Euler problem 464.

## Core techniques used

### 1) Linear sieve for the Möbius function
We compute the Möbius function `μ(n)` for all `n ≤ N` using a **linear sieve** (Euler’s sieve):

- Keeps a list of primes.
- Tracks the least prime factor for each `n`.
- Produces `μ(n) ∈ {-1,0,1}` in overall **O(N)** time.

### 2) Rewrite the interval constraint with `D` and `S`
For an interval `[a,b]` let:

- `D = P - N = Σ μ(k)` over the interval
- `S = P + N = Σ |μ(k)|` over the interval (count of squarefree numbers)

The two inequalities in the statement simplify to:

- `|D| ≤ S / 199`

So the condition depends only on **(sum of μ)** and **(count of squarefree numbers)**.

### 3) Collapse `μ = 0` stretches into gap weights
Numbers with `μ=0` (non-squarefree) do not affect `D` or `S`, but they create many distinct endpoint choices.

We handle this by:
- Counting intervals fully inside each `μ=0` run of length `L` as `L(L+1)/2`.
- Compressing the problem to the sequence of squarefree numbers (`μ=±1`) and using:
  - a *start weight* = number of ways to choose `a` before the first squarefree
  - an *end weight* = number of ways to choose `b` after the last squarefree

This converts the answer to a **weighted count of valid squarefree segments**.

### 4) Transform to 2D dominance counting
Let `z_k ∈ {+1,-1}` be the Möbius values on squarefree numbers and:

- `W_k = z_1 + ... + z_k`

For prefixes `i<j`, the interval condition becomes:

- `|W_j - W_i| ≤ (j - i) / 199`

Define:

- `u_k = k + 199·W_k`
- `v_k = k - 199·W_k`

Then the condition is equivalent to:

- `u_i ≤ u_j` and `v_i ≤ v_j`

This is a classic **2D dominance** relation. Also:

- `u_k + v_k = 2k`

So dominance automatically implies the correct prefix order (no separate `i<j` check beyond excluding `i=j`).

### 5) Radix sort + Fenwick tree
To compute the weighted dominance efficiently:

- **Radix sort** (base `2^16`) sorts all prefix points by `(u,v)` in linear time.
- A **Fenwick tree** over `v` stores start weights and answers prefix-sum queries.

Overall shape:

- `O(N)` sieve
- `O(M)` build compressed data (where `M ≈ #squarefree ≤ N`)
- `O(M)` radix sort passes
- `O(M log M)` Fenwick operations

## Files
- `main.py` — computes and prints `C(20_000_000)` and includes asserts for all sample values from the statement.
