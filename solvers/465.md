# Project Euler 465 Solution - Polar Polygons

<https://projecteuler.net/problem=465>:

* [465.py](465.py)

This repository contains a pure-Python solution (no external libraries) for **Project Euler 465**:

> Find \(P(7^{13}) \bmod 1\,000\,000\,007\).

The script also includes `assert` checks for all sample values from the problem statement.

---

## Main ideas used

### 1) Reduce “polar polygons” to choices of directions
A polygon is *polar* iff the origin lies strictly inside its kernel, which (for polygons around the origin) is equivalent to:

- the polygon’s edge directions must wrap all the way around the origin, and
- there is no “gap” in the angular order of edge directions that would leave the origin outside the kernel.

When vertices are integer points inside \([-n,n]^2\), every edge direction corresponds to some **primitive lattice direction** \((a,b)\) with \(\gcd(a,b)=1\).

Consecutive collinear vertices are allowed, so multiple edges can share the same direction.

This lets us count polygons via a **combinatorial / generating-function** approach over available directions.

---

### 2) Count available edges per primitive direction using Euler’s totient
For a primitive direction \((a,b)\), the maximum number of usable steps is controlled by:

\[
m = \max(|a|,|b|),\quad \text{and } \left\lfloor \frac{n}{m} \right\rfloor
\]

The number of **undirected** primitive directions (lines through the origin) whose max-coordinate is exactly \(m\) is:

\[
c_m = 4\varphi(m)
\]

So, when we group directions by \(m\), totients appear naturally.

---

### 3) Closed form in three quantities: a product + two sums
Let \(q(m) = \left\lfloor \frac{n}{m} \right\rfloor\). Define:

- \(B = \prod_{m=1}^{n} (1+q(m))^{4\varphi(m)}\)
- \(S_1 = \sum_{m=1}^{n} 4\varphi(m)\,q(m)\)
- \(S_2 = \sum_{m=1}^{n} 4\varphi(m)\,q(m)^2\)

Then the final answer is:

\[
P(n) \equiv B^2 - 2BS_1 + S_2 - 1 \pmod{10^9+7}
\]

This is what `main.py` computes.

---

### 4) Fast evaluation using floor-division grouping
Both \(q(m)=\lfloor n/m\rfloor\) and the ranges where it stays constant can be enumerated in:

\[
O(\sqrt{n})
\]

by looping over blocks \([l,r]\) with the same quotient \(q\).

On each block we need:

\[
\sum_{m=l}^{r}\varphi(m)
\]

---

### 5) Summatory totient via a Du Jiao-style recursion
Let:

\[
\Phi(x) = \sum_{k=1}^{x}\varphi(k)
\]

For large \(x\), we compute \(\Phi(x)\) using the standard recursive identity (with divisor grouping):

\[
\Phi(n) = \frac{n(n+1)}{2} - \sum_{l=2}^{n} (r-l+1)\,\Phi\!\left(\left\lfloor \frac{n}{l} \right\rfloor\right)
\]

with memoization, while using a linear sieve to precompute \(\Phi(x)\) for all \(x \le \text{LIMIT}\).

---

## Running

```bash
python3 main.py
```

Optional: compute \(P(n)\) for your own input:

```bash
python3 main.py 343
```

Optional: tune the sieve size (memory vs speed trade-off):

```bash
PE465_LIMIT=8000000 python3 main.py
```

---

## Notes

- The solution is optimized for **mod \(10^9+7\)** arithmetic.
- Sample checks from the statement are included as `assert`s:
  - \(P(1)=131\)
  - \(P(2)=1648531\)
  - \(P(3)=1099461296175\)
  - \(P(343)\bmod 1\,000\,000\,007 = 937293740\)
