# Project Euler 254 Solution - Sums of Digit Factorials

<https://projecteuler.net/problem=254>:

* [254.py](254.py)

This solution computes

\[
\sum_{i=1}^{150} sg(i)
\]

where

- \(f(n)\) is the sum of factorials of the digits of \(n\)
- \(sf(n)\) is the digit-sum of \(f(n)\)
- \(g(i)\) is the smallest \(n\) with \(sf(n)=i\)
- \(sg(i)\) is the digit-sum of \(g(i)\)

The program prints the final numeric answer.

## Main techniques

### 1) Switch from searching \(n\) to searching \(k=f(n)\)

Define **invf**(\(k\)) as the smallest positive integer \(n\) such that \(f(n)=k\).
Then

- \(sf(\text{invf}(k)) = \text{digitSum}(k)\)
- therefore \(g(i) = \min_{\text{digitSum}(k)=i} \text{invf}(k)\)

So we can search over values of \(k\) (the factorial-sum), and *canonically* map each \(k\) to the smallest \(n\) that produces it.

### 2) Factoradic (factorial-number-system) representation for the remainder

Write

\[
k = q\cdot 9! + r, \quad 0 \le r < 9!
\]

For \(r < 9!\), the minimal-length representation of \(r\) as a sum of digit factorials is its
**factoradic** form:

\[
r = \sum_{d=1}^{8} a_d\, d! \quad \text{with } 0\le a_d \le d.
\]

This immediately gives the digit multiset of **invf**(\(k\)):

- \(a_d\) copies of digit \(d\) for \(d=1..8\)
- \(q\) copies of digit 9

No digit 0 is ever needed in the minimal representation.

The crucial consequence: for any \(k\), **invf**(\(k\)) contains at most

\(1+2+\dots+8 = 36\)

digits from \(1..8\), and the rest are 9s.

### 3) Only a small range of \(q\) matters

For fixed \(i\), let \(k_{min}\) be the smallest *decimal* integer with digit-sum \(i\).
Then \(q_{min} = \lfloor k_{min}/9!\rfloor\) is a lower bound on the number of 9s.

Because the non-9 part of **invf**(\(k\)) has length \(\le 36\), any solution with
\(q > q_{min}+36\) can’t be shorter (and therefore can’t be smaller).
So we only test \(q \in [q_{min}, q_{min}+36]\), with an extra early-stop once \(q\) itself
can’t beat the current best total length.

### 4) Precomputation + best-first search over the 9! remainders

There are exactly \(9! = 362{,}880\) possible remainders \(r\).

We precompute for every \(r\):

- its factoradic digits \((a_1..a_8)\)
- the count (length) \(\sum a_d\)
- the digit-sum contribution \(\sum d\cdot a_d\)

Then we sort remainders in “best first” order (shorter remainder digit multiset first;
ties broken by producing smaller digits earlier). For a fixed \(q\), the first remainder
that matches the required \(sf\) value is optimal for that \(q\).

### 5) Fast digit-sum check using a 6-digit split

Since \(r < 10^6\), for each \(k = q\cdot 9! + r\) we split \(q\cdot 9!\) into

- a high part \(H\) and
- a low 6-digit part \(L\)

and compute digit sums using a precomputed table for all values up to
\(10^6 + 9!\), handling the single possible carry.

### 6) Mod 9 filter

Because \(9!\) is divisible by 9, \(k \equiv r \pmod 9\). And digit sum modulo 9 equals the
number modulo 9, so only remainders with

\(r \equiv i \pmod 9\)

can contribute to \(g(i)\). This divides the remainder search by ~9.

---

The final answer printed by `main.py` is:

```
8184523820510
```
