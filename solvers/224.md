# Project Euler 224 Solution - Almost Right-angled Triangles II

<https://projecteuler.net/problem=224>:

* [224.py](224.py)

We count integer-sided triangles with sides `a ≤ b ≤ c` such that:

- `a² + b² = c² − 1`  (the triangle is “barely obtuse”)
- `a + b + c ≤ 75,000,000`

The program outputs the number of such triangles.

## Main techniques used

### 1) Generating all solutions with a transformation tree
Brute force over perimeters is far too slow. Instead, all integer triples `(a, b, c)` satisfying:

- `a² + b² = c² − 1`
- `a ≤ b ≤ c` and triangle inequality

can be generated **uniquely** from the root solution `(2, 2, 3)` by repeatedly applying three **linear** transformations (3×3 integer matrices). Each node produces up to three children, and every valid solution appears exactly once in this tree.

In code, these are implemented as direct formulas producing the children `(x, y, z)` from `(a, b, c)`.

### 2) Depth-first search (DFS) with pruning
We traverse the tree using an explicit Python list as a stack (iterative DFS).

- If `a + b + c > limit`, we **prune** that node and do not expand it.
- Otherwise we count it and push its children that still fit under the perimeter bound.

Because perimeters strictly grow along the tree, pruning is very effective.

### 3) Integer-only arithmetic and invariants
Everything is done with integers.

In debug mode (`python` without `-O`), we also assert invariants for safety:

- `a ≤ b ≤ c`
- triangle inequality
- `a² + b² = c² − 1`

## Complexity
The runtime is essentially `O(S)` where `S` is the number of valid triangles under the limit. For the Euler limit, `S = 4,137,330`, which is feasible with a simple DFS and pruning.
