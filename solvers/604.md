# Project Euler 604 Solution - Convex Path in Square

<https://projecteuler.net/problem=604>:

* [604.py](604.py)

## Key idea: turn the curve into a “step vector” problem

Take the lattice points on the graph in increasing `x`. Consecutive points differ by
a vector `(dx, dy)` with `dx > 0`, `dy > 0`.
Strict convexity + increasing means the slopes `dy/dx` are strictly increasing.

If `(dx, dy)` had `gcd(dx, dy) > 1`, it is just a multiple of a smaller vector with the
same slope. Using the smaller **primitive** vector costs less width/height and never
reduces the number of points, so an optimum uses only **primitive** steps with `gcd(dx,dy)=1`.

So we want the largest set of primitive vectors `(a, b)` with positive components such that:

- total width `Σ a ≤ N`
- total height `Σ b ≤ N`

Ordering them by slope automatically gives a strictly convex increasing chain.

---

## Group by `s = a + b` and use Euler’s totient

Fix `s = a + b`. A primitive vector is `(a, s-a)` and it is primitive iff:

- `gcd(a, s) = 1`  (because `gcd(a, s-a) = gcd(a, s)`)

Therefore, for each `s ≥ 2`, the number of primitive vectors with sum `s` is:

- `count(s) = φ(s)`

Also, the sum of all valid `a` values (reduced residues modulo `s`) is known:

- `Σ a = s·φ(s)/2`

So if we take **all** primitive vectors with `a+b ≤ t`, then:

- number of step vectors: `V(t) = Σ_{s=2..t} φ(s)`
- width used equals height used:
  `X(t) = Y(t) = (1/2) · Σ_{s=2..t} s·φ(s)`

---

## Greedy structure and the “next layer” bound

Let `t` be the largest value with `X(t) ≤ N`. Let `R = N - X(t)` be the remaining budget
in **each** dimension.

Any additional vector must have `a+b ≥ t+1`, so for `k` additional vectors:

- total extra `(a+b)` is at least `k·(t+1)`
- but `Σ(a+b) = Σa + Σb ≤ 2R`

So:

- `k ≤ floor(2R / (t+1))`

This bound is achievable by taking:

- `floor(R/(t+1))` *swapped pairs* from the layer `s = t+1`
  (a pair `(a,b)` and `(b,a)` costs `(t+1, t+1)` and adds 2 vectors),
- plus possibly **one** extra single vector from the same layer if it fits in the leftover
  `(r, r)` budget (a small gcd search in an interval).

Finally, the answer in lattice points is:

- `F(N) = (number of step vectors) + 1`

---

## Implementation techniques

- **Linear sieve** to compute totients `φ(1..M)` in `O(M)` time.
- `M` is about `O(N^{1/3})` (for `N=10^18`, ~2.2 million), so this is fast.
- A single forward scan finds the maximal `t` with `X(t) ≤ N`.
- A short gcd search decides whether the “odd extra” vector is possible.

Time is `O(M)` and memory is `O(M)` with compact arrays.
