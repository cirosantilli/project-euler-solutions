# Project Euler 912 Solution - Where are the Odds?

<https://projecteuler.net/problem=912>:

* [912.py](912.py)

This repository contains a single-file Python solution (`main.py`) that computes
`F(10^16) mod (10^9+7)` without enumerating the sequence.

## Key ideas

### 1) Automaton DP for “no 111”
Binary strings that avoid three consecutive ones can be counted with a tiny
finite-state automaton that tracks the current run of trailing ones:

- state `cons = 0` (last bit is 0)
- state `cons = 1` (last bits end with ...1)
- state `cons = 2` (last bits end with ...11)

Appending a `1` from state `2` is forbidden.

For each suffix-length `rem` and state `cons`, the DP stores:

- `count(rem, cons)`: number of valid completions (exact integer)
- `odd_cnt(rem, cons)`: how many completions end with bit `1` (mod M)
- `odd_sum(rem, cons)`: sum of the **ranks** of those odd completions (mod M)
- `odd_sum2(rem, cons)`: sum of squared ranks (mod M)

Ranks are 1-based in lexicographic order of the remaining bits.

### 2) Lexicographic blocks = numeric order
For a fixed bit-length `L`, sorting numbers by value is the same as sorting their
`L`-bit strings lexicographically. With the MSB fixed to `1`, all valid numbers
of length `L` correspond to valid suffixes of length `rem = L-1`.

### 3) Prefix-by-rank aggregation
To handle the final (partially used) bit-length block, the code computes
aggregates for the **first `t`** valid suffixes by rank. It does this by
recursing on the next bit:

- take the whole `0`-branch if `t` exceeds its size
- otherwise recurse only into the `0`-branch

When a whole branch is taken, the odd-rank sums are shifted by the branch size.
This gives prefix values `(odd_cnt, odd_sum, odd_sum2)` in `O(L)` time.

### 4) Converting local ranks to global indices
The overall sequence `s_n` is grouped by bit-length. If a length-`L` block starts
after `offset` earlier values, then a local rank `r` becomes global index
`n = offset + r`.

For the odd subset, the contribution is expanded as:

`sum (offset + r)^2 = odd_cnt*offset^2 + 2*offset*odd_sum + odd_sum2`

All arithmetic is performed modulo `10^9+7`.

## Complexity
The maximum bit-length needed for `N = 10^16` is only about 60, so the DP table
is tiny. Runtime is `O(L)` and memory is `O(L)`.

## Running

```bash
python3 main.py
```

The script includes asserts for the example values stated in the problem.
