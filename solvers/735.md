# Project Euler 735 Solution - Divisors of $2n^2$

<https://projecteuler.net/problem=735>:

* [735.py](735.py)

The task defines

- `f(n)` = the number of divisors `d` of `2n²` with `d ≤ n`
- `F(N) = Σ_{n≤N} f(n)`

The direct approach (factor `2n²` for each `n`) is far too slow for `N = 10¹²`.

## 1) Swap the order of summation

Count pairs `(n,d)` with `n≤N`, `d≤n`, and `d | 2n²`, but sum over `d` first.

For a fixed `d`, the condition `d | 2n²` is equivalent to `n` being a multiple of a minimal value `r(d)` (derived from prime exponents), so the valid `n` are:

`n = r(d) * k` with `k ≥ d/r(d)` and `n ≤ N`.

That gives a contribution

`floor(N / r(d)) - d/r(d) + 1`.

So

`F(N) = Σ_{d≤N} ( floor(N / r(d)) - d/r(d) + 1 )`.

## 2) Parameterize `d` by a ratio `q = d / r(d)` and an odd squarefree `u`

From the exponent-splitting rules in `r(d)`, every `d` can be written as:

- `d = q² * u` (always), and additionally
- `d = (q² * u) / 2` if `q` is even,

where `u` is **odd and squarefree**.

This makes:

- `d / r(d) = q`
- `r(d) = q*u` (or `q*u/2` in the even case)

## 3) Key cancellation

When expressing `Σ floor(N/r(d))` and `Σ d/r(d)` using the `(q,u)` representation, the large term

`Σ q * #(u)`

appears in both sums and **cancels**.

After cancellation, the final formula becomes:

`F(N) = N + S0 + S1`

where

- `S0 = Σ_{q<t, q*t≤N} C(N // (q*t))`
- `S1 = Σ_{q even, q<t, q*t≤2N} C((2N) // (q*t))`

and `C(x)` is the count of **odd squarefree** integers `≤ x`.

So the remaining work is essentially counting factor-pairs weighted by a squarefree-count function.

## 4) Fast odd-squarefree counting

For large `x`, odd-squarefree counting is done with Möbius inversion:

`C(x) = Σ_{k odd} μ(k) * ( floor(x/k²) - floor(x/(2k²)) )`

Let

`A(x) = Σ_{k odd} μ(k) * floor(x/k²)`

Then `C(x) = A(x) - A(x//2)`.

`A(x)` can be computed in about `O(x^{1/3})` time by grouping ranges where `floor(x/k²)` is constant, using prefix sums of `μ(k)` over odd `k`.

For small `x`, the program precomputes `C(x)` with a sieve that marks non-squarefree numbers (multiples of `p²`) and excludes evens.

## 5) Product splitting

The double sums for `S0` and `S1` involve many calls to `C(N//(q*t))`.
To avoid calling the Möbius-based routine too often:

- Precompute `C(x)` for all `x ≤ K` (a memory/time tradeoff).
- Let `L = N//K`. If `q*t > L`, then `N//(q*t) ≤ K`, so it’s a fast table lookup.
- Only the “small product” part (`q*t ≤ L`) needs the expensive `C(x)` calls, and it’s handled with compact precomputed coefficients:
  - For `S0`, coefficients come from divisor counts for `p ≤ L`.
  - For `S1`, coefficients count even-factor pairs for `p ≤ 2N//K`.

This keeps the overall runtime practical in pure Python.

---

Implementation details are in `main.py` (no external libraries). The statement’s sample values are checked via brute force assertions for `F(15)` and `F(1000)`.
