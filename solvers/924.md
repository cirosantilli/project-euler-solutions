# Project Euler 924 Solution - Larger Digit Permutation II

<https://projecteuler.net/problem=924>:

* [924.py](924.py)

We have:

- `a_0 = 0`
- `a_n = a_{n-1}^2 + 2`
- `B(x)` = the next larger number formed by permuting decimal digits of `x`, or `0` if none exists
- `U(N) = sum_{n=1..N} B(a_n)`
- We need `U(10^16) mod (10^9+7)`.

The implementation uses only pure Python (no external libraries).

---

## 1) Separating the hard part: `B(x)` only changes a suffix

`B(x)` is computed by the standard **next permutation** algorithm on digits.
Crucially, it keeps the prefix unchanged and only modifies a suffix starting at the pivot.

So for any integer `x`:

- write `x = prefix * 10^d + suffix`
- `B(x) = prefix * 10^d + suffix'`
- therefore `B(x) - x = suffix' - suffix`

This means the correction `delta(x) = B(x) - x` depends **only** on the digits in the pivot suffix.

So:

`U(N) â‰¡ sum(a_n) + sum(delta(a_n))  (mod M)` where `M = 10^9+7`.

---

## 2) Summing `a_n mod M` by cycle detection

We only need `a_n (mod M)`:

`a_{n} = a_{n-1}^2 + 2 (mod M)`.

Since this is a deterministic map on a finite set, the sequence is eventually periodic.
For `M=10^9+7`, the cycle is *small* (tens of thousands of terms), so we can:

1. generate residues until we see a repeated value,
2. obtain preperiod length `mu` and cycle length `lambda`,
3. compute `sum_{n=1..N} a_n (mod M)` via:
   - prefix sum over the preperiod
   - full-cycle multiplication
   - remainder prefix.

This avoids iterating to `10^16`.

---

## 3) Why only the last 10 digits matter almost always

For `n >= 6`, `a_n` already has more than 10 digits.
If the last 10 digits are **not** fully non-increasing, then the rightmost ascent
(the next-permutation pivot) lies **within those last 10 digits**.

So for almost all `n >= 6`:

`delta(a_n) = next_perm(last10(a_n)) - last10(a_n)`,

and we only need `a_n (mod 10^10)` to compute it.

---

## 4) Periodicity modulo `10^10`

The sequence `a_n (mod 10^k)` is eventually periodic, and for `k=10` the cycle length is:

`step = 8 * 5^(k-2) = 3,125,000`.

We scan **one full cycle** of `a_n (mod 10^10)` starting at `a_6`,
compute the sum of `delta10` over that cycle, and then scale it up to `N` using
quotient/remainder arithmetic.

During this scan, we detect the unique position where the last 10 digits are
fully non-increasing (so the 10-digit next permutation does not exist).
Those indices are handled separately.

---

## 5) The only exceptional class uses 11 digits (and nothing deeper is needed)

Let `first_bad_n` be the first index where the last 10 digits are non-increasing.
Then the bad indices are exactly:

`n = first_bad_n + t*step`.

At those indices, the pivot is the **11th digit from the end**, so:

`delta(a_n) = next_perm(last11(a_n)) - last11(a_n)`.

Modulo `10^11`, the main cycle length is `5*step`, so sampling every `step` steps
produces a subsequence with period 5 in `t`.
We compute the 5 needed 11-digit residues once, get 5 deltas, then count how often
each occurs up to `N`.

Because any pivot deeper than 11 would require the last 11 digits to be non-increasing,
and that would imply the last 10 digits are also non-increasing, all potential deeper
cases would have to appear inside this same bad-index set. The computed 5 cases always
have an 11-digit next permutation, so the pivot never goes beyond 11.

---

## Complexity

The dominant work is:

- scanning one full `10^10` cycle: 3,125,000 iterations with 10-digit permutation work
- computing 5 special `10^11` states: about 14 million modular iterations
- cycle detection mod `10^9+7`: only ~tens of thousands of steps

All are feasible in pure Python.
