# Project Euler 382 Solution - Generating Polygons

<https://projecteuler.net/problem=382>:

* [382.py](382.py)

This repository contains a fast solver for Project Euler **Problem 382**.

The task is to compute the last 9 digits of:

- `f(n)`: the number of subsets of `U_n = {s_1, …, s_n}` that generate at least one polygon
- where `s_1=1, s_2=2, s_3=3` and `s_n = s_{n-1} + s_{n-3}` for `n>3`

A set of side lengths generates a (simple, non-self-intersecting) polygon iff the **polygon inequality** holds:
> `max(side) < sum(other sides)` (and at least 3 sides).

## 1) Count “bad” subsets instead of “good” ones

A subset `T` fails to generate a polygon if either:

- it has fewer than 3 elements, or
- it has at least 3 elements but its largest element is **at least** the sum of the others.

For a strictly increasing sequence, any non-empty subset has a unique maximum.  
Let the maximum be `s_k`. Then the subset is bad **iff** the chosen elements from `{s_1,…,s_{k-1}}` sum to **at most** `s_k`.

So the number of bad subsets is:

- `1` for the empty set, plus
- `g(k)` for each `k` where `g(k) = # { A ⊆ {s_1,…,s_{k-1}} : sum(A) ≤ s_k }`.

Then:

- `f(n) = 2^n - ( 1 + Σ_{k=1..n} g(k) )`.

Define:

- `b_i = # { A ⊆ {s_1,…,s_i} : sum(A) ≤ s_{i+1} }`.

Then `g(k) = b_{k-1}` and:

- `f(n) = 2^n - 1 - Σ_{i=0..n-1} b_i`.

So we need:
- `2^n (mod 1e9)` and
- the prefix sum of `b_i (mod 1e9)`.

## 2) A key inequality collapses the state space

Empirically (and provably by induction for this sequence), for all `m ≥ 4`:

- `s_{m+3} ≥ s_1 + s_2 + … + s_m`.

That means **every** subset of `{s_1,…,s_m}` has sum `≤ s_{m+3}`.

So any counting problem of the form:

- “#subsets of first `m` terms with sum ≤ `s_{m+3}`”

is simply `2^m`.

This kills off “large threshold offsets” and ensures that only a few nearby thresholds matter.

## 3) Deriving a recurrence for `b_i`

Using inclusion/exclusion on the largest available term and repeatedly applying the sequence identity
` s_{i+1} = s_i + s_{i-2} `,
one can show (for `i ≥ 5`):

- `b_{i+1} = 2*b_{i-2} + b_{i-3} - b_{i-5} + 5*2^{i-3} + 1`.

This is **almost** linear: it depends on a delayed power of two and a constant.

## 4) Make it linear with a small matrix, then exponentiate

We track a small fixed-size state:

- the last 6 `b` values,
- four delayed powers of two (`2^i, 2^{i-1}, 2^{i-2}, 2^{i-3}`),
- the running prefix sum `S_i = Σ_{k=0..i} b_k`,
- and a constant `1`.

This is a **linear** transformation from state `i` to state `i+1`, so we build a `12×12` matrix `M`.

Then for huge `n`:

- compute `state_{n-1} = M^(n-6) · state_5 (mod 1e9)` in `O(12^3 log n)` time,
- extract `S_{n-1}`,
- return `f(n) = 2^n - 1 - S_{n-1} (mod 1e9)`.

## 5) Complexity

- Time: `O(log n)` matrix exponentiation (tiny constant, 12×12)
- Memory: `O(1)`

The included `main.py` asserts the sample values from the problem statement (`f(5)`, `f(10)`, `f(25)`) and prints the final 9-digit answer for `n = 10^18`.
