# Project Euler 61 Solution - Cyclical Figurate Numbers

<https://projecteuler.net/problem=61>:

* [61.py](61.py)

We need a cyclic sequence of six **4-digit** polygonal numbers, using each type exactly once:
- triangle (3), square (4), pentagonal (5), hexagonal (6), heptagonal (7), octagonal (8)

Cyclic means: for each adjacent pair, the last two digits of the first equal the first two digits of the next, and the last connects back to the first.

### Key ideas
1. **Generate candidates**  
   For each type `s ∈ {3..8}`, generate all 4-digit `s`-gonal numbers using:
   \[
   P_{s,n} = \frac{n((s-2)n-(s-4))}{2}
   \]
   Keep only those in `[1000, 9999]`. Also require the last two digits to be `>= 10`, because they must serve as the next number’s first two digits (which must be 10–99 for a 4-digit number).

2. **Prefix-based lookup**  
   For each type, group its numbers by their first two digits (`prefix = num // 100`), creating a dictionary:
   `prefix -> list of numbers`.

3. **Depth-first search with constraints**  
   Build the cycle one number at a time:
   - next number must have `prefix == current_suffix` (where `suffix = num % 100`)
   - each polygonal type used at most once
   - avoid reusing the same numeric value (extra safety)
   When length reaches 6, enforce closure: last suffix must equal the first prefix.

4. **Symmetry reduction**  
   Any cycle can be rotated, so we fix the first type to octagonal (8) to avoid redundant searches.

The DFS quickly finds the unique valid cycle; summing its six numbers gives the required answer.
