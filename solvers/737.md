# Project Euler 737 Solution - Coin Loops

<https://projecteuler.net/problem=737>:

* [737.py](737.py)

This repository contains a standalone Python solution (no external libraries) for Project Euler 737.

## Model reduction

Let the vertical line intersect the table at the origin P. Every coin touches the line, so in the top view each coin center lies on the unit circle:

- coin center C_n satisfies |C_n| = 1.

A stack is considered balanced if, for every coin, the center of mass of the coins above it lies within that coin's disk. The maximal-turn configuration is achieved when each placement is tight, i.e. the center of mass of the stack above lies exactly on the rim of the supporting coin.

It's convenient to build the configuration top-down:
- Start with one coin.
- Add the next coin underneath so that the previous stack's center of mass lies on its rim.

## Harmonic-number invariant

Let G_n be the center of mass (in the plane) of n coins in this top-down construction.

A key identity emerges:

- |G_n|^2 = H_n / n, where H_n = 1 + 1/2 + ... + 1/n is the harmonic number.

So the radius of the center of mass is known in closed form, and the remaining work reduces to summing small rotation increments.

## Rotation sum formula

Define the total rotation (in radians):

- S(n) = sum_{k=2..n} theta_k

The construction yields a decomposition:

- S(n) = alpha_n + sum_{m=2..n-1} beta_m

where alpha_n and beta_m depend only on H_{m-1} (hence only on m), not on the global geometry.

This makes S(n) a 1D monotone function of n, so the required coin count for k loops is found by binary search for the smallest n with:

- S(n) > 2*pi*k.

## Fast evaluation for huge n

For n up to hundreds of millions, directly summing all beta_m is too slow.

The implementation uses:

1. Exact prefix
   - Precompute harmonic numbers and prefix sums of beta_m up to M (default M = 500,000).

2. Tail via Euler-Maclaurin
   - Approximate sum_{m=a..b} beta_m by:
     - integral_a^b beta(x) dx + (beta(a)+beta(b))/2.

3. Numerical integration in log-space
   - Compute integral beta(x) dx with the substitution x = exp(u) and apply fixed Gauss-Legendre quadrature over small chunks in u = log x.
   - The Gauss-Legendre nodes/weights are computed at runtime by Newton iteration on Legendre polynomials (no hardcoded tables).

## Correctness checks

main.py includes asserts for the test values stated in the problem statement:

- 1 loop -> 31 coins
- 2 loops -> 154 coins
- 10 loops -> 6947 coins

Running the program prints the answer for the requested number of loops (default: 2020).
