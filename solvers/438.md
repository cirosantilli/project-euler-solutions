# Project Euler 438 Solution - Integer Part of Polynomial Equation's Solutions

<https://projecteuler.net/problem=438>:

* [438.py](438.py)

We count integer coefficient tuples \((a_1,\dots,a_n)\) for the monic polynomial

\[
f(x)=x^n+a_1x^{n-1}+a_2x^{n-2}+\dots+a_n
\]

whose **real roots** \(x_1<\dots<x_n\) satisfy:

\[
\lfloor x_i \rfloor = i \quad (1\le i\le n)
\]

For each valid tuple \(t\), define:

\[
S(t)=\sum_{i=1}^{n} |a_i|
\]

The program computes \(\sum_t S(t)\) for \(n=7\), while also matching the statement’s provided check for \(n=4\).

---

## 1) Replace “one root per unit interval” with ε-sign constraints

Let \(\varepsilon>0\) be “infinitesimal”. The root-floor condition is equivalent to the alternating sign pattern:

\[
f(n+1-\varepsilon)>0,\quad
f(n-\varepsilon)<0,\quad
f(n-1-\varepsilon)>0,\ \dots
\]

Using \(x=k-\varepsilon\) avoids ambiguity when a root lies exactly at an integer.

Each inequality is **linear** in the integer coefficients \(a_i\) and has coefficients that are **polynomials in \(\varepsilon\)**.

---

## 2) Eliminate coefficients using forward differences

Define the forward difference operator:

\[
\Delta f(x)=f(x+1)-f(x)
\]

Subtracting consecutive inequalities yields inequalities for \(\Delta f\) at shifted points and *eliminates* the constant term \(a_n\).
Repeating this process eliminates \(a_{n-1}\), etc.

After applying \(\Delta\) exactly \(n-k\) times, the remaining inequalities have the form:

\[
(-1)^{k+1-m}\ \Delta^{n-k} f(m-\varepsilon) > 0,\quad m=1,\dots,k+1
\]

and depend only on \((a_1,\dots,a_k)\).
Crucially, the coefficient of \(a_k\) becomes a **nonzero constant** \((n-k)!\), so each inequality gives a direct bound on \(a_k\).

---

## 3) Interpret ε-polynomials lexicographically

Inequalities reduce to checking the sign of:

\[
c_0 + c_1\varepsilon + c_2\varepsilon^2 + \dots
\]

As \(\varepsilon\to 0^+\), the sign is determined by the **first nonzero** coefficient:
- if \(c_0\ne 0\), use \(\text{sign}(c_0)\)
- otherwise use \(\text{sign}(c_1)\), etc.

This yields exact integer bounds (no floating point).

---

## 4) Recursive enumeration over tight integer intervals

For each \(k\):
1. intersect the \(k+1\) inequalities to obtain a small integer interval \([L_k,U_k]\) for \(a_k\)
2. iterate only that interval and recurse

For the last coefficient \(a_n\), the program **does not loop** over all values; it sums \(\sum |a_n|\) over the interval directly.

---

## Included checks

The problem statement provides a check:
- For \(n=4\), there are **12** valid tuples and the required sum is **2087**.

These are asserted in `main.py`.
