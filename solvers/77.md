# Project Euler 77 Solution - Prime Summations

<https://projecteuler.net/problem=77>:

* [77.py](77.py)

We want the smallest `n` that can be written as a sum of primes in **more than 5000** different ways, where order does **not** matter (so `3+7` is the same as `7+3`).

## Key idea: Coin-change / partition DP
Treat primes as coin denominations, with unlimited usage.  
Let `ways[s]` be the number of ways to form sum `s`.

Initialize:
- `ways[0] = 1` (one way to make zero: choose nothing)

For each prime `p`, update:
- for `s = p..n`: `ways[s] += ways[s - p]`

Iterating primes in increasing order ensures we count **unordered** sums (partitions), just like the classic coin-change counting method.

## Algorithm
For `n = 2, 3, 4, ...`:
1. Generate all primes `<= n` (sieve).
2. Run the DP to compute `ways[n]`.
3. Stop at the first `n` with `ways[n] > 5000`.

This is fast because the answer is small (`71`), and the DP is only `O(n * #primes<=n)`.

## Result
The first value with more than 5000 prime-sum partitions is **71**.
