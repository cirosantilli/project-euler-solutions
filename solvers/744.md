# Project Euler 744 Solution - What? Where? When?

<https://projecteuler.net/problem=744>:

* [744.py](744.py)

This repository contains a standalone `main.py` (standard library only) that solves Project Euler 744.

## Main techniques

### 1) Random permutation viewpoint
Opening envelopes **without replacement** is equivalent to revealing a **uniformly random permutation** of the `2n+1` envelopes. The position of the single RED card is therefore uniform over `1..(2n+1)`.

### 2) Reduce the problem to an expected stopping time
Ignore the RED card and consider only the question/answer process:

- Each question is answered correctly with probability `p`.
- A correct answer gives the expert a point; an incorrect one gives the viewers a point.
- Let `Q` be the number of questions needed until either side reaches `n` points.

Because the RED card position is independent of the answer sequence,
the game ends normally iff the RED card appears **after** the first `Q` envelopes.
With `K` the RED-card position (uniform on `1..(2n+1)`):

\[
f(n,p) = P(K > Q) = E\!\left[\frac{2n+1-Q}{2n+1}\right] = 1 - \frac{E[Q]}{2n+1}.
\]

So the task becomes computing (or tightly approximating) `E[Q]`.

### 3) Exact `E[Q]` for moderate `n` via terminal distributions
At game end, one side has `n` points and the other has `k` points for some `k = 0..n-1`,
so `Q = n + k`.

The probability that the viewers win with exactly `k` expert points is a negative-binomial form:

- Choose the locations of the `k` successes among the first `n+k-1` trials, then the last trial is a failure.
- This gives a term with a binomial coefficient and powers of `p` and `1-p`.

A symmetric term handles the expert winning. Summing `(n+k) * P(k)` over `k=0..n-1` yields `E[Q]`.

To avoid overflow/underflow, `main.py` evaluates the sum in **log-space**:
- Binomial coefficients are computed using `lgamma`.
- A log-sum-exp shift keeps exponentials numerically stable.

This exact method is `O(n)` and comfortably handles the statementâ€™s test case with `n = 10^4`.

### 4) Fast approximation for huge `n` with noticeable bias
When `n` is enormous and `p` is not extremely close to `1/2`, the more likely side almost surely reaches `n` first.
Then `Q` is essentially the waiting time to get `n` points for that side, i.e. a negative binomial mean:

\[
E[Q] \approx \frac{n}{\max(p,1-p)}.
\]

The final instance in the script uses high-precision `Decimal` arithmetic to ensure correct rounding to 10 decimals.

## Running
```bash
python3 main.py
