# Project Euler 350 Solution - Constraining the Least Greatest and the Greatest Least

<https://projecteuler.net/problem=350>:

* [350.py](350.py)

This repository contains a fast solution to Project Euler Problem 350:

> Compute  
> `f(10^6, 10^12, 10^18) mod 101^4`  
> where `f(G,L,N)` counts length-`N` lists of natural numbers with  
> `gcd(list) ≥ G` and `lcm(list) ≤ L`.

## Main ideas

### 1) Split by the exact gcd

Let `d = gcd(a1..aN)`. Then we can write:

- `ai = d * bi`
- `gcd(b1..bN) = 1`
- `lcm(a1..aN) = d * lcm(b1..bN)`

So the constraint `lcm(a) ≤ L` becomes `lcm(b) ≤ floor(L/d)`.

Therefore:

`f(G,L,N) = Σ_{d=G..L} g(floor(L/d), N)`

where `g(M,N)` is the number of `N`-tuples with `gcd = 1` and `lcm ≤ M`.

### 2) Count tuples with a fixed lcm using prime exponents

For a fixed `m`, if `lcm(b) = m`, then every `bi` is a divisor of `m`.
Write `m = ∏ p^e`. The exponent choices for different primes are independent.

For one prime power `p^e`, each `bi` has an exponent in `{0..e}`.
We need **both**:

- `min exponent = 0` (to make overall gcd = 1)
- `max exponent = e` (to make overall lcm include `p^e`)

By inclusion–exclusion, the number of exponent `N`-tuples satisfying both is:

`a_e = (e+1)^N - 2·e^N + (e-1)^N`

Thus the number of `N`-tuples with `gcd=1` and `lcm=m` is the multiplicative function:

`c(m) = ∏_{p^e || m} a_e`

Then:

`g(M,N) = Σ_{m ≤ M} c(m)`

### 3) Compute `c(m)` for all `m ≤ 10^6` with a sieve

For the target parameters, `M` never exceeds `L/G = 10^6`.
We compute smallest prime factors up to `10^6` (linear sieve), then build `c(m)` for all `m`
using a recurrence that strips off the highest power of the smallest prime.

A prefix sum array gives all `g(M,N)` in O(1).

### 4) Sum over `d` with floor-division bucketing

The term `floor(L/d)` takes only `O(√L)` distinct values.
We iterate ranges `[d..r]` where the quotient is constant and accumulate:

`(r-d+1) · g(floor(L/d),N)`

All arithmetic is done modulo `101^4`.

## Complexity

- Sieve and building `c(m)` up to `10^6`: ~O(10^6)
- Summation over `d` grouped by quotient: ~O(2·√L) ≈ 2·10^6 for `L=10^12`

Memory is kept low by storing large arrays using Python’s `array`/`bytearray` types.
