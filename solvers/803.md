# Project Euler 803 Solution - Pseudorandom Sequence

<https://projecteuler.net/problem=803>:

* [803.py](803.py)

This solution is **pure Python** (no external libraries) and avoids brute-forcing the full `2^48` state space by exploiting structure in the RAND48 generator and the way characters are produced.

Problem statement (for reference) defines:

- `a_n = (A*a_{n-1} + C) mod 2^48`, with `A = 25214903917`, `C = 11`
- `b_n = floor(a_n / 2^16) mod 52`
- `b_n` maps to letters `a..zA..Z`

We are given that the infinite string `c` starts with `"PuzzleOne..."` and we want the first index where `"LuckyText"` occurs.

---

## 1) Key algebra: split the 48-bit state into two 24-bit halves

Write each 48-bit state as:

- `a = x + 2^24 * y` with `0 <= x,y < 2^24`

Then:

- `floor(a / 2^16) = (x >> 16) + 256*y`
- so
  - `b ≡ (x >> 16) + 48*y (mod 52)` because `256 ≡ 48 (mod 52)`

This means each emitted character constrains `(x >> 16)` and `y` modulo small values.

---

## 2) Split `x` again into 18+6 bits to get a tiny brute force

Split the lower half:

- `x = u + 2^18*w` with `0 <= u < 2^18` and `0 <= w < 64`

Then:

- `(x >> 16) = (u >> 16) + 4*w`

### Mod-4 pruning

Because `48*y` is divisible by 4, the character equation implies:

- `b mod 4 == (x >> 16) mod 4 == (u >> 16)`

So for a given prefix, we brute-force only `u0` in `[0,2^18)` and keep those where `(u_n >> 16)` matches the required `b_n mod 4` for every character.

That’s `2^18 = 262144` candidates, and the filter is so strong that typically only **one** survives.

---

## 3) Each character fixes `y_n mod 13`

From:

- `48*y_n + t_n ≡ v_n (mod 52)` with `t_n = (x_n >> 16)` and `v_n` the letter index,

reduce mod 13:

- `9*y_n + t_n ≡ v_n (mod 13)`

Since `9^{-1} ≡ 3 (mod 13)`, this gives:

- `y_n ≡ 3*(v_n - t_n) (mod 13)`

So once `u0` and `w0` are fixed (hence `t_n` is known), the whole prefix determines the required residues `y_n mod 13`.

---

## 4) Solve for the 24-bit `y0` by scanning one arithmetic progression

The update for `y` is:

- `y_{n+1} = (A*y_n + carry_n) mod 2^24`

where `carry_n = floor((A*x_n + C) / 2^24)` depends only on `x_n`.

For fixed `u0,w0`, the carries are known constants, so we scan:

- `y0 = r0 + 13*k`

because `y0 mod 13` is fixed by the first character.

A cheap precheck on `y1 mod 13` and `y2 mod 13` removes almost all candidates; survivors are fully verified.

This yields all 48-bit seeds whose output starts with the chosen pattern.

---

## 5) Turning “first occurrence” into a state-index problem

A substring `"LuckyText"` begins at position `n` iff the generator state `a_n` produces that prefix.

So:

1. Reconstruct the unique start seed for `"PuzzleOne"`.
2. Find all seeds (states) that produce the prefix `"LuckyText"`.
3. For each such state, compute its index `n` in the `"PuzzleOne"` sequence.
4. Take the minimum `n`.

---

## 6) Fast index lookup using a 2-adic discrete logarithm

We use a standard conjugacy trick.

Let:

- `K = a1 - a0` (this is always odd, hence invertible mod `2^48`)
- Define `Y_0=0`, `Y_{n+1} = A*Y_n + 1 (mod 2^48)`

Then:

- `a_n = a0 + K*Y_n (mod 2^48)`
- and also:
  - `A^n ≡ (A-1)*Y_n + 1 (mod 2^48)`

So to find `n` for a target state:
- compute `Y_n = (a_n - a0) * K^{-1} (mod 2^48)`
- compute `h = (A-1)*Y_n + 1 (mod 2^48)` which equals `A^n`
- solve the discrete log `A^n = h` inside the subgroup `≡ 1 (mod 4)`, whose order is `2^46`

Because the group order is a pure power of two, `n (mod 2^46)` can be recovered **bit-by-bit**.
There are only four possible lifts to the full modulus, and we test them.

---

## Included statement assertions

The code asserts all test values from the problem statement:

- With `a0 = 123456`, the prefix is `"bQYicNGCY"`.
- The first occurrence of `"RxqLBfWzv"` is at index `100`.
- If the string starts with `"EULERcats"`, then `a0 = 78580612777175`.

The final Project Euler answer is **not hard-coded** and is **only printed**.
