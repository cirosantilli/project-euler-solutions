# Project Euler 423 Solution - Consecutive Die Throws

<https://projecteuler.net/problem=423>:

* [423.py](423.py)

## Key reformulation

Let a sequence of `n` die throws be `x1, x2, ..., xn`.

Define `c` as the number of *equal* adjacent pairs:

- `c = |{ i : 1 ≤ i ≤ n-1 and xi = x{i+1} }|`

A sequence can be viewed as **runs** of equal values. If a sequence has `r` runs, then:

- each run boundary is a *change*, so `changes = r - 1`
- there are `n-1` adjacencies total, so `c = (n-1) - changes = n - r`

So **bounding `c` bounds the number of runs**:

- `c ≤ π(n)`  ⇔  `r ≥ n - π(n)`

The number of sequences with exactly `c` matches is:

- choose which `c` of the `n-1` adjacencies are matches ⇒ `binom(n-1, c)`
- choose values: first throw has 6 choices, each *change* has 5 choices
- there are `(n-1-c)` changes

\[
f(n,c)= 6 \cdot 5^{\,n-1-c}\cdot \binom{n-1}{c}
\]

Therefore:

\[
C(n)=\sum_{c=0}^{\pi(n)} f(n,c)
\]

We need:

\[
S(L)=\sum_{n=1}^{L} C(n) \pmod{1\,000\,000\,007}
\]

with `L = 50,000,000`.

---

## O(1) update per `n` using a boundary term

Let:

- `k = π(n)`
- `b(n) = f(n, k)` (the number of sequences with exactly `k` matches)

When moving from `n` to `n+1`, the prime-count `k` either stays the same or increases by 1
(only when `n+1` is prime).

Using the recurrence induced by appending one throw:

- if the last two throws differ: 5 choices (match-count unchanged)
- if they are equal: 1 choice (match-count +1)

this yields a clean update on the **partial sum** `C(n)`:

- If `π(n+1) = π(n)` (no new prime):
  \[
  C(n+1) = 6C(n) - b(n)
  \]
- If `π(n+1) = π(n)+1` (a new prime appears at `n+1`):
  \[
  C(n+1) = 6C(n) + 5\cdot f(n, k+1)
  \]

The “extra” term `f(n, k+1)` can be computed from `b(n)` with one binomial ratio:

\[
f(n,k+1)= \frac{b(n)}{5}\cdot \frac{(n-\pi(n))-1}{k+1}
\]

All arithmetic is done modulo `MOD = 1,000,000,007`, so divisions use modular inverses.

We also update the boundary term for the next step:

- no-new-prime: `b(n+1) = b(n) * 5 * n / (n - k)`
- new-prime: `b(n+1) = b(n) + 5*f(n,k+1)`

---

## Prime counting and speed tricks

- `π(n)` changes only at primes, so we precompute primality up to `L` with an **odd-only sieve**.
- Since every even number > 2 is composite, we process **two steps at once**:
  `even n → odd n+1 → even n+2`, requiring only one prime check per two `n`s.
- All required modular inverses up to the maximum denominator are precomputed in linear time using:
  \[
  inv[i] = MOD - \left\lfloor \frac{MOD}{i} \right\rfloor \cdot inv[MOD \bmod i] \pmod{MOD}
  \]

This yields an overall time complexity essentially linear in `L`, with modest memory usage
(bytearray sieve + 32-bit inverse table).

---

## Files

- `main.py`: full solution + asserts for the sample values in the problem statement
- This `README.md`: explanation of the main techniques
