# Project Euler 546 Solution - The Floor's Revenge

<https://projecteuler.net/problem=546>:

* [546.py](546.py)

We need to evaluate

\[
f_k(n) = \sum_{i=0}^{n} f_k\!\left(\left\lfloor\frac{i}{k}\right\rfloor\right),\quad f_k(0)=1
\]

and compute

\[
\left(\sum_{k=2}^{10} f_k(10^{14})\right)\bmod(10^9+7).
\]

The implementation is in `main.py` (pure Python, no external libraries).


## Key techniques used

### 1) Turn the definition into a cheap recurrence

From the definition,

\[
f_k(n) - f_k(n-1) = f_k\!\left(\left\lfloor \frac{n}{k}\right\rfloor\right),
\]

so for `n >= 1`:

\[
f(n)=f(n-1)+f(\lfloor n/k\rfloor).
\]

This removes the explicit summation over `i = 0..n`.


### 2) Use iterated prefix sums to “linearize” the floor recursion

Define a family of sequences:

- \(A_0(n)=f(n)\)
- \(A_j(n)=\sum_{i=0}^{n} A_{j-1}(i)\) for \(j\ge 1\)

So \(A_1\) is the prefix sum of \(f\), \(A_2\) is the prefix sum of \(A_1\), etc.

A crucial (and provable by summing complete `k`-blocks) fact is:

> For each `j` and each remainder `r` (0 ≤ r < k), there exist constants  
> \(c_{j,r,p}\) such that for all `n`:
>
> \[
> A_j(k n + r) = \sum_{p=0}^{j+1} c_{j,r,p}\, A_p(n)\pmod{M}.
> \]

So **every** \(A_j\) at a larger index `k*n+r` is a fixed linear combination of
\((A_0, A_1, ..., A_{j+1})\) at the smaller index `n`.


### 3) Compute those coefficients by dynamic programming (no algebra system)

For `j=0` you can rewrite directly:

\[
A_0(kn+r)=kA_1(n) + (r+1-k)A_0(n).
\]

Assuming we already have the coefficient lists for level `j-1`, we obtain the
coefficients for level `j` by:

- summing over a full block (`u = 0..k-1`)
- plus a partial block (`u = 0..r`)
- and using \(A_{p+1}(n-1)=A_{p+1}(n)-A_p(n)\)

This yields a clean recurrence that builds all \(c_{j,r,p}\) up to the needed depth
using only additions/subtractions modulo \(10^9+7\).


### 4) Evaluate \(f_k(10^{14})\) by repeatedly dividing by `k`

To compute \(f_k(N)\), build the chain:

\[
N,\ \left\lfloor N/k\right\rfloor,\ \left\lfloor N/k^2\right\rfloor,\ \dots
\]

until the value is `< k`. At the bottom, \(f(n)=n+1\) for all `n < k`, so

\[
A_j(n)=\binom{n+j+1}{j+1}.
\]

Then “lift” back up the chain using the precomputed coefficients.

For `k <= 10`, the chain length is at most about `log_k(10^14)` (≈ 47 when k=2), so
the whole computation is very fast.


## Complexity

For each `k`, the chain length is \(d = O(\log_k N)\).  
At depth `i` we update `i+1` values with short dot-products, giving about
\(\sum_{i=1}^{d} O(i^2) = O(d^3)\) scalar operations.

With \(d \le 47\) and `k` from 2 to 10, this easily runs in under a second in Python.


## Notes

The code includes the exact test values from the problem statement:

- \(f_5(10)=18\)
- \(f_7(100)=1003\)
- \(f_2(10^3)=264830889564\)
