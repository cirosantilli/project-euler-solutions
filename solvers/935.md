# Project Euler 935 Solution - Rolling Square

<https://projecteuler.net/problem=935>:

* [935.py](935.py)

This solver uses only the Python standard library and computes **F(10^8)** fast enough in pure Python.

## Geometry → a 1D dynamical system

Rescale so the **small** square has side length `1`.  
Then the **big** square has side length:

- `L = 1 / b = h + x`, with integer `h ≥ 1` and `x ∈ [0, 1)`.

When the square “rolls” around a corner, the next edge loses a length computed by the Pythagorean theorem, giving the map

- `H(x) = frac( x - sqrt(1 - x^2) )`, where `frac` is the fractional part.

Iterating this map tracks the “leftover” length on successive edges.

## Step counting collapses to coprime counting

The returning configurations split into two families:

### 1) Integer `L = h` (i.e. `x = 0`)
These return after `4 * (h - 1)` rolls.  
So they contribute exactly `⌊N/4⌋` valid values of `b = 1/h` (with `h ≥ 2`).

### 2) Non-integer `L = h + x_{u,v}`
For each reduced fraction `v/u` (with `gcd(u,v)=1`, `1 ≤ v < u`), there is a unique `x_{u,v} ∈ (0,1)` that produces a return.  
The number of rolls is:

- `scale(u) * (h*u + v - 1)`

with the scale depending only on `u (mod 4)`:

- `scale(u) = 1` if `u ≡ 0 (mod 4)`
- `scale(u) = 2` if `u ≡ 2 (mod 4)`
- `scale(u) = 4` if `u` is odd

Let `t = h*u + v`. Then `gcd(u,t)=gcd(u,v)=1` and the condition becomes a **simple bound on `t`**:

- `u < t ≤ ⌊N/scale(u)⌋ + 1`

So counting valid `b` reduces to counting coprime pairs `(u,t)` in 3 residue classes of `u`.

## Fast coprime counting with Möbius inversion

For any fixed `X`, the number of `t ≤ X` coprime to `u` is:

- `C(X,u) = Σ_{d|u} μ(d) * ⌊X/d⌋`

Summing `C(X,u)` over many `u` can be rearranged into sums of the form:

- `Σ_{d≤X} μ(d) * f(⌊X/d⌋)`

These are evaluated with the **Dirichlet hyperbola method** by grouping ranges where `⌊X/d⌋` is constant.

## Du Jiao sieve for the Mertens function

The hyperbola method needs fast access to prefix sums of the Möbius function:

- `M(n) = Σ_{k≤n} μ(k)`  (Mertens function)

The solver uses a **Du Jiao sieve**:

1. Precompute `μ(k)` (and prefix sums) up to `n^(2/3)` with a linear sieve.
2. Compute `M(n)` for large `n` by the classic recursion over distinct values of `⌊n/i⌋`, memoized.

Because `μ(4m)=0`, only odd `d` and `d ≡ 2 (mod 4)` matter, so we also maintain an “odd Mertens” prefix sum and use simple parity transforms.

## Complexity

- Time: about `O(n^(2/3))` for the prefix-sum machinery + `O(√n)` for each final summation.
- Memory: `O(n^(2/3))` for the small sieve arrays and memo tables.

The code includes asserts for the example values from the problem statement (`F(6)` and `F(100)`), and prints the computed value for `F(10^8)`.
