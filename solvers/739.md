# Project Euler 739 Solution - Summation of Summations

<https://projecteuler.net/problem=739>:

* [739.py](739.py)

This solution turns the “repeated summation over a triangle” into coefficient extraction from a generating function, then evaluates a derived recurrence modulo **1,000,000,007** without using external libraries.

## 1) From the triangle to a generating function

If you build the triangle

- row 1 is the input sequence,
- each next row is the prefix sums of the row above,
- and `f(n)` is the last entry in row `n`,

then `f(n)` is a linear functional of the initial sequence. Using ordinary generating functions, the whole process can be encoded as an algebraic generating function `F(x)` such that:

- `f(n) = [x^(n-1)] F(x)`.

For the Lucas start sequence in this problem, the derivation yields a closed algebraic form involving `sqrt(1-4x)`.

## 2) Convert the algebraic GF into a coefficient recurrence

An algebraic generating function is *D-finite*, hence its coefficients satisfy a linear recurrence with polynomial (here: linear) coefficients.

For this problem the coefficients `a_m = [x^m] F(x)` satisfy a 4th-order recurrence of the form

```
(4k+2)a_k + (23k+26)a_{k+1} + (22k+62)a_{k+2} - (15k+50)a_{k+3} + (2k+8)a_{k+4} = 0
```

with initial values `a_0..a_3 = 1, 3, 7, 21`.

Then `f(n) = a_{n-1}`.

## 3) Fast modular division via block inverses

Direct iteration needs division by `(2k+8)` at every step. Doing a modular exponentiation for each inverse would be far too slow.

Key observations:

- `(2k+8) = 2*(k+4)`, so we only need inverses of consecutive integers `k+4`, multiplied by `inv(2)`.
- We need inverses of **consecutive** integers `k+4`.

To compute inverses of a block of consecutive integers `s, s+1, ..., s+L-1` efficiently:

1. Compute prefix products `P[i] = ∏_{j< i} (s+j)`.
2. Compute `inv(P[L])` once using `pow(P[L], MOD-2, MOD)`.
3. Recover each `inv(s+i)` in reverse using the standard prefix/suffix trick.

This replaces `L` expensive inversions with **one**.

The implementation processes the recurrence in large blocks, precomputing `inv(k+4)` for each block, and then doing the recurrence update with only modular multiplications/additions in the inner loop.

## 4) Correctness checks

The code includes `assert`s for the test values given in the problem statement (`f(8)` and `f(20)`), and then prints `f(10^8) mod 1,000,000,007`.
