# Project Euler 940 Solution - Two-Dimensional Recurrence

<https://projecteuler.net/problem=940>:

* [940.py](940.py)

This solution computes
\(S(50) \bmod 1123581313\), where

\[
S(k)=\sum_{i=2}^{k}\sum_{j=2}^{k} A(f_i,f_j)
\]

and \((f_i)\) are Fibonacci numbers.

## Key techniques

### 1) Turn the 2D recurrence into 2×2 matrix transforms
The rules

- \(A(m+1,n)=A(m,n+1)+A(m,n)\)
- \(A(m+1,n+1)=2A(m+1,n)+A(m,n)\)

imply *linear* updates if you group nearby values into a 2-vector.

**Advance in `m` (fixed `n`):**
Let \(x=A(m,n)\), \(y=A(m,n+1)\). Then

- \(A(m+1,n)=x+y\)
- \(A(m+1,n+1)=2(x+y)+x=3x+2y\)

so
\[
\begin{bmatrix}A(m+1,n)\\A(m+1,n+1)\end{bmatrix}
=
\begin{bmatrix}1&1\\3&2\end{bmatrix}
\begin{bmatrix}A(m,n)\\A(m,n+1)\end{bmatrix}.
\]

**Advance in `n` (fixed `m`):**
Use \(A(m,n+1)=A(m+1,n)-A(m,n)\) (rearranging the first rule) and
\(A(m+1,n+1)=2A(m+1,n)+A(m,n)\) (the second rule), giving
\[
\begin{bmatrix}A(m,n+1)\\A(m+1,n+1)\end{bmatrix}
=
\begin{bmatrix}-1&1\\1&2\end{bmatrix}
\begin{bmatrix}A(m,n)\\A(m+1,n)\end{bmatrix}.
\]

### 2) Fast exponentiation (binary exponentiation)
Both updates are 2×2 matrix powers:

- \(M^m\) moves from \((A(0,n),A(0,n+1))\) to \((A(m,n),A(m,n+1))\)
- \(N^n\) moves from \((A(m,0),A(m+1,0))\) to \((A(m,n),A(m+1,n))\)

With binary exponentiation, each power costs \(O(\log m)\) or \(O(\log n)\).

### 3) Work only at Fibonacci coordinates
The sum needs \(A(f_i,f_j)\) for \(2\le i,j\le k\). For \(k=50\) there are only
49 distinct Fibonacci values, so we cache \(M^{f_i}\) and \(N^{f_i}\) once each,
then reuse them for all 2401 pair evaluations.

### 4) Compute everything modulo the required modulus
Because all recurrences are linear with integer coefficients, reducing modulo
\(1123581313\) is valid at every step.

## Correctness checks
The program asserts the example values from the problem statement:

- \(S(3)=30\)
- \(S(5)=10396\)

Then it prints \(S(50) \bmod 1123581313\).
