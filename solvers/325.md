# Project Euler 325 Solution - Stone Game II

<https://projecteuler.net/problem=325>:

* [325.py](325.py)

This solution turns the game into a number‑theory / summation problem and evaluates it in **O(log N)** time.

## 1) Game theory: Euclid’s algorithm game

Each move replaces `(a, b)` (with `0 < a ≤ b`) by `(a, b − k·a)` for some integer `k ≥ 1`, then reorders the pair.
This is the classic **Euclid game**.

A known characterization for this game is:

*A position `(a, b)` with `0 < a < b` is losing for the player to move iff `b/a < φ`, where `φ = (1+√5)/2` (the golden ratio).*  
Equivalently, `(a, b)` is losing iff `b ≤ ⌊φ·a⌋`.

So for a fixed `x`, the losing `y` are the consecutive integers

```
y = x+1, x+2, …, min(N, ⌊φx⌋).
```

## 2) Summation split

Let `d = ⌊N/φ⌋`. Then:

* for `x ≤ d`, we have `⌊φx⌋ < N`;
* for `x ≥ d+1`, we have `⌊φx⌋ ≥ N`, so the losing `y` extend all the way to `N`.

This splits the required sum `S(N)` into:

*a “Beatty” part* (`x ≤ d`) and *a pure polynomial part* (`x > d`).

For `x ≤ d`, use the identity `⌊φx⌋ = x + ⌊x/φ⌋` and set `t = ⌊x/φ⌋`. Then

```
Σ_{y=x+1..x+t} (x+y) = 2·x·t + t(t+1)/2.
```

So we only need prefix sums of `t`, `t²`, and `x·t` for `t = ⌊x/φ⌋`.

For `x > d`, the contribution has a closed form:

```
part2 = (N − d − 1) · (N(N+1) − d(d+1)) / 2.
```

## 3) Beatty sequences and logarithmic recurrences

Define the Beatty sequence

* `a_n = ⌊nφ⌋`

and its “complement”

* `b_n = ⌊nφ²⌋ = a_n + n`.

Beatty’s theorem says `{a_n}` and `{b_n}` partition the positive integers.
From this, we get fast recurrences for the prefix sums:

* `A(n) = Σ a_k`
* `B(n) = Σ a_k²`

with the shrink parameter `c = ⌊n/φ⌋`:

* `A(n) = T(⌊nφ⌋) − A(c) − T(c)`
* `B(n) = S₂(⌊nφ⌋) − B(c) − 2·H(c) − S₂(c)`

where `T(n)=n(n+1)/2` and `S₂(n)=n(n+1)(2n+1)/6`.

The mixed sum `H(n) = Σ k·a_k` is computed via a lattice‑point reciprocity for `q = 1/φ`:

```
H(n) = Σ k² + c·T(n) − (B(c)+A(c))/2,  with c = ⌊n/φ⌋.
```

Because `c ≈ 0.618·n`, all recurrences finish in `O(log n)` steps.

## 4) Exact floors without floating point

To avoid precision issues for `N = 10^16`, floors are computed with integer square roots:

* `⌊nφ⌋ = (n + ⌊n√5⌋) // 2`
* `⌊n/φ⌋ = (⌊n√5⌋ − n) // 2`

with `⌊n√5⌋ = isqrt(5n²)`.

## 5) Modular arithmetic

The final answer is requested modulo `7¹⁰` (an odd modulus), so divisions by `2` and `6` are performed via modular inverses.

---

The code in `main.py` includes the problem’s check values:

* `S(10) = 211`
* `S(10^4) = 230312207313`

and prints `S(10^16) mod 7^10`.
