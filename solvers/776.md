# Project Euler 776 Solution - Digit Sum Division

<https://projecteuler.net/problem=776>:

* [776.py](776.py)

Compute

\[
F(N)=\sum_{n=1}^{N}\frac{n}{d(n)}
\]

where \(d(n)\) is the sum of the decimal digits of \(n\), for a very large \(N\).

## Key ideas used

### 1) Group by digit sum
Instead of summing \(\frac{n}{d(n)}\) directly, group terms by digit sum \(s\):

\[
F(N)=\sum_{s\ge 1}\frac{1}{s}\sum_{\substack{1\le n\le N\\ d(n)=s}} n
\]

So the hard part becomes computing, for each \(s\), the total **sum of numbers** \(\sum n\) whose digit sum is \(s\).

### 2) Digit DP (dynamic programming on digits)
A classic “digit DP” over the decimal representation of \(N\) counts and aggregates all numbers \(\le N\) without iterating them.

The DP tracks:
- position in the digit string,
- current digit-sum \(s\),
- whether the prefix is **tight** (equal to \(N\) so far) or already **loose** (smaller than \(N\)).

For each state, we maintain two aggregates:
- `count`: how many prefixes produce this state,
- `sum`: the sum of the numeric values of those prefixes.

When appending a digit `d`:
- every previous value `v` becomes `v*10 + d`,
- so `sum` updates as `sum*10 + count*d`.

At the end, we obtain an array `S[s] = sum of all numbers ≤ N with digit sum s`.

### 3) High-precision decimal summation
The final result is

\[
\sum_{s\ge 1} \frac{S[s]}{s}
\]

There are only up to \(9 \cdot \text{digits}(N)\) digit sums (here at most 171), so we sum these terms using `decimal.Decimal` with a high precision context to safely round the final output to 12 digits after the decimal point in scientific notation.

## Files
- `main.py` — implementation + asserts for the statement’s sample values.
- `README.md` — this summary.
