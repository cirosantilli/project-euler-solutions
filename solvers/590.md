# Project Euler 590 Solution - Sets with a Given Least Common Multiple

<https://projecteuler.net/problem=590>:

* [590.py](590.py)

We need:

- `H(n)`: the number of **sets** of positive integers whose least common multiple (LCM) is exactly `n`.
- `L(N) = lcm(1,2,...,N)`.
- `HL(N) = H(L(N))`.

The goal is `HL(50000) (mod 10^9)`.

---

## 1) Inclusion–exclusion for `H(n)`

If a set has LCM `n`, then every element must divide `n`. So `H(n)` equals the number of non-empty subsets of the divisor set `D(n)` whose LCM is exactly `n`.

Write `n = ∏ p^{a_p}`. For each prime `p | n`, define the bad event
`E_p`: none of the chosen divisors is divisible by `p^{a_p}`.

If `E_p` happens, every chosen divisor has exponent of `p` at most `a_p-1`, i.e. it divides `n/p`.
For any subset `A` of the prime factors, enforcing all `E_p` for `p ∈ A` means all chosen divisors divide
`n / ∏_{p∈A} p`.

There are `2^{d(m)}` subsets of the divisor set of `m` (including the empty set), where `d(m)` is the divisor-count function.
Using inclusion–exclusion over the primes of `n` gives (for `n>1`):

`H(n) = Σ_{A⊆P(n)} (-1)^{|A|} · 2^{ d( n / ∏_{p∈A} p ) }`.

The special case `H(1)=1` corresponds to the single set `{1}`.

## 2) Using the structure of `L(50000)`

For `L(N)`, each prime `p ≤ N` appears to the exponent `a_p = max{a : p^a ≤ N}`.
For `N = 50000`, almost all primes have exponent `1` (all primes `p > √N`).

Split:

- `L(50000) = m · P`,
- where `P` is the product of the `r` primes with exponent `1`,
- and `m` contains the remaining primes (only those `p ≤ √N`, so there are few of them).

---

## 3) Collapsing the exponent-1 primes into a single function `F_r(x)`

Apply the inclusion–exclusion formula to `n = m·P`.
Fix a squarefree divisor `q | m` (this chooses which primes of `m` are “removed” in inclusion–exclusion).
Let:

- `x = d(m/q)`.

Now handle the `r` exponent-1 primes of `P`:
choosing a subset `A ⊆ primes(P)` to remove replaces each missing prime factor `2` in the divisor count, so

- `d( (m·P) / (q·∏_{p∈A} p) ) = d(m/q) · 2^{r-|A|} = x · 2^{r-|A|}`.

So the contribution of the exponent-1 primes becomes the same function for every `q`:

`F_r(x) = Σ_{A⊆P} (-1)^{|A|} · 2^{ x · 2^{r-|A|} }`

Reindexing by `k = r-|A|` gives:

`F_r(x) = Σ_{k=0..r} (-1)^{r-k} · C(r,k) · 2^{ x · 2^k }`.

### Fast evaluation of `F_r(x)`

Modulo `5^9`, `2` is coprime to the modulus, so exponents can be reduced modulo `φ(5^9) = 4·5^8`.
To evaluate `2^{x·2^k}` efficiently:

- compute `p0 = 2^x (mod 5^9)`
- then repeatedly square: `p_{k+1} = p_k^2 (mod 5^9)` gives `p_k = 2^{x·2^k}`.

---

## 4) Summing over squarefree `q | m` without enumerating `2^{48}` cases

The number of primes in `m` is small, but `2^{(#primes in m)}` is still too big.
Instead, primes in `m` are grouped by their exponent `a` in `L(50000)`.
For a prime with exponent `a ≥ 2`:

- if it is included in `q`, the divisor-count factor becomes `a` (because the exponent is reduced by 1)
- otherwise it contributes `a+1`.

If there are `c_a` primes with exponent `a`, choosing `t` of them into `q` contributes:

- a multiplicity factor `C(c_a, t)`
- a sign `(-1)^t`
- and a divisor-count multiplier `a^t · (a+1)^{c_a-t}`.

A small dynamic program over these exponent groups builds a map:

- key: `x = d(m/q) (mod φ(5^9))`
- value: total weight `Σ μ(q)·multiplicity(q) (mod 5^9)` for all `q` producing that `x`.

Then the final sum is `Σ weight[x] · F_r(x)`.

---

## 5) Modulo `10^9` via prime-power splitting and CRT

`10^9 = 2^9 · 5^9`.

- Mod `2^9 = 512`: for `L(50000)` every exponent in every term `2^E` is at least `9`, so every term is `0 (mod 512)` and therefore the total is `0 (mod 512)`.
- Mod `5^9`: compute the full value using the method above.

Finally combine the two residues using the Chinese Remainder Theorem.
Because the answer is `0 (mod 512)`, it has the form `512·t`, and we solve:

`512·t ≡ answer (mod 5^9)`.

---

### Complexity

Let `r` be the number of exponent-1 primes (here `r = 5085`).
The number of distinct `x` values from the grouped DP is only about ten thousand, and each `F_r(x)` evaluation is `O(r)` using repeated squaring.
This is fast enough in plain Python.
