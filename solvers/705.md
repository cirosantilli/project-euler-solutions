# Project Euler 705 Solution - Total Inversion Count of Divided Sequences

<https://projecteuler.net/problem=705>:

* [705.py](705.py)

This solution computes

- `G(N)`: the concatenation of all primes `< N` in increasing order, with every `0` digit removed
- `F(N)`: the sum of inversion counts over **all** “divided sequences” obtained by replacing each digit by one of its divisors

All results are taken modulo `1_000_000_007`.

## Key ideas

### 1) Linearity of expectation for inversion counts
For any digit sequence `x[0..L-1]`, the inversion count is:

\[
\text{inv}(x) = \sum_{0 \le i < j < L} [x_i > x_j]
\]

When each position chooses uniformly among the divisors of its master digit, all divided sequences are equally likely. Therefore:

\[
F(N) = M \cdot \mathbb{E}[\text{inv}(x)]
\]

where `M` is the total number of divided sequences (a product of “number of divisors” per position).

So we only need:

1) the expected inversion count, and  
2) the total number of divided sequences, both modulo `MOD`.

### 2) Streaming expected inversions with cumulative distributions
Let `P_j(v)` be the probability that position `j` becomes digit value `v` (uniform over divisors).

Maintain cumulative probabilities over the prefix:

- `A[v] = sum_{i<j} P_i(v)` for `v = 1..9`

When processing a new position `j`, its expected new inversions with the prefix are:

\[
\sum_v P_j(v) \cdot \sum_{u>v} A[u]
\]

Because digit values are only `1..9` and each divisor set has size at most 4, this can be updated very quickly in a single left-to-right pass.

### 3) Separating `M` using digit counts
The number of choices at a position depends only on the **master digit** `d` via `W[d] = number_of_divisors(d)`.

So if `count[d]` is how often digit `d` appears in `G(N)` (after removing zeros), then:

\[
M = \prod_{d=1}^{9} W[d]^{\text{count}[d]} \pmod{MOD}
\]

This avoids multiplying `M` once per digit.

### 4) Fast prime generation
`G(10^8)` is long, so primes are generated with a **segmented odd-only sieve**:

- sieve only odd numbers in each segment
- mark composites with slicing (`bytearray[start::step] = ...`) for speed
- stream primes without storing them all

### 5) Avoiding per-prime string conversions
Converting millions of primes to strings is expensive. Instead, each prime is split into base-10000 chunks:

- precompute the non-zero decimal digits for every integer `0..9999`
- for a prime `p`, process `divmod(p, 10000)` chunks, reusing the precomputed digit lists
- this naturally ignores zero digits

## Files

- `main.py` — computes `F(10^8) mod 1_000_000_007` and asserts the given test values.
