# Project Euler 380 Solution - Amazing Mazes!

<https://projecteuler.net/problem=380>:

* [380.py](380.py)

## Key observation
A “perfect” `m×n` maze (exactly one path between squares) is exactly a **spanning tree** of the `m×n` grid graph:
- Each cell is a vertex.
- An opening between adjacent cells is an edge.
- “Exactly one path” ⇔ the graph is connected and acyclic ⇔ a tree.

So `C(m,n)` equals the number of spanning trees of the grid graph `P_m × P_n`.

## Main techniques used

### 1) Matrix–Tree Theorem
Kirchhoff’s Matrix–Tree theorem says the number of spanning trees equals **any cofactor** of the graph Laplacian `L`
(remove one row/column and take the determinant).

This is great for **small** test cases, and we use it to assert:
- `C(1,1) = 1`
- `C(2,2) = 4`
- `C(3,4) = 2415`

To compute the determinant exactly with integers, the code uses the **Bareiss algorithm** (fraction-free Gaussian elimination).

### 2) Closed-form eigenvalue product for grid graphs
For the Cartesian product `P_m × P_n`, the Laplacian eigenvalues are:

`λ(i,j) = (2 − 2cos(iπ/m)) + (2 − 2cos(jπ/n)) = 4 − 2cos(iπ/m) − 2cos(jπ/n)`

with `i=0..m−1`, `j=0..n−1`.

Matrix–Tree theorem implies the spanning-tree count is:

`C(m,n) = (1/(mn)) * ∏_{(i,j)≠(0,0)} λ(i,j)`

This avoids any large determinants and makes `C(100,500)` easy.

### 3) Work in the log domain + stable summation
`C(100,500)` is astronomically large, so we compute:

`log10(C(m,n)) = −log10(mn) + Σ log10(λ(i,j))`

The implementation:
- precomputes the cosine terms for each `i` and `j`,
- uses **Kahan summation** to reduce floating-point error,
- converts the final `log10` value into **scientific notation rounded to 5 significant digits**.

## Output format
The program prints the answer as required, e.g. `1.2346e12` (lowercase `e`, 5 significant digits).
