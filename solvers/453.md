# Project Euler 453 Solution - Lattice Quadrilaterals

<https://projecteuler.net/problem=453>:

* [453.py](453.py)

This repo contains a fast, exact (integer) solver for:

- **Problem 453**: `Q(12345, 6789) mod 135707531`

where `Q(m, n)` counts **simple quadrilaterals** whose vertices are lattice points in the rectangle
`0 ≤ x ≤ m`, `0 ≤ y ≤ n` (distinct vertices, no straight angles, no self-intersection).

## Main techniques used

### 1) Combinatorial classification of 4-point sets
For four lattice points (with no three collinear):

- If the 4 points form a **convex** quadrilateral, there is **exactly 1** simple quadrilateral.
- If one point lies **strictly inside** the triangle formed by the other three (a **concave** case),
  there are **exactly 3** different simple quadrilaterals (three different ways to “walk around” the
  vertices without self-intersection).

Collinearities are handled via separate correction terms.

This reduces the problem to counting certain geometric/combinatorial configurations, instead of
enumerating quadrilaterals directly.

### 2) Turning geometry into arithmetic sums
The final closed form for `Q(m,n)` can be written as a combination of:

- Binomial coefficients in `P = (m+1)(n+1)`
- A term `S` = **sum of triangle areas** over all lattice triangles in the box
- Two “degeneracy correction” terms `L3` and `L4` that count collinear triples/quadruples in a
  weighted way, expressible using `gcd(Δx,Δy)` sums.

All of these can be expressed using sums of the form:

- `∑ x^a y^b gcd(x,y)^c` over rectangular ranges

### 3) Fast evaluation via floor-division grouping + memoization
Naively summing over all `x,y` up to `(12345,6789)` is too slow.

The implementation uses a classic trick for summatory functions:

- Many terms depend on `⌊m/k⌋` and `⌊n/k⌋`, which take only **O(√m)** distinct values.
- We group equal floor-division values into blocks, and use recursion + memoization (caching) to
  compute weighted **coprime sums**:

  `G(u,v,a,b) = ∑_{gcd(x,y)=1, x≤u, y≤v} x^a y^b`

From `G`, we build:

`H(a,b,c) = ∑_{x≤m,y≤n} x^a y^b gcd(x,y)^c`

and then assemble the closed form for `Q(m,n)`.

### 4) Pick’s theorem (conceptually)
Pick’s theorem is used in the underlying derivation to relate triangle area, boundary lattice points,
and interior lattice points. That’s what allows the “geometry” pieces to be rewritten into gcd-based
arithmetic sums.

## Files

- `main.py` — solver + asserts for the problem statement test values.
- `README.md` — this explanation.

## Output

Running `python3 main.py` prints the answer for the Euler input:

`104354107`
