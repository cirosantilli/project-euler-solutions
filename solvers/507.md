# Project Euler 507 Solution - Shortest Lattice Vector

<https://projecteuler.net/problem=507>:

* [507.py](507.py)

This repository contains a pure-Python solution (no external libraries) for **Project Euler 507**.

## Key ideas

### 1) View each `(V_n, W_n)` as a rank‑2 lattice
All lattice vectors have the form:

\[
D = kV_n + \ell W_n,\quad k,\ell \in \mathbb{Z}
\]

We want the **shortest non‑zero** vector under the Manhattan (L1) norm:

\[
\|D\|_1 = |D_x| + |D_y| + |D_z|
\]

So each `S(n)` is a shortest‑vector problem in a **2D lattice embedded in 3D**.

### 2) 2D lattice reduction, but for the L1 norm
For Euclidean norm, the classic 2D reduction is Gauss/Lagrange reduction.  
Here we need the **L1** version.

Given a current basis `(A, B)`, we perform **size reduction**:

\[
B \leftarrow B - mA
\]

where the integer `m` is chosen to minimize:

\[
\|B - mA\|_1 = |b_1 - ma_1| + |b_2 - ma_2| + |b_3 - ma_3|
\]

#### Weighted-median trick (continued-fraction flavor)
As a function of real `m`, this is a convex piecewise-linear function. Writing

\[
|b_i - ma_i| = |a_i|\cdot\left|m - \frac{b_i}{a_i}\right|
\]

shows that the minimizing real `m` is a **weighted median** of the three ratios `b_i/a_i`,
with weights `|a_i|`. Since there are only 3 ratios, we can:

1. Sort the 3 fractions by value (with exact integer cross-multiplication),
2. Find the weighted median (and the adjacent ratio in the rare tie case),
3. Test `floor` / `ceil` around that median to get the best integer `m`.

This plays the same role that “rounding the projection” plays in Euclidean Gauss reduction, and
it behaves like a continued-fraction / Euclidean algorithm on the dominating coordinate until
the basis is reduced.

### 3) Shortest vector from a reduced 2D basis
Once reduced, the shortest vector is guaranteed to be among a tiny set:

- `A`
- `B`
- `A + B`
- `A - B`

So `S(n)` is computed by taking the minimum L1 norm among those candidates.

### 4) Streaming Tribonacci residues
The residues satisfy:

\[
r_i = (r_{i-1}+r_{i-2}+r_{i-3}) \bmod 10^7
\]

We **stream** them (no arrays), consuming 12 residues per `n` to build `V_n` and `W_n`.
Because each sum is `< 3·10^7`, the modulus is implemented with at most two subtractions instead
of `%`, which is faster.

## Included checks
The code asserts the test values given in the problem statement:

- `S(1) = 32`
- `sum_{n=1..10} S(n) = 130762273722`

Running `python3 main.py` prints the required sum for `n = 1..20_000_000`.
