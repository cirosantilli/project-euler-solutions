# Project Euler 817 Solution - Digits in Squares

<https://projecteuler.net/problem=817>:

* [817.py](817.py)

This repository contains a standalone Python solution (`main.py`) for Project Euler 817.

## Core observations

We need, for each `d`, the smallest positive integer `m` such that the base-`p` expansion of `m²` contains the digit `p-d`, where

- `p = 1,000,000,007` (a prime), and
- `d` ranges from `1` to `100,000`.

Because `p` is enormous, the digit `p-d` is **very close to the maximum base-`p` digit**. That structure lets us focus on the first couple of base-`p` digits of `m²`.

## Technique 1: Modular arithmetic for the least-significant digit

If the desired digit occurs in the **units digit** (base-`p`), then we need

- `m² ≡ p-d ≡ -d (mod p)`.

Since `p` is prime, we can determine whether `-d` is a quadratic residue using **Euler’s criterion**:

- `(-d)^((p-1)/2) (mod p)` is `1` for a residue and `p-1` for a non-residue.

When it is a residue, `p ≡ 3 (mod 4)` makes modular square roots particularly cheap:

- `sqrt(a) ≡ a^((p+1)/4) (mod p)`.

The smaller root `min(r, p-r)` is the minimal positive `m` giving the required least-significant digit.

## Technique 2: Interval search for the next digit

If `-d` is a **non-residue**, then the least-significant base-`p` digit of any square can never be `p-d`. The earliest occurrence must therefore come from a higher digit.

For this problem’s digit range (`d ≤ 100,000`), it is sufficient to search the **next base-`p` digit** (the `p`’s place). That digit equals `p-d` exactly when `m²` lies in one of the intervals

- `[B·p² - d·p,  B·p² - (d-1)·p - 1]` for integers `B = 1, 2, 3, …`

Each interval has width `p`.

To find the smallest `m` hitting the interval for a given `B`, take

- `m = ceil(sqrt(L))` where `L = B·p² - d·p`,

and check whether `m² ≤ L + (p-1)`.

This uses Python’s fast integer square root (`math.isqrt`) and the monotonicity of squares.

## Correctness checks

The problem statement gives two sample values:

- `M(10, 7) = 24` because `24² = 576` contains digit `7` in base 10.
- `M(11, 10) = 19` because `19² = 361 = 2A9₁₁` contains digit `A` (10) in base 11.

`main.py` includes these as runtime `assert` checks using a tiny brute-force helper (fast for those small bases).

## Complexity

For each `d`:

- one modular exponentiation to compute the Legendre symbol,
- (for about half the cases) one modular exponentiation for the modular square root,
- otherwise a short scan over consecutive `B` values, each doing one integer square root.

The work is therefore about `O(D · log p)` with a small constant factor.
