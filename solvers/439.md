# Project Euler 439 Solution - Sum of Sum of Divisors

<https://projecteuler.net/problem=439>:

* [439.py](439.py)

We define:

- `d(n)` = sum of divisors of `n` (sigma function)
- `S(N) = sum_{i=1..N} sum_{j=1..N} d(i*j)`

We need:

- `S(10^11) mod 10^9`

## Key Techniques Used

### 1) Möbius inversion and divisor rearrangement

A crucial identity reduces the 2D sum into a 1D sum:

\[
S(N)=\sum_{k=1}^{N} (k\mu(k))\cdot H(\lfloor N/k\rfloor)^2
\]

where:

- `μ(k)` is the Möbius function
- `H(x)=\sum_{t=1}^{x} t\lfloor x/t\rfloor`
  which equals `sum_{n<=x} sigma(n)`.

This transforms the original double sum into a sum over Möbius-weighted blocks.

---

### 2) Floor-division grouping (harmonic lemma)

In many sums of the form:

\[
\sum_{i=1}^{n} f(\lfloor n/i\rfloor)
\]

the value `floor(n/i)` changes only `O(√n)` times.

So we iterate intervals `[i..j]` where:

- `v = n // i`
- `j = n // v`

This is used for:

- the main sum over `k`
- computing `H(x)`
- the recursion for the Möbius prefix sum

---

### 3) Dujiao sieve (recursive prefix sums)

We need:

\[
IMU(n)=\sum_{k\le n} k\mu(k)
\]

Direct computation is impossible for `n=10^11`, so we use:

\[
IMU(n)=1-\sum_{blocks} \left(\sum_{k=i}^{j} k\right)\cdot IMU(\lfloor n/i\rfloor)
\]

and memoize results for large `n`.

---

### 4) Small precomputation for speed

We precompute `H(x)` exactly for all `x <= sqrt(N)` using a divisor sieve for sigma:

- build `sigma[n]` for `n <= sqrt(N)`
- build prefix sums `H_small[n] = sum_{k<=n} sigma[k]`

Large `H(x)` values are computed using floor-block iteration.

---

## Validation

The code contains assertions for all values given in the statement:

- `S(3) = 59`
- `S(10^3) = 563576517282`
- `S(10^5) mod 10^9 = 215766508`
