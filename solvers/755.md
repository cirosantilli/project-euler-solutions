# Project Euler 755 Solution - Not Zeckendorf

<https://projecteuler.net/problem=755>:

* [755.py](755.py)

This repository contains a solution for computing:

\[
S(N)=\sum_{k=0}^{N} f(k)
\]

where `f(k)` is the number of representations of `k` as a sum of **distinct** Fibonacci numbers from:

\[
1,2,3,5,8,13,\dots
\]
(with \(F_1=1, F_2=2, F_i=F_{i-1}+F_{i-2}\)).

## Key idea: turn the sum into a subset-counting problem

Each subset of Fibonacci numbers has a unique subset-sum.  
If a subset sums to `m`, it contributes `1` to `f(m)`. Therefore:

- `S(N)` counts **how many subsets have sum ≤ N**.

So the task becomes:

> Count the number of subsets of Fibonacci numbers whose total sum is ≤ `N`.

Only Fibonacci numbers ≤ `N` are relevant.

## Recursion with memoization

Let `count(k, cap)` be the number of subsets of `{F1..Fk}` with sum ≤ `cap`.

A standard knapsack recurrence applies:

- If `cap < Fk`, we cannot take `Fk`:
  - `count(k, cap) = count(k-1, cap)`
- Otherwise:
  - `count(k, cap) = count(k-1, cap) + count(k-1, cap - Fk)`

Memoization (caching) avoids recomputing the same `(k, cap)` states.

## Strong pruning using a Fibonacci sum identity

The sum of the first `k` Fibonacci numbers in this sequence is:

\[
F_1 + F_2 + \dots + F_k = F_{k+2} - 2
\]

If `cap` is at least this value, then **every** subset fits, so:

- `count(k, cap) = 2^k`

This pruning collapses large parts of the recursion tree and keeps the number of
states tiny even for `N = 10^13`.

## Correctness checks

The implementation asserts the sample values provided in the problem statement:

- `S(100) = 415`
- `S(10^4) = 312807`

## Running

```bash
python3 main.py
