# Project Euler 70 Solution - Totient Permutation

<https://projecteuler.net/problem=70>:

* [70.py](70.py)
* [70.lean](70.lean)

We need `1 < n < 10^7` such that `phi(n)` is a digit-permutation of `n`, and `n/phi(n)` is minimal.

## Key ideas used

1. **Compute all totients efficiently**
   - Use a **linear sieve** to compute `phi(k)` for every `k ≤ 9,999,999` in `O(N)` time.
   - Store `phi` in `array('I')` (32-bit) to keep memory reasonable.

2. **Fast permutation check**
   - Two numbers are permutations iff their digit counts match.
   - Compute a compact **digit signature** by packing digit counts into an integer:
     - Use 3 bits per digit (base 8) since counts are ≤ 7 for numbers `< 10^7`.
     - Compare `signature(n) == signature(phi(n))`.

3. **Cheap filters before signature**
   - Same digit multiset ⇒ same digit sum ⇒ `n ≡ phi(n) (mod 9)`.
   - Same multiset ⇒ same number of digits (checked via range bounds).

4. **Minimize ratio without floats**
   - Compare `n/phi(n)` using cross multiplication:
     - `n1/phi1 < n2/phi2` ⇔ `n1*phi2 < n2*phi1`.

The program prints the minimizing `n`.
