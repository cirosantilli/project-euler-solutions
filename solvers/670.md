# Project Euler 670 Solution - Colouring a Strip

<https://projecteuler.net/problem=670>:

* [670.py](670.py)

This repository contains a pure-Python solution (no external libraries) for **Project Euler 670**.

## Core ideas

### 1) Turn the tiling into a small “column automaton”
We process the rectangle **one column at a time**.
Because the only horizontal tile lengths are **1, 2, 3**, any tile can stick out at most **two columns** to the right. With height 2, the boundary between processed/unprocessed area is completely described by a tiny amount of information:

- For each row (top/bottom):
  - Is the current cell already occupied by a horizontal tile coming from the left?
  - If so, does it *also* continue one more column to the right? (this happens only in the middle of a length-3 tile)
  - The colour of that incoming tile.
  - If the cell is *not* occupied, we store the colour of the tile immediately to the left (needed to enforce “adjacent tiles have different colours”).

- A flag telling whether the **previous column** contained a **vertical domino**.
  - This is exactly what’s needed to enforce the rule “no four tile corners meet at a point”, because that rule is local to the boundary between two consecutive columns.

This produces a finite set of reachable boundary states (only **113** states).

### 2) Local transition generation
For each boundary state, we try all legal ways to fill the next column:

- Place a **vertical domino** (2×1) if both cells are free.
- Otherwise place horizontal tiles (length 1/2/3) in whichever rows are free.
- Count how many colour choices satisfy all adjacency constraints.
- Reject transitions that violate the “no four corners meet” rule at the just-crossed boundary.

This yields a weighted directed graph: a **transfer matrix** `T` where `T[i][j]` is the number of ways to go from state `i` to state `j` in one column.

### 3) Fast exponentiation for huge *n*
The number of tilings for width `n` is obtained by applying the transfer matrix `n` times.
For `n = 10^16` we can’t iterate, so we compute:

- `v_n = v_0 · T^n  (mod M)`

using **binary exponentiation** (repeated squaring), with modulus:

- `M = 1,000,004,321`

Finally, we sum the entries of `v_n` that correspond to states with **no tile sticking out past the right edge**.

## Complexity

- States: **113**
- Matrix exponentiation: `O(S^3 log n)` with `S=113` and `log2(10^16) ≈ 54`
- Runs comfortably fast in CPython.

## Files

- `main.py` — builds the automaton, runs the statement’s test asserts, and prints `F(10^16) mod 1,000,004,321`.
