# Project Euler 941 Solution - de Bruijn's Combination Lock

<https://projecteuler.net/problem=941>:

* [941.py](941.py)

This repository contains a pure‑Python solution for Project Euler 941.

## What the code does

1. Generates the first `N` values of the given linear congruential generator (LCG) modulo `10^12`.
2. Treats each value as a 12‑digit string (leading zeros allowed).
3. Orders these strings by their **first occurrence position** in the lexicographically smallest de Bruijn sequence `C(10,12)`.
4. Computes

\[
F(N) = \sum_{i=1}^{N} i \cdot b_i
\]

where `b_i` is the `i`‑th element in that “order of appearance” list.
5. Prints `F(10^7) mod 1234567891`.

## Main techniques

### 1) Ranking substrings in the lexicographically smallest de Bruijn sequence

Building `C(10,12)` explicitly is impossible (it would have length `10^12 + 11`).
Instead we need a **rank function**:

- Input: a length‑`n` word `w` over an alphabet of size `k`.
- Output: the starting index where `w` appears in the linearized lexicographically smallest de Bruijn sequence.

The implementation ports the practical `RankDB` algorithm of Sawada & Williams. The algorithm reduces the problem to:

- Testing whether a word is a **necklace** (lexicographically smallest rotation).
- Computing `lyn(w)`: the length of the longest Lyndon prefix of the necklace representative.
- Counting how many words appear before a given necklace, via a small dynamic program (`T`).

For this Euler problem, `k=10` and `n=12`, so all of the supporting tables are tiny and the algorithm runs in effectively constant time per word.

### 2) Fast digit extraction with fixed-width chunks

Each LCG value must be treated as a 12‑digit string with leading zeros. Converting `10^7` values using `str(...).zfill(12)` is expensive.

The solution splits the number into three 4‑digit chunks (`0000`–`9999`) and uses a precomputed table of those chunk digits, producing the 12 digits with only a few divisions/mods and table lookups.

### 3) Radix sort instead of comparison sort

To compute `F(10^7)` we must sort `N` values by their de Bruijn ranks.

Python’s comparison sort on `10^7` items is too slow and too memory-hungry (tuples, comparisons, etc.).
The program uses a **stable LSD radix sort** on 64‑bit integer keys (the ranks), with a radix of `2^16`:

- 3 passes cover up to 48 bits (ranks fit well within this).
- Each pass is a counting sort into preallocated `array('Q')` buffers.

This reduces sorting to `O(N)` time with low constant factors and predictable memory use.

## Built-in checks

The code includes `assert` statements for the example values from the problem statement:

- `C(3,2) = 0010211220`
- `F(2) = 2194210461325`
- `F(10) = 32698850376317`

Additional small sanity checks compare the rank function to brute-force positions for very small `(k,n)`.

## Running

```bash
python3 main.py          # computes the required result for N = 10^7
python3 main.py 10       # prints the exact F(10)
```
