# Project Euler 690 Solution - Tom and Jerry

<https://projecteuler.net/problem=690>:

* [690.py](690.py)

This solver counts **Tom graphs** (graphs on which Tom can guarantee catching Jerry) up to isomorphism and outputs `T(2019) mod 1_000_000_007`.

## Main ideas

### 1) Structural reduction: Tom graphs are restricted forests
A Tom graph must be acyclic (a forest). Moreover, not every forest works: the connected components must be a special class of trees called **lobsters** (trees whose “leaf-pruned” core is a caterpillar).

So:

- **Connected Tom graphs** ⇔ **lobster trees**
- **All Tom graphs** ⇔ **forests (multisets) of lobster trees**

### 2) Count lobster trees via an explicit generating function
Let

- `P(x) = ∏_{k≥1} 1/(1 - x^k)` be the generating function for integer partitions.
  Its coefficients are the partition numbers `p(n)`.

There is a closed-form ordinary generating function `A(x)` for the number of unlabeled lobsters on `n` vertices, expressed using `P(x)`, `P(x^2)`, and a few rational factors. The code expands this series up to degree `2019` using basic power-series operations (addition, multiplication, series inversion).

### 3) Build forests from trees using the Euler transform
If `b(n)` counts connected components of size `n` (here, lobster trees), then the ordinary generating function for unlabeled forests is

`F(x) = ∏_{k≥1} (1 - x^k)^(-b(k))`.

The coefficient sequence of `F(x)` is the **Euler transform** of `b(n)`. A standard `O(n^2)` recurrence computes it efficiently modulo `1_000_000_007`.

### 4) Mod arithmetic throughout
All coefficients are computed **modulo 1_000_000_007**, including divisions handled via modular inverses (the modulus is prime).

## Complexity
With `n = 2019`:

- Partition DP: `O(n^2)`
- A handful of truncated polynomial multiplications / inversions: `O(n^2)`
- Euler transform: `O(n^2)`

This fits comfortably in time in pure Python.
