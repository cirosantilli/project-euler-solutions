# Project Euler 569 Solution - Prime Mountain Range

<https://projecteuler.net/problem=569>:

* [569.py](569.py)

This solution computes:

\[
S(N)=\sum_{k=1}^{N} P(k)
\]

where `P(k)` is the number of earlier peaks visible from the `k`-th peak.

The required output for **N = 2,500,000** is produced by `main.py` (it prints the final integer).

## Main techniques used

### 1) Prime generation with an odd-only sieve
We need the first `2N` primes. A classic Sieve of Eratosthenes is used, but only **odd numbers** are stored:

- index `i` represents the number `2*i+1`
- this halves memory and speeds up marking

An analytic upper bound `p_n < n(log n + log log n) + 10` is used so the sieve is typically built once.

### 2) Converting primes to peak coordinates
Each mountain uses two consecutive primes:

- up-slope length: `p_{2k-1}`
- down-slope length: `p_{2k}`

From this we build peak coordinates `(X_k, Y_k)` in a single pass.

### 3) Exact visibility checks via slope comparisons
Peak `i` is visible from peak `k` iff for every intermediate peak `j`:

- peak `j` lies **strictly below** the segment `(i,k)`

Equivalently, when scanning peaks leftward from `k-1` down to `1`, the visible peaks are exactly the **record lows** of the slope:

\[
\text{slope}(k,i)=\frac{Y_k-Y_i}{X_k-X_i}
\]

All slope comparisons are done without floating point:
`a/b < c/d` is checked as `a*d < c*b`.

### 4) Output-sensitive dynamic construction of visibility chains
A direct scan for every `k` would be quadratic. The key structural property exploited is:

> The visible peaks from `k` form a chain  
> `v1 = k-1, v2, v3, ...`  
> and each next peak `v_{t+1}` is contained in the visibility list of `v_t`.

So to build the visible list for `k`, we:
1. start with `a = k-1`
2. keep the current minimum slope from `k` to `a`
3. scan the *already known* visibility list of `a` until finding the first peak with an even smaller slope
4. jump to that peak and repeat

This makes the total runtime roughly proportional to the number of visible pairs, which is small enough here.

### 5) Compact memory layout
Storing `N` Python lists would be enormous for `N = 2.5M`. Instead:

- all visibility lists are stored back-to-back in one flat `array('I')`
- `offs[k]` and `ln[k]` give the slice for peak `k`

This keeps memory usage reasonable while retaining O(1) access to each list.

## Built-in correctness checks
`main.py` includes asserts from the problem statement:

- `P(3) = 1`
- `P(9) = 3`
- `sum_{k<=100} P(k) = 227`
