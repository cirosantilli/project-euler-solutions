# Project Euler 534 Solution - Weak Queens

<https://projecteuler.net/problem=534>:

* [534.py](534.py)

## Key reformulation

Let `L = n - 1 - w`.  
A weak queen attacks:

- **horizontally:** any distance (so no two queens can share a row)
- **vertically/diagonally:** only up to **L rows away**

Because we place **n queens on an n×n board** and horizontal attacks are unlimited, every valid placement has **exactly one queen per row**. So each placement is a sequence of columns:

\[
c[0], c[1], \dots, c[n-1] \in \{0,\dots,n-1\}.
\]

For rows `i < j`, define `d = j - i`. Then the pair conflicts **only if** `d <= L` and:

- same column: `c[i] = c[j]`
- same diagonal: `c[i] = c[j] ± d`

For `d > L`, that pair is unconstrained.

So `Q(n,w)` is the number of such sequences with range `L = n-1-w`, and:

\[
S(n) = \sum_{w=0}^{n-1} Q(n,w).
\]

## Main technique: sliding-window DP over the last L rows

Constraints only depend on the last `L` previous rows.  
When filling rows top-to-bottom, row `r` only needs to be checked against rows:

\[
r-1, r-2, \dots, r-L.
\]

That enables a DP where the **state** is the columns used in the last `L` rows (or fewer at the beginning).

### State packing

For `n=14`, each column fits in 4 bits. The solution packs the last `L` columns into an integer:

- low nibble = previous row (distance 1)
- next nibble = distance 2
- …

When a new queen is placed, the state is shifted left by 4 bits and the new column is appended.

This keeps state updates very fast and avoids Python tuples.

### Fast conflict test

For each previous queen at distance `d` in column `c`, the forbidden columns on the current row are:

- `c` (vertical)
- `c + d` and `c - d` (diagonals, if in range)

These are precomputed as small bitmasks and OR’d together to get an `avail` column mask.

## Symmetry: vertical reflection

Reflecting columns `c -> (n-1-c)` preserves all constraints.

- For even `n` (like 14), there are **no fixed points**, so:
  \[
  Q = 2 \cdot Q_{\text{first row in left half}}
  \]
- For odd `n`, the middle column case must be counted separately:
  \[
  Q = 2 \cdot Q_{\text{left half}} + Q_{\text{middle column}}
  \]

This roughly halves the runtime.

## Special cases

- `L = 0` (i.e. `w = n-1`): no vertical/diagonal attacks at all  
  ⇒ each row is independent ⇒ `Q = n^n`
- `L >= n-1` (i.e. `w = 0`): full queen  
  ⇒ classic n-queens, counted with a standard bitmask recursion

## Correctness checks

The code asserts all example values from the statement:

- `Q(4,0)=2`, `Q(4,2)=16`, `Q(4,3)=256`
- `S(4)=276`, `S(5)=3347`

Running `main.py` prints `S(14)`.
