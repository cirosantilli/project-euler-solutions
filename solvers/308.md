# Project Euler 308 Solution - An Amazing Prime-generating Automaton

<https://projecteuler.net/problem=308>:

* [308.py](308.py)

## Problem in one line
Run Conway’s FRACTRAN program (PRIMEGAME) starting from `n = 2` and determine how many **iterations** it takes before it first produces a value of the form:

\[
2^{p_{10001}}
\]

where \(p_{10001}\) is the 10001st prime.

---

## Main techniques used

### ✅ 1) FRACTRAN as a register machine
A FRACTRAN integer encodes multiple registers via prime exponents:

\[
n = 2^{a} 3^{b} 5^{c} 7^{d} \cdots
\]

Each fraction tests/decrements some exponents and increments others — effectively a tiny register machine.

---

### ✅ 2) Macro-states: reduce to only `2` and `7`
Conway’s PRIMEGAME repeatedly returns to special “macro-states”:

\[
2^n \cdot 7^m \qquad (0 \le m < n)
\]

Each macro-step advances:

- \(n \to n+1\)
- \(m \to k-1\), where \(k\) is the **largest proper divisor** of \(n+1\)

A power of 2 occurs exactly when \(k = 1\), i.e. when \(n+1\) is prime.

So the whole machine is essentially a slow primality test over increasing \(n\).

---

### ✅ 3) Exact cost formula per checked number \(N\)
Instead of simulating trillions of FRACTRAN steps, we compute the number of steps needed to process each candidate \(N\) directly using an arithmetic formula involving:

- the largest proper divisor \(b\) of \(N\)
- a floor-division sum \(\sum \lfloor N/d \rfloor\)

This makes the total computation feasible.

---

### ✅ 4) Largest proper divisor via smallest prime factor (SPF sieve)
For \(N\):

- If \(N\) is prime → largest proper divisor is `1`
- Else → largest proper divisor is:

\[
b = \frac{N}{\text{smallestPrimeFactor}(N)}
\]

We compute SPF for all values up to \(p_{10001}\) using a sieve in \(O(n \log\log n)\).

---

### ✅ 5) Fast floor-division summation in \(O(\sqrt{N})\)
We compute:

\[
\sum_{d=b}^{N-1}\left\lfloor \frac{N}{d} \right\rfloor
\]

efficiently by grouping ranges of `d` where `N//d` is constant:

- For a quotient \(q = \lfloor N/d \rfloor\),
- all `d` in `[d, N//q]` share that same quotient.

This reduces summation from linear to ~\(2\sqrt{N}\) operations per \(N\).

---

## Complexity
With \(p_{10001} = 104743\):

- sieve: ~O(p log log p)
- loop across all \(N \le p\)
- each uses ~O(sqrt(N)) floor-sum grouping

This runs in ~1 second in Python.

---

## Built-in asserts
The solution includes assertions directly from the statement:

- First FRACTRAN outputs:
  `15, 825, 725, 1925, 2275, 425`
- First powers of two observed:
  `4, 8, 32` i.e. \(2^2, 2^3, 2^5\)

---
