# Project Euler 638 Solution - Weighted Lattice Paths

<https://projecteuler.net/problem=638>:

* [638.py](638.py)

## Key idea: area = inversions in an `R/U` word

A monotone lattice path from `(0,0)` to `(a,b)` can be encoded as a word of length `a+b` containing:

- `a` symbols `R` (right steps)
- `b` symbols `U` (up steps)

For such a word, the **area under the path** equals:

- the sum of the current `y`-coordinate for each `R` step, which is
- the number of `U` steps that appear before each `R`, i.e. the number of **(U before R)** pairs.

That is exactly an **inversion statistic** on the word.

So the weighted sum

\[
C(a,b,k)=\sum_{\text{paths}} k^{A(\text{path})}
\]

is a classic generating function: it is a **Gaussian (q-)binomial coefficient** evaluated at `q=k`.

## Gaussian binomial coefficient

Let `m = a+b`. Then

\[
C(a,b,k) = \binom{m}{a}_q \Big|_{q=k}
\]

where

\[
\binom{m}{n}_q
= \prod_{i=1}^{n}\frac{1-q^{m-n+i}}{1-q^{i}}
\quad\text{(with } n=\min(n,m-n)\text{)}.
\]

For `q=1` this reduces to the ordinary binomial coefficient.

## Modular computation trick: one inverse, not millions

We work modulo `MOD = 1,000,000,007` (a prime), so modular inverses exist whenever the denominator is nonzero.

For `k ∈ {2,…,7}` and the largest exponent we ever need (`≤ 2·10,000,007`), we never hit `k^t ≡ 1 (mod MOD)`,
so **all factors** `(1 - k^i)` are invertible. (In particular, `MOD-1 = 2·500,000,003` is huge compared to our exponents.)

Thus we compute:

- `NUM = Π (1 - k^{b+i})`
- `DEN = Π (1 - k^{i})`
- result = `NUM * DEN^{-1} (mod MOD)`

This uses **exactly one** modular inverse per `C(a,b,k)` evaluation.

## Complexity

For a given `(a,b)`, the product runs for `min(a,b)` steps.

In the actual problem we compute 7 terms with sizes:

`11, 102, 1003, 10004, 100005, 1000006, 10000007`

so the total loop count is about **11.1 million** iterations, which is fast in Python.

## Files

- `main.py` contains the implementation and prints the final answer.
- It also includes `assert` checks for all sample values given in the problem statement.
