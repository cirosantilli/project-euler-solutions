# Project Euler 472 Solution - Comfortable Distance II

<https://projecteuler.net/problem=472>:

* [472.py](472.py)

This solution computes:

\[
\sum_{1\le N\le 10^{12}} f(N)
\]

and outputs the **last 8 digits**.

`f(N)` is the number of first-seat choices that maximize the eventual number of seated people, given:

1. No adjacent seats may be occupied.
2. People arrive sequentially.
3. Each chooses the seat **maximizing distance to the nearest occupied seat**, breaking ties by choosing the **leftmost**.

---

## Core Techniques Used

### 1) Interval Independence (Key Simplification)

Once a seat is occupied, its adjacent seats are permanently blocked.  
That means the remaining usable seats split into **independent segments**:

- Choosing seats in one segment never affects distances in another segment.
- The final seated count becomes the sum of the results of each segment.

So after choosing the first seat:

\[
\text{total}(p)=1 + A(\text{left length}) + A(\text{right length})
\]

where `A(n)` is the number of seats ultimately occupied in a free edge segment of length `n`.

---

### 2) Closed Form for Edge Segment Filling `A(n)`

The greedy seating process inside an edge segment produces a surprisingly simple result.

Let:

- `t = n + 1`
- `p = highest power of 2 ≤ t`

Then:

\[
A(n)=\max\left(\frac p2, \;t-p\right)
\]

This avoids simulation entirely.

---

### 3) Binary Block Structure of `f(N)`

When analyzing `f(N)` across ranges of the form:

- `[2^k, 2^{k+1})`

the function repeats on large parts of the next block due to how the greedy rule depends on **binary distance symmetry**.

This yields two critical regimes:

#### A) Numbers starting with binary `11`  
For blocks:

\[
[3\cdot 2^k,\;4\cdot 2^k - 1]
\]

`f(N)` follows an explicit short piecewise formula in terms of offset.

#### B) Numbers starting with binary `10`
For blocks:

\[
[2^{k+1},\;3\cdot 2^k - 1]
\]

`f(N)` is mostly copied from a smaller block (`N → N - 2^k`) with only a small **triangular correction** on the last quarter.

---

### 4) Fast Prefix Summation `Σ f(N)` via Recursion

The required range is enormous (`10^12`), so we compute:

\[
S(N)=\sum_{n\le N} f(n)
\]

using recursive decomposition by the highest power of 2 ≤ N:

- sum complete lower blocks
- recurse into the partial upper block
- apply `11`-block direct arithmetic sums
- apply `10`-block mapping + arithmetic correction sums

This makes evaluation run in roughly `O(log N)` time.

---

### 5) Arithmetic Series for Corrections

The only non-recursive adjustments are simple sums like:

\[
\sum_{d=1}^{m} d = \frac{m(m+1)}2
\]

which appear because the correction region forms a **descending ramp**.

---

## Validation

Asserts included from the problem statement:

- `f(1)=1`
- `f(15)=9`
- `f(20)=6`
- `f(500)=16`
- `Σ f(N)=83` for `1≤N≤20`
- `Σ f(N)=13343` for `1≤N≤500`

---

## Output

Running `main.py` prints the last 8 digits of:

\[
\sum_{1\le N\le 10^{12}} f(N)
\]

as an 8-digit zero-padded number.
