# Project Euler 383 Solution - Divisibility Comparison Between Factorials

<https://projecteuler.net/problem=383>:

* [383.py](383.py)

We need to count integers `i` with `1 ≤ i ≤ n` such that:

\[
v_5((2i-1)!) < 2\,v_5(i!)
\]

where \(v_5(m)\) is the exponent of 5 in `m`.

## Main techniques

### 1) Legendre’s formula + digit-sum identity (base 5)

Legendre’s formula gives:

\[
v_5(m!) = \sum_{k\ge 1} \left\lfloor \frac{m}{5^k}\right\rfloor
\]

A standard identity connects this to base‑5 digit sums:

\[
v_5(m!) = \frac{m - s_5(m)}{4}
\]

where \(s_5(m)\) is the sum of digits of `m` written in base 5.

Substituting into the inequality and simplifying yields an equivalent, purely digit‑based condition:

\[
s_5(2i-1) \ge 2\,s_5(i)
\]

So the problem becomes: **count `i ≤ n` whose base‑5 digit sum doubles slower than the digit sum of `2i−1`.**

---

### 2) Automaton for computing digits of `2i − 1` in base 5

To compute base‑5 digits of `2i−1` from digits of `i`, we simulate the usual grade‑school operation:

- doubling introduces a **carry** (0 or 1)
- subtracting 1 introduces a **borrow** (0 or 1)

Processing from least significant digit to most significant digit is easy with this `(carry, borrow)` state.

---

### 3) Digit DP with a “reversed” carry/borrow process

A standard digit DP for “`i ≤ n`” wants to process digits from **most significant to least significant** (to maintain a `tight` flag).

But the `(carry, borrow)` propagation for `2i−1` naturally goes from **least to most**.

To reconcile this, the solution:

1. precomputes all **reverse transitions** of the carry/borrow automaton  
   (i.e., given the *next* state and a digit, enumerate all possible *previous* states)
2. runs a digit DP from MSB → LSB using these reverse transitions
3. tracks the running difference:

\[
\Delta = s_5(2i-1) - 2\,s_5(i)
\]

and counts valid `i` with \(\Delta \ge 0\) at the end.

Because the number of base‑5 digits of \(10^{18}\) is only 26, the DP state space is tiny and runs quickly.

---

### 4) Statement checks

The program includes asserts for the values given in the problem statement:

- `T5(10^3) = 68`
- `T5(10^9) = 2408210`
