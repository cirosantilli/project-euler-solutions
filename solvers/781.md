# Project Euler 781 Solution - Feynman Diagrams

<https://projecteuler.net/problem=781>:

* [781.py](781.py)

We need **F(n)**: the number of **connected** graphs built from:

- 2 degree‑1 vertices (one has a single outgoing blue edge, one has a single incoming blue edge)
- `n` degree‑3 vertices, each with:
  - one incoming blue edge,
  - a *different* outgoing blue edge (so **no blue self‑loops**),
  - one red (undirected) edge-end.

Because every degree‑3 vertex contributes exactly one red edge-end, the red edges form a perfect matching, so `n` must be even.

The problem gives test values:

- `F(4) = 5`
- `F(8) = 319`

Both are asserted in `main.py`.

---

## 1) Turning the count into power series

Let `n = 2m`. The red matching contributes the Gaussian moment factor:

- number of pairings of `2m` items is `(2m-1)!!`.

The “blue part” is a directed bijection of outgoing blue stubs to incoming blue stubs, with the constraint that a degree‑3 vertex’s incoming and outgoing blue edges must be **different**, which corresponds to excluding fixed points (derangement-style inclusion–exclusion). This leads to truncated sums of `(-1)^k/k!`.

A convenient way to package the Burnside / inclusion–exclusion bookkeeping is via two formal power series in `h`:

- `A(h)` uses coefficients of `e^{-x}/(1-x)`
- `B(h)` uses coefficients of `e^{-x}/(1-x)^2`

Concretely, for `m >= 0`:

- `A_m = (2m-1)!! * [x^(2m)] (e^{-x}/(1-x))`
- `B_m = (2m-1)!! * [x^(2m)] (e^{-x}/(1-x)^2)`

The required connected count appears as the quotient series:

- `G(h) = B(h) / A(h)`
- then `F(2m) ≡ [h^m] G(h) (mod 1e9+7)`.

So the task reduces to extracting one coefficient from a **power series division**.

---

## 2) Fast power series division via Newton inversion

To compute `G = B / A` up to degree `M = 25_000`, we compute the inverse series `A^{-1}` using Newton iteration:

- start with `inv = 1/A[0]`
- repeatedly double the precision:
  - `inv <- inv * (2 - A*inv)  (mod x^k)`

Finally:

- `G = B * A^{-1}  (mod x^(M+1))`.

This needs fast polynomial multiplication.

---

## 3) Fast multiplication mod 1e9+7 (NTT + CRT)

`1_000_000_007` is not an NTT-friendly prime, so multiplication is done by:

1. Performing 3 NTT convolutions under these primes:

   - `998244353`
   - `1004535809`
   - `469762049`

2. Reconstructing each coefficient with CRT directly into `mod 1e9+7`.

This is fully deterministic (no floating-point rounding issues) and uses only Python built-ins.
