# Project Euler 653 Solution - Frictionless Tube

<https://projecteuler.net/problem=653>:

* [653.py](653.py)

This solution exploits a “collision = identity swap” trick and a coordinate compression that removes the marbles’ diameter.

## 1) Replace marbles by hard rods and compress away the diameter

Work with **left edges** of the marbles (diameter 20 mm, radius 10 mm).

- Let `g1` be the gap (in mm) from the sealed west wall to the west-most surface of the first marble.
- For `i ≥ 2`, let `gi` be the gap between marble `i-1` and `i` (surface-to-surface).

The problem’s PRNG gives:
- `gi = (ri mod 1000) + 1`
- Marble `i` initially moves east iff `ri ≤ 10,000,000`.

Define the **compressed coordinate**

\[
y_i = g_1 + g_2 + \cdots + g_i
\]

This happens because the true left-edge position is

\[
u_i = g_1 + \sum_{k=2}^{i}(g_k + 20)
\]

and subtracting `20*(i-1)` cancels the `+20` terms:

\[
y_i = u_i - 20(i-1) = g_1 + \sum_{k=2}^{i} g_k
\]

So the whole initial configuration is captured by:
- the prefix sums `y_i` (gaps only)
- the initial directions.

## 2) Use the elastic-collision equivalence

In 1D with equal masses and equal speed magnitudes:

- When two adjacent marbles collide, they exchange velocities.
- That is equivalent to **letting them pass through each other** but swapping identities.

In the compressed `y` coordinates, collisions happen at the *same position* (no “+20 mm jump”), so the “pass-through” viewpoint becomes especially clean.

## 3) Reduce exits to sorting one scalar per marble

When there are `M` marbles still inside, the east-most marble exits when its **centre** reaches `x = L`,
i.e. when its **left edge** reaches `L-10`.

In compressed coordinates, the current “effective” absorbing boundary is:

\[
B_M = (L - 10) - 20(M-1)
\]

For a point starting at `y_i`:

- if it initially moves east, time to hit `B_M` is `B_M - y_i`
- if it initially moves west, it first hits 0 then goes east, so time is `y_i + B_M`

So define a single value per marble:

\[
a_i =
\begin{cases}
-y_i & \text{(initially east)}\\
+y_i & \text{(initially west)}
\end{cases}
\]

Then “time to hit boundary” is simply:

\[
t_i(B_M) = B_M + a_i
\]

At each exit, `B_M` is the same constant for all remaining marbles, so the next exiting marble is the one
with the **smallest** `a_i`. Therefore, the exit order is obtained by sorting all `a_i`.

The marble labels exit from east to west (marble `N` first, then `N-1`, …), so marble `j` exits with rank:

\[
m = N - j + 1
\]

At that moment, only marbles `1..j` remain, so `M = j`, and:

\[
B_j = (L - 10) - 20(j-1) = L - 20j + 10
\]

Finally:

\[
d(L, N, j) = B_j + a_{(m)}
\]

where `a_(m)` is the `m`-th smallest value in the multiset `{a_i}`.

## 4) Complexity

- Generate all `a_i` in `O(N)` time.
- Sort `N` integers: `O(N log N)`.
- Memory: `O(N)`.

For the required `N = 1,000,001`, this easily fits in time and memory in Python.

## 5) Correctness checks

The implementation includes `assert` statements for the given examples:

- `d(5000, 3, 2) = 5519`
- `d(10_000, 11, 6) = 11_780`
- `d(100_000, 101, 51) = 114_101`
