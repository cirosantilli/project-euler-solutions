# Project Euler 276 Solution - Primitive Triangles

<https://projecteuler.net/problem=276>:

* [276.py](276.py)

We need to count integer-sided triangles \((a,b,c)\) with \(a\le b\le c\), perimeter \(a+b+c\le N\), and \(\gcd(a,b,c)=1\) ("primitive"). Here \(N=10{,}000{,}000\).

## 1) Count all integer triangles by perimeter

Let \(t(p)\) be the number of integer triangles with **exact** perimeter \(p\) (up to congruence, i.e. \(a\le b\le c\)). A classical result (see OEIS A005044 / Wikipedia “Integer triangle”) is:

- \(t(p)=\operatorname{round}(p^2/48)\) if \(p\) is even
- \(t(p)=\operatorname{round}((p+3)^2/48)\) if \(p\) is odd

Define the cumulative count
\[
A(n)=\sum_{p\le n} t(p)
\]
which is the number of (not-necessarily-primitive) integer triangles with perimeter at most \(n\).

## 2) Turn the cumulative sum into an O(1) formula

After substituting \(p=2m\) and \(p=2m+1\), the problem reduces to the helper sum
\[
S(m)=\sum_{k=1}^{m} \left\lfloor \frac{k^2+6}{12}\right\rfloor.
\]

Use
\[
\left\lfloor \frac{k^2+6}{12}\right\rfloor
=\frac{k^2+6-((k^2+6)\bmod 12)}{12}
\]
so
\[
S(m)=\frac{\sum_{k\le m}k^2 + 6m - \sum_{k\le m}((k^2+6)\bmod 12)}{12}.
\]

- \(\sum k^2\) has a closed form \(m(m+1)(2m+1)/6\).
- The remainder term \(((k^2+6)\bmod 12)\) depends only on \(k\bmod 6\), so its prefix sums are computed by a tiny precomputed pattern.

This yields an O(1) function for \(S(m)\), and therefore an O(1) function for \(A(n)\):
\[
A(n)=S(\lfloor n/2\rfloor) + S\left(\left\lfloor\frac{n+1}{2}\right\rfloor + 1\right).
\]

## 3) Möbius inversion to extract primitive triangles

Every integer triangle has a gcd \(d=\gcd(a,b,c)\). Dividing by \(d\) maps it to a unique primitive triangle.

- The number of triangles whose sides are all divisible by \(d\) is exactly \(A(\lfloor N/d\rfloor)\).
- By Möbius inversion:
\[
P(N)=\sum_{d=1}^{N} \mu(d)\,A(\lfloor N/d\rfloor)
\]
where \(\mu\) is the Möbius function.

## 4) Fast summation by divisor grouping

The term \(\lfloor N/d\rfloor\) takes only \(O(\sqrt N)\) distinct values. We group ranges of \(d\) where the quotient is constant.

For this we need the Mertens prefix function
\[
M(x)=\sum_{k\le x} \mu(k).
\]
Then for each interval \([l,r]\) with constant \(q=\lfloor N/d\rfloor\):
\[
\sum_{d=l}^{r} \mu(d)\,A(q) = (M(r)-M(l-1))\,A(q).
\]

## 5) Linear sieve for \(\mu\) and \(M\)

A linear-time prime sieve computes \(\mu(1..N)\) without factoring each number, and a single pass builds the prefix array \(M(x)\). Memory is kept reasonable by storing \(\mu\) in an 8-bit array and \(M\) in a 32-bit array.

---

**Complexity**

- Sieve: \(O(N)\) time
- Grouped Möbius sum: \(O(\sqrt N)\) time
- Memory: \(O(N)\) for the prefix arrays

For \(N=10{,}000{,}000\) this runs comfortably in a few seconds in Python.
