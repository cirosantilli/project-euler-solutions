# Project Euler 882 Solution - Removing Bits

<https://projecteuler.net/problem=882>:

* [882.py](882.py)

## Key ideas

### 1) Split the position into independent components
The starting position contains `k` copies of the number `k` for `k = 1..n`.
A move always chooses exactly one number and changes only that number, so the game is a **disjunctive sum** of independent subgames (one subgame per number in the multiset).

If `g(x)` is the combinatorial game value of a *single* number `x`, then the whole position has value

\[
G(n) = \sum_{k=1}^{n} k\,g(k).
\]

### 2) “Skipping” is the same as adding a negative integer game
A skip is a move available only to Dr. Zero (Right) that leaves the main position unchanged.
In combinatorial game theory this is equivalent to adding the game `-1` (Right has a move, Left does not).
Allowing `K` skips corresponds to adding `-K`, so the effective value becomes `G(n) - K`.

Because these positions evaluate to **numbers** (not fuzzy games), Right wins with Left to move iff

\[
G(n) - K \le 0.
\]

Therefore the minimal `K` that makes Right win is

\[
S(n) = \lceil G(n) \rceil.
\]

### 3) Each single-number game is a dyadic rational
For a fixed binary representation of `x`, Dr. One deletes a `1` bit and Dr. Zero deletes a `0` bit.
Every move strictly shortens the bitstring, so the game graph is acyclic.
Empirically (and as expected for short number games here), every `g(x)` is a **dyadic rational**:

\[
\frac{m}{2^e}.
\]

That makes exact integer arithmetic possible by using a single global denominator `2^E`.

### 4) Dynamic programming over integers
Deleting a bit from `x` always produces a smaller integer `y < x`, so values can be computed in increasing order:

- compute all option values `g(y)` for `y` reachable by deleting one bit from `x`
- reduce the option lists using canonical pruning for number games
- choose the *simplest* dyadic strictly between the remaining Left and Right bounds

### 5) “Simplest dyadic between bounds”
After pruning, the value of a number game is the earliest-born dyadic strictly between

- `max(left options)` and
- `min(right options)`.

To find it, we scan denominators `1, 2, 4, ...` (powers of two) and pick the first grid point that lies in the open interval.

## Complexity
For `n = 100000`, numbers have at most 17 bits.
Each `g(x)` checks at most that many deletions and performs small list filtering.
Overall time is roughly `O(n log n)` with small constants, and memory is `O(n)`.
