# Project Euler 300 Solution - Protein Folding

<https://projecteuler.net/problem=300>:

* [300.py](300.py)

This solution computes the **average number of H–H contact points** in an **optimal 2D folding**
of a random protein string of length **15**, where each residue is equally likely to be `H` or `P`.

Check value from the problem statement (asserted in `main.py`):

- For **n = 8**, the average is **850 / 2⁸ = 3.3203125**

---

## Main ideas

### 1) Symmetry-reduced enumeration of self-avoiding walks
A folding is a **self-avoiding walk** (SAW) of length `n-1` on the square grid.

We reduce duplicates by fixing:
- residue 0 at `(0,0)` and residue 1 at `(1,0)` (removes rotations)
- and requiring the final `y >= 0` (removes mirror images)

---

### 2) Keep only *contact maps*
Many different SAWs yield the same set of residue-residue adjacencies.

So instead of storing every geometric folding, we store just the **contact map**:
- a set of *non-consecutive* adjacent index pairs `(i,j)`  
- encoded as a compact bitmask

For `n = 15` this produces **12,494** distinct contact maps, and each has at most **8** non-consecutive contacts.

Consecutive contacts `(i, i+1)` are handled separately: they exist in every folding but still count if both are `H`.

---

### 3) Evaluate all 2ⁿ proteins in parallel with **bit-sliced arithmetic**
Each protein is an integer `p` from `0..2^n-1`:
- bit `i` = `1` means residue `i` is `P`
- bit `i` = `0` means residue `i` is `H`

For each residue pair `(i,j)`, we precompute a **bitset** over all proteins where both are `H`.
This bitset is a Python `int` with `2^n` bits.

For a given contact map with up to 8 edges, we:
- add those edge-bitsets using a bit-sliced “binary counter” (big-int XOR/AND carry logic)
- add the already-precomputed bit-sliced consecutive-contact count
- update the running per-protein maximum using a bit-sliced comparator (`max(A,B)` without looping over proteins)

Finally, we compute the sum over all proteins without decoding any per-protein values:
\[
\sum_p \text{best}(p) = \sum_k 2^k \cdot \text{popcount}(\text{best\_slice}_k)
\]

---

### 4) Exact decimal output
The answer is:

\[
\frac{\sum_p \max_{\text{foldings}} \text{contacts}(p)}{2^n}
\]

Since the denominator is `2^n`, the decimal expansion terminates (≤ `n` digits).
We compute it exactly via multiplying by `5^n` and dividing by `10^n`.

---

## Result

Running:

```bash
python3 main.py
```

prints:

```
8.0540771484375
```
