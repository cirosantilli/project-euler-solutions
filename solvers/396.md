# Project Euler 396 Solution - Weak Goodstein Sequence

<https://projecteuler.net/problem=396>:

* [396.py](396.py)

This solution uses three ideas:

## 1) Replace the “base-changing countdown” by a Hardy hierarchy value

Let `a(n)` be the **final base** reached by the weak Goodstein process that starts at `n`
(i.e. the first base `B` where the sequence value becomes `0`).  
Then the required length is:

- `G(n) = a(n) - 2`

A standard Goodstein-style ordinal argument shows that `a(n)` can be expressed using the
**Hardy hierarchy** `H_α(x)`:

- Write `n` in base 2 as digits `d_k ... d_1 d_0`
- Form the ordinal `α(n) = d_k ω^k + ... + d_1 ω + d_0`
- Then `a(n) = H_{α(n)}(2)`

For `n < 16`, the largest exponent is 3, so we only need ordinals below `ω⁴` (and in fact,
only one `ω³` term ever appears).

## 2) Closed forms for the small ordinals and a key iteration for `ω³`

With the standard fundamental sequences used for Goodstein/Hardy proofs:

- `H_k(x) = x + k` (finite k)
- `H_ω(x) = 2x + 1`
- `H_{ω²}(x) = (x+1) · 2^(x+1) − 1`

Define:

- `f(x) = H_{ω²}(x) = (x+1)·2^(x+1) − 1`

Then the fundamental sequence for `ω³` yields:

- `H_{ω³}(x) = H_{ω²·(x+1)}(x) = f applied (x+1) times to x`

For this Euler problem we only need `x ∈ {2,3,5,7,23,63,383,2047}`, so the iteration count
is at most `2048` — *big enough to be interesting, small enough to loop*.

Also, for `m < 8`:

- `α(8+m) = ω³ + α(m)` and `α(m) < ω³`
- so `a(8+m) = H_{ω³}( a(m) )`

That reduces everything to repeated application of the single function `f(x)`.

## 3) Modular arithmetic for astronomically large values

We need the last 9 digits, i.e. modulo:

- `10^9 = 2^9 · 5^9`

So we compute residues modulo `2^9` and `5^9` separately and combine with CRT.

### Mod `2^9`

For `k = 9`, `2^e ≡ 0 (mod 2^k)` once `e ≥ k`.  
After the very first step (values already exceed 9), the `2^(x+1)` factor becomes `0` modulo `512`,
so the iteration quickly stabilizes.

### Mod `5^9`

Because `gcd(2, 5^9) = 1`, we can reduce exponents modulo `φ(5^9) = 4·5^8`.  
But `f(x)` needs `2^(x+1)` and **the exponent itself is the previous iterate**, so we must
also know `x` modulo `φ(5^9)`, and for that we must know `x` modulo `φ(φ(5^9))`, etc.

The implementation keeps a **totient chain**:

`m0 = 5^9, m1 = φ(m0), m2 = φ(m1), ... , 1`

At each iteration we track the current value `x` modulo every `mi`, which provides exactly
the reduced exponent needed at the level above. Powers of two in intermediate moduli are handled
directly (because `2^e mod 2^k` is trivial), and the odd part is handled with Euler reduction.

Finally, residues modulo `2^9` and `5^9` are combined via the Chinese Remainder Theorem.

## Result

Running `main.py` prints the last 9 digits of:

`Σ_{1 ≤ n < 16} G(n)`
