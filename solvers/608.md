# Project Euler 608 Solution - Divisor Sums

<https://projecteuler.net/problem=608>:

* [608.py](608.py)

This solution computes:

\[
D(m,n)=\sum_{d\mid m}\sum_{k=1}^{n}\sigma_0(kd)
\quad\text{with}\quad m=200!,\; n=10^{12}
\]

where \(\sigma_0(x)=\tau(x)\) is the number-of-divisors function.

The code is fully self-contained (standard library only) and prints the required value modulo \(10^9+7\).

---

## 1) Turning the double sum into a multiplicative function

Fix \(m\) and define:

\[
S(k)=\sum_{d\mid m}\tau(kd)
\quad\Rightarrow\quad
D(m,n)=\sum_{k\le n}S(k)
\]

For \(m=M!\), write \(a_p=v_p(M!)\).  
If \(k\) has exponent \(b_p=v_p(k)\), then for each prime \(p\le M\):

\[
\sum_{e=0}^{a_p} (b_p+e+1) = (a_p+1)\left(b_p+1+\frac{a_p}{2}\right)
\]

So \(S(k)\) factors prime-by-prime. After pulling out the constant

\[
A=\prod_{p\le M}(a_p+1)
\]

we get a multiplicative function \(f(k)=S(k)/A\).

---

## 2) Euler products and a Dirichlet convolution

For primes \(p>M\), \(a_p=0\) so the local factor is just \((b_p+1)\), i.e. \(\tau\).

For primes \(p\le M\), the local factor becomes \((b+1+a/2)\). The resulting Euler product can be written as:

\[
F(s)=C\cdot \zeta(s)^2 \prod_{p\le M}\left(1-\frac{a_p}{a_p+2}p^{-s}\right)
\]

where

\[
C=\prod_{p\le M}\frac{a_p+2}{2}
\]

The factor \(\zeta(s)^2\) corresponds to \(\tau\).  
The product \(\prod(1-\alpha_p p^{-s})\) corresponds to a squarefree-supported multiplicative function \(g\) with:

- \(g(1)=1\)
- \(g(p)=-\alpha_p=-\dfrac{a_p}{a_p+2}\)
- \(g(p^2)=0\)

Thus, up to the constant \(C\):

\[
f = C\cdot (\tau * g)
\]

So:

\[
D(M!,n)=A\cdot C\cdot \sum_{k\le n} (\tau*g)(k)
\]

---

## 3) Reducing to \(\sum g(q)\,T(\lfloor n/q\rfloor)\)

Using convolution:

\[
\sum_{k\le n}(\tau*g)(k)=\sum_{q\le n}g(q)\sum_{t\le n/q}\tau(t)
\]

Define the divisor summatory function:

\[
T(x)=\sum_{t\le x}\tau(t)
\]

Then:

\[
H(n)=\sum_{q\le n} g(q)\,T(\lfloor n/q\rfloor)
\]

and the final answer is:

\[
D = (A\cdot C)\cdot H(n)\pmod{10^9+7}
\]

All fractions are handled modulo \(10^9+7\) using modular inverses.

---

## 4) Computing \(T(x)\) efficiently

We use the classic identity:

\[
T(x)=\sum_{i=1}^{x}\left\lfloor\frac{x}{i}\right\rfloor
     =2\sum_{i=1}^{\lfloor\sqrt{x}\rfloor}\left\lfloor\frac{x}{i}\right\rfloor
      - \lfloor\sqrt{x}\rfloor^2
\]

- Precompute \(T(x)\) for all \(x\le \lfloor\sqrt{n}\rfloor\) using a linear sieve for \(\tau\).
- For larger \(x\), compute the above formula on-demand and memoize.

---

## 5) Splitting the \(q\)-sum and meet-in-the-middle for prefix sums of \(g\)

The function \(g(q)\) is **squarefree** and only uses primes \(\le 200\).  
There are ~44 million such products \(\le 10^{12}\), too many to enumerate directly.

We split:

- enumerate all \(q \le y\) explicitly (with \(y=10^9\), about 1.94 million terms),
  and accumulate weights grouped by the quotient \(t=\lfloor n/q\rfloor\).
- for \(q>y\), the quotient \(t=\lfloor n/q\rfloor \le n/y\) is small (here \(\le 1000\)),
  and each contribution needs only **range sums** of \(g\):

\[
\sum_{L<q\le R} g(q)=G(R)-G(L)
\quad\text{where}\quad
G(x)=\sum_{q\le x} g(q)
\]

### Meet-in-the-middle for \(G(x)\)

Split the primes into two halves. Every squarefree \(q\) decomposes uniquely as \(q=a\cdot b\).

- Enumerate all products in half 1 (≈ 1,000,000) and sort them, building prefix sums of weights.
- Enumerate all products in half 2 (≈ 45,000).
- For each needed \(x\):

\[
G(x)=\sum_{b}\; g(b)\cdot \Big(\sum_{a\le x/b} g(a)\Big)
\]

The inner “\(\sum_{a\le u} g(a)\)” is obtained by binary search in the sorted list plus a prefix-sum lookup.  
A cache is used for repeated \(u=x//b\) values across many \(x\), which happens very often.

---

## 6) Result

The program:
- verifies the two examples from the statement using `assert`,
- computes and prints \(D(200!,10^{12}) \bmod (10^9+7)\).

Run:

```bash
python3 main.py
```
