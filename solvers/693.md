# Project Euler 693 Solution - Finite Sequence Generator

<https://projecteuler.net/problem=693>:

* [693.py](693.py)

This repository contains a pure-Python solution for computing **f(3,000,000)** from Project Euler problem 693.

## Core idea for computing g(x)

For fixed `x`, every choice of `y` produces a sequence

- `a_x = y`
- `a_{z+1} = a_z² (mod z)` for `z = x, x+1, ...`
- stop when `a` becomes `0` or `1`

Instead of simulating each `y` separately, we simulate **all possibilities at once**.

Define an **active set** `A_z` = all values `> 1` that can occur at index `z` for *some* starting `y < x` (values `0` and `1` are excluded because they terminate immediately).

Then the union evolves by a deterministic rule:

`A_{z+1} = { a² mod z : a ∈ A_z } \ {0, 1}`

The longest chain length for this `x` is reached exactly when the active set becomes empty; that moment means every possible start has hit `0` or `1`.

### Practical speed-ups

- **Start after the first step.** The initial set `{2..x-1}` is huge, but its image after one squaring modulo `x` can be generated directly.
- **Symmetry of squaring.** `y² mod x` equals `(x−y)² mod x`, so only `y = 2..⌊x/2⌋` must be iterated to build the first active set.
- **Deduplication with a bytearray.** For large active sets, a `bytearray` marker gives fast “seen” checks without hashing.
- **Switch to hashing when small.** Once the active set is small, a normal Python `set` becomes more efficient than allocating large marker arrays.
- **Singleton fast path.** When the active set collapses to a single value, we stop building sets entirely and just follow that one value forward; this is crucial for very long chains.

## Finding f(n) efficiently

We need `f(n) = max_{2 ≤ x ≤ n} g(x)`.

A key inequality provides an upper bound:

For `r ≥ x`, dropping the first `(r−x)` terms of any sequence starting at `x` yields a valid sequence starting at `r`, so:

`g(x) ≤ g(r) + (r − x)`

Therefore, on any interval `[l, r]`:

`max_{l ≤ x ≤ r} g(x) ≤ g(r) + (r − l)`

The program uses a **best-first branch-and-bound** search:

1. Evaluate `g` on a coarse grid to get a strong initial lower bound.
2. Put each gap `[l, r]` into a priority queue keyed by the upper bound `g(r) + (r-l)`.
3. Always split the interval with the highest remaining bound.
4. Stop when the queue’s best bound can’t beat the current best value.

This guarantees the maximum is found, while computing `g(x)` for only a small fraction of all `x`.

## Running

```bash
python3 main.py
```

The script runs the small assertions from the statement and then prints `f(3_000_000)`.
