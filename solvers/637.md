# Project Euler 637 Solution - Flexible Digit Sum

<https://projecteuler.net/problem=637>:

* [637.py](637.py)

## Approach
- Observe that for `n <= 10^7` the number of steps `f(n, B)` is at most 3. A full digit split yields a sum below `B^2` for base 10 and well below `3^4` for base 3, so two additional steps always suffice.
- For `n >= B`:
  - If the digit sum in base `B` is `< B`, then `f(n, B) = 1`.
  - Otherwise `f(n, B) = 2` iff there exists a partition of the digits whose block-sum has digit sum `< B`. If no such partition exists, then `f(n, B) = 3`.
- This reduces the task to efficiently testing whether any partition sum has digit sum `< B`.

## Implementation Details
- Iterate `n = 1..N` and maintain digits and digit sums incrementally in base 10 and base 3 (least-significant-digit first).
- Precompute:
  - digit-sum tables for all values up to `N` for bases 10 and 3;
  - powers of 10 and 3 up to the max digit lengths;
  - for each digit length, a list of digit-partition masks ordered by many separators first (to find a good partition early).
- For each `n` with digit sum `>= B`, compute prefix values for the digits and test partition sums using precomputed blocks. The first partition whose sum has digit sum `< B` determines `f = 2`.
- Accumulate `n` into the total when `f(n,10) == f(n,3)`.

## Complexity
- Each number uses O(length) work for prefix values and checks a small number of partitions on average.
- Total runtime is a few minutes or less in PyPy for `N = 10^7`.
