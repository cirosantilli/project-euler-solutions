# Project Euler 795 Solution - Alternating GCD Sum

<https://projecteuler.net/problem=795>:

* [795.py](795.py)

We are asked to compute

- \(g(n) = \sum_{i=1}^{n} (-1)^i \gcd(n, i^2)\)
- \(G(N) = \sum_{n=1}^{N} g(n)\)

for \(N = 12{,}345{,}678\).

## Main ideas used

### 1) Split by parity: all odd \(n\) are trivial
A key simplification is that

- if \(n\) is odd, then \(g(n) = -n\)

so the whole odd part of \(G(N)\) can be summed in \(O(1)\) using the identity
\(1 + 3 + 5 + \dots + (2m-1) = m^2\).

### 2) Rewrite the even case as a divisor sum
For even \(n\), the alternating GCD sum can be turned into a divisor sum over \(d \mid n\) that only depends on:

- Euler's totient \(\varphi(d)\)
- the **square part** of \(d\)

Write \(d = r \cdot s^2\) with \(r\) squarefree (the “squarefree kernel”) and \(s = \sqrt{\text{square part}(d)}\).
Then the formula used by the implementation is equivalent to:

\[
\frac{g(n)}{n} = \sum_{\substack{d\mid n\\ d\ \text{even}}} \frac{\varphi(d)}{d} \; s(d).
\]

### 3) Introduce a multiplicative function to get prime-power closed forms
Define the arithmetic function

\[
A(n) = \sum_{d\mid n} \frac{n}{d} \, \varphi(d) \, s(d).
\]

This is a Dirichlet convolution of two multiplicative functions, hence **multiplicative** itself.
That means \(A(n)\) is determined by its values on prime powers, and we can use closed forms:

- for \(e = 2k\):  \(A(p^{2k}) = p^{2k-1}\big((p+1)p^{k} - 1\big)\)
- for \(e = 2k+1\): \(A(p^{2k+1}) = p^{2k}\big(2p^{k+1} - 1\big)\)

### 4) Reduce \(g(n)\) for even \(n\) to the odd part
Write an even number as \(n = 2^a m\) with \(m\) odd.
From the divisor-sum identity one can show:

\[
 g(n) = A(n) - 2^a A(m).
\]

Since \(A\) is multiplicative and \(\gcd(2^a,m)=1\), we have \(A(n)=A(2^a)A(m)\), so

\[
 g(n) = A(m)\big(A(2^a) - 2^a\big).
\]

The program precomputes \(c_2(a)=A(2^a)-2^a\), so each even \(n\) only needs \(A(m)\).

### 5) Fast factorization with a smallest-prime-factor sieve
All needed \(m\) values satisfy \(m \le N/2\). The code builds a **linear sieve** of smallest prime factors up to \(N/2\), enabling fast prime factorization of each odd part \(m\) and thus fast evaluation of \(A(m)\).

### 6) Sum evens without iterating all \(n\)
Every even \(n\le N\) is uniquely represented by an odd \(m\le N/2\) and an exponent \(a\ge 1\) with \(n=m\cdot 2^a\).
The implementation loops over odd \(m\) once, computes \(A(m)\) once, and then adds contributions for all valid powers of two.

## Complexity

- Sieve up to \(N/2\): \(O(N)\) operations and \(O(N)\) memory (4 bytes per entry).
- Factoring all odd \(m\le N/2\) using the sieve: about \(O((N/2)\log\log N)\) total prime-factor steps.
- Summation over all even numbers: exactly \(N/2\) additions.

This comfortably fits within typical Project Euler constraints in pure Python.
