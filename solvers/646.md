# Project Euler 646 Solution - Bounded Divisors

<https://projecteuler.net/problem=646>:

* [646.py](646.py)

We want

\[
S(n,L,H)=\sum_{\substack{d\mid n\\L\le d\le H}}\lambda(d)\,d
\]

where \(\lambda\) is the Liouville function: \(\lambda(n)=(-1)^{\Omega(n)}\) and \(\Omega(n)\) is the total number of prime factors with multiplicity.

For the actual problem we need \(S(70!,10^{20},10^{60}) \bmod (10^9+7)\).

---

## 1) Turn the summand into a completely multiplicative function

Define

\[
f(d)=\lambda(d)\,d.
\]

Because \(\lambda\) is completely multiplicative, so is \(f\). On prime powers:

\[
f(p^k)=(-1)^k\,p^k = (-p)^k.
\]

So any divisor \(d=\prod p^{k_p}\) has

\[
f(d)=\prod (-p)^{k_p}.
\]

This is perfect for fast divisor enumeration: we can build both the divisor value \(d\) and its contribution \(f(d)\) by multiplying precomputed power tables.

---

## 2) Reduce a bounded sum to prefix sums

Let

\[
F(x)=\sum_{\substack{d\mid n\\ d\le x}} f(d).
\]

Then

\[
S(n,L,H)=F(H)-F(L-1).
\]

So we only need the ability to compute \(F(x)\) quickly.

---

## 3) Meet-in-the-middle over the prime factors of \(n!\)

For \(n=70\), \(70!\) has only 19 primes in its factorisation, but the number of divisors is enormous.

Split the primes into two disjoint sets:

- **STORE** primes → divisors \(b\)
- **ITER** primes → divisors \(a\)

Every divisor \(d\mid n!\) can be written uniquely as \(d=a\cdot b\), and by multiplicativity

\[
f(d)=f(a)\,f(b).
\]

For a prefix bound \(x\):

\[
F(x)=\sum_{a} f(a)\sum_{\substack{b\\ b\le x/a}} f(b).
\]

### Implementation detail

1. Enumerate all STORE divisors \(b\), sort them by value, and build a prefix array of \(\sum f(b)\).
2. For each ITER divisor \(a\), compute `limit = x // a`, binary-search the largest `b <= limit`, and fetch the inner sum in **O(log |B|)**.

The code chooses STORE so that the number of STORE divisors stays below a fixed memory cap (about 1.2 million) but is still reasonably close to \(\sqrt{\tau(n!)}\) to balance work.

---

## 4) Speed trick: loop/base split on the iterated side

Enumerating all ITER divisors can still be millions of combinations. To reduce Python overhead:

- Move the few primes with the largest \((e_p+1)\) factors into a small set of **loop primes**.
- Enumerate the remaining **base primes** into a small list.
- Combine them with nested loops.

This keeps the “stored base list” small (e.g., tens of thousands) while still visiting all ITER divisors exactly once.

---

## 5) Modulo arithmetic

For the final answer, all coefficients are kept modulo \(10^9+7\) during enumeration, which avoids huge intermediate integers.

The example values from the problem statement are asserted using exact integer arithmetic.

---

## Complexity (rough)

Let \(|B|\) be the number of STORE divisors and \(|A|\) the number of ITER divisors.

- Precomputation: \(O(|B|\log |B|)\) for sorting.
- Querying: \(O(|A|\log |B|)\) via binary search.

With \(n=70\) and the chosen split, this comfortably fits in time without any external libraries.
