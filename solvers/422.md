# Project Euler 422 Solution - Sequence of Points on a Hyperbola

<https://projecteuler.net/problem=422>:

* [422.py](422.py)

This solution avoids iterating the geometric construction up to `n = 11^14` by turning it into a small number of modular exponentiations.

## 1) Factor the quadratic form

The hyperbola is

\[
12x^2 + 7xy - 12y^2 = 625.
\]

Its discriminant is a perfect square:

\[
7^2 - 4\cdot 12 \cdot (-12) = 625 = 25^2,
\]

so the left-hand side factors over the rationals:

\[
12x^2 + 7xy - 12y^2 = (3x+4y)(4x-3y).
\]

Define a linear change of variables:

- \(u = 3x + 4y\)
- \(v = 4x - 3y\)

Then the curve becomes the rectangular hyperbola

\[
uv = 625.
\]

Because this is an invertible linear transform, it maps lines to lines and **preserves parallelism**, so the problem’s “parallel lines” rule is unchanged in \((u,v)\)-coordinates.

## 2) Normalize to \(UV = 1\)

Scale by 25:

- \(U = u/25\)
- \(V = v/25\)

so the curve is simply \(UV=1\), and the special point \(X=(7,1)\) becomes \((U,V)=(1,1)\).

Any point on \(UV=1\) can be written as

\[
(U,V) = \left(s,\,\frac{1}{s}\right).
\]

For this problem, the initial points give

- \(s_1 = 4\)
- \(s_2 = -\tfrac{3}{2}\)

and converting back to \((x,y)\) is especially simple:

\[
x = 3s + \frac{4}{s},\qquad y = 4s - \frac{3}{s}.
\]

## 3) The geometric recursion collapses to a 2nd-order division recurrence

On \(UV=1\), intersecting the hyperbola with a line through \(P_{i-1}\) parallel to \(P_{i-2}X\) gives a quadratic with one known root (the point \(P_{i-1}\)), so the other intersection is obtained from the second root.

After substituting \((U,V)=(s,1/s)\), the result simplifies dramatically:

\[
\boxed{s_i = \frac{s_{i-2}}{s_{i-1}}}\quad (i>2).
\]

## 4) Exponent/Fibonacci structure

Write

\[
s_n = s_1^{p_n} s_2^{q_n}.
\]

The exponents satisfy a linear recurrence:

\[
p_n = p_{n-2} - p_{n-1},\qquad q_n = q_{n-2} - q_{n-1},
\]

which becomes an ordinary Fibonacci recurrence after a sign twist. This yields closed forms:

- \(p_n = (-1)^{n+1}F_{n-2}\) (for \(n\ge 2\))
- \(q_n = (-1)^{n}F_{n-1}\)

So `s_n` is just a product of powers of 2 and 3 (and a sign) with exponents expressed using Fibonacci numbers.

## 5) Fast doubling for Fibonacci in \(O(\log n)\)

We only need Fibonacci values **modulo** \(10^9+6\) (because the final modulus is prime \(10^9+7\) and we use Fermat’s theorem for exponents).

The program uses the **fast doubling** identities to compute \((F_n, F_{n+1})\) in \(O(\log n)\) time.

## 6) Modular reconstruction of \((x,y)\)

Let \(s = N/D\) (in lowest terms). Then:

\[
x = \frac{3N^2 + 4D^2}{ND},\qquad y = \frac{4N^2 - 3D^2}{ND}.
\]

For the huge target `n = 11^14` (odd), \(N\) is a power of 2 and \(D\) is a power of 3. The only possible common factors between numerator and denominator are small powers of 2 and/or 3, and for `n >= 3` the reductions stabilize:

- for odd `n`: reduce \(x\) by 12, \(y\) by 1
- for even `n`: reduce \(y\) by 12, \(x\) by 1

All division is performed modulo \(10^9+7\) via modular inverses.

## 7) Statement checks

`main.py` includes asserts for all values given in the problem statement:

- \(P_3\), \(P_4\), \(P_7\)
- the example output for `n = 7`

These are computed exactly using a tiny rational-number helper (only for small `n`).
