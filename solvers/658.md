# Project Euler 658 Solution - Incomplete Words II

<https://projecteuler.net/problem=658>:

* [658.py](658.py)

This repository contains a fast, no-dependencies (standard library only) solution for:

\[
S(k,n)=\sum_{\alpha=1}^{k} I(\alpha,n) \pmod{1\,000\,000\,007},
\quad \text{where } I(\alpha,n) \text{ counts incomplete words of length }\le n.
\]

Target: **\(S(10^7,10^{12}) \bmod 1\,000\,000\,007\)**.

---

## Key ideas

### 1) Inclusion–exclusion for incomplete words
For a fixed alphabet size \(\alpha\), a word is **incomplete** if it misses at least one letter.

For each length \(L\), inclusion–exclusion over the set of missing letters gives:

\[
\#\text{incomplete length }L
=\sum_{t=1}^{\alpha} (-1)^{t+1}\binom{\alpha}{t}(\alpha-t)^L.
\]

Summing over lengths \(0 \le L \le n\) introduces the geometric sum

\[
G(m)=\sum_{L=0}^{n} m^L.
\]

So,

\[
I(\alpha,n)=\sum_{t=1}^{\alpha} (-1)^{t+1}\binom{\alpha}{t}G(\alpha-t).
\]

---

### 2) Swap the summations
We want

\[
S(k,n)=\sum_{\alpha=1}^{k} I(\alpha,n).
\]

Rewrite with \(m=\alpha-t\) and swap the order of summation:

\[
S(k,n)=\sum_{m=0}^{k-1} G(m)\,A(m,k),
\]

where the coefficient

\[
A(m,k)=\sum_{\alpha=m+1}^{k} (-1)^{\alpha-m+1}\binom{\alpha}{m}.
\]

Now the problem becomes computing **all** \(A(m,k)\) for \(m=0..k-1\) in total \(O(k)\).

---

### 3) Closed form for the binomial alternating sum via generating functions
Consider

\[
B(k,m)=\sum_{\alpha=m}^{k}(-1)^{\alpha}\binom{\alpha}{m}.
\]

Using coefficient extraction:

\[
\binom{\alpha}{m}=[z^m](1+z)^{\alpha},
\]

so

\[
B(k,m)=[z^m]\sum_{\alpha=0}^{k}(-1)^{\alpha}(1+z)^{\alpha}
=[z^m]\frac{1-(-1)^{k+1}(1+z)^{k+1}}{2+z}.
\]

This yields a formula in terms of a *prefix binomial sum*:

\[
T_m=\sum_{t=0}^{m}\binom{k+1}{t}(-2)^t,
\]

and for even \(k\) (our case \(k=10^7\)):

\[
A(m,k)=1-2^{-(m+1)}(1+T_m).
\]

Crucially, \(T_m\) can be updated in **O(1)** from \(T_{m-1}\) by maintaining the current term
\(\binom{k+1}{m}(-2)^m\).

---

### 4) Fast evaluation of \(G(m)\) for all \(m\le k\)
We need

\[
G(m)=\sum_{L=0}^{n} m^L=
\begin{cases}
n+1 & m=1\\
\frac{m^{n+1}-1}{m-1} & m\ne 1
\end{cases}
\pmod{p},
\quad p=1\,000\,000\,007.
\]

The heavy part is computing \(m^{n+1}\) for all \(m=0..k-1\).

Because \(k < p\), every \(m\ge 1\) is invertible mod \(p\), so we reduce the exponent:

\[
m^{n+1}\equiv m^{(n+1)\bmod (p-1)} \pmod{p}.
\]

Then we compute all powers \(m^e\) with a **linear sieve**:
- call `pow(p, e, MOD)` only for primes \(p\),
- compute composites with one multiplication using \((ab)^e = a^e b^e\).

We also compute modular inverses \(1..k+1\) in linear time using:

\[
\text{inv}[i] = -\left\lfloor \frac{p}{i}\right\rfloor \text{inv}[p \bmod i]\pmod{p}.
\]

---

## Complexity

- **Time:** \(O(k)\) (a handful of tight loops over \(k=10^7\))
- **Memory:** \(O(k)\), using packed `array('I', ...)` buffers (4 bytes per entry)

---

## Output

Running `main.py` prints the required value:

\[
S(10^7,10^{12}) \bmod 1\,000\,000\,007.
\]
