# Project Euler 461 Solution - Almost Pi

<https://projecteuler.net/problem=461>:

* [461.py](461.py)

This repository contains a Python solution for **Project Euler 461: “Almost Pi”**. citeturn3search2

## Core techniques used

### 1) Tight bounding of the search space
The function is:

\[
f_n(k) = e^{k/n} - 1
\]

Because \(f_n(k)\) is increasing and all terms are non‑negative, we never need \(f_n(k) > \pi\).  
So we can cap:

\[
k \le \left\lfloor n \ln(\pi+1) \right\rfloor
\]

This reduces the (otherwise infinite) search to a finite range.

### 2) Meet-in-the-middle (4-sum → 2-sum)
We want:

\[
f(a)+f(b)+f(c)+f(d) \approx \pi
\]

Instead of trying all 4-tuples (too large), we form **all pair sums**:

\[
s_{ij} = f(i) + f(j)
\]

Then the problem becomes finding two pair sums \(s_{ij}\) and \(s_{kl}\) such that:

\[
s_{ij} + s_{kl} \approx \pi
\]

This is the standard **meet-in-the-middle** trick for 4-sum style problems. citeturn2search2

### 3) Sort + binary search for best complement
After generating all pair sums \(s_{ij}\) (only those \(\le \pi\)), we sort them.  
For each sum \(s\), we binary search for \(\pi - s\), and check the nearest neighbor(s) to minimize the absolute error.

### 4) Track `g(n)` with tie-breaking
The objective is **minimize absolute error first**; if multiple tuples yield the same minimal error, choose the one with minimal:

\[
g(n) = a^2 + b^2 + c^2 + d^2
\]

The solver keeps `(best_error, best_g)` and updates accordingly.

## Practical note for `n = 10000`
For `n = 10000`, the pair list is enormous (~tens of millions), which is memory-heavy in pure Python.  

You can still force the meet-in-the-middle computation for small `n` via:

```bash
python3 main.py --n 200 --force
```

## Built-in correctness check

The file includes an assertion based on the problem statement:

- `g(200) = 64658` citeturn3search2
