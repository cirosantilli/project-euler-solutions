# Project Euler 698 Solution - 123 Numbers

<https://projecteuler.net/problem=698>:

* [698.py](698.py)

This solution computes **F(n)**, the *n-th* “123-number”, and prints

- `F(111111111111222333) mod 123123123`

without hard-coding any known final value.

## Key ideas

### 1) Membership test via recursion + memoization
An integer is a 123-number iff:

- its decimal digits are only `1`, `2`, `3`, and
- for each digit that appears, **the number of occurrences** of that digit is also a 123-number.

The only self-reference happens at `1`, so we take `is_123_number(1) = True` as a base case and
use `lru_cache` to memoize recursive checks.

### 2) Ordering = (length, then lexicographic)
All digits are nonzero, so every number with fewer digits is smaller.
Therefore “ascending order” equals:

1. increasing length `L`
2. lexicographic order among valid length-`L` strings over `{1,2,3}`

### 3) Counting valid numbers of a fixed length
For a fixed length `L`, a valid number is determined by a triple of digit totals:

- `(a, b, c)` = counts of digits `1`, `2`, `3`
- `a + b + c = L`
- each **positive** count is a 123-number (zero means the digit is absent)

For each valid triple, the number of strings is the multinomial coefficient:

`L! / (a! b! c!)`

Summing these over all valid triples gives the number of valid 123-numbers of length `L`.

### 4) Lexicographic unranking by summing completions
Once the target length is found, we build the answer digit-by-digit.

For each candidate next digit (`1`, then `2`, then `3`), we count how many valid length-`L` strings
can extend the new prefix. This is done by summing multinomials over all valid total triples
consistent with the prefix. We then pick the smallest digit whose completion count covers the rank.

### 5) Modulo computation without big integer construction
Even though the final length here is modest, the output requested is a modulus.
The code computes the modulus incrementally from the decimal string.
