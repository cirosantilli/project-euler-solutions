# Project Euler 578 Solution - Integers with Decreasing Prime Powers

<https://projecteuler.net/problem=578>:

* [578.py](578.py)

We count **decreasing prime power** integers `n ≤ N`:

If

`n = p1^a1 p2^a2 … pk^ak` with `p1 < p2 < … < pk`,

then

`a1 ≥ a2 ≥ … ≥ ak`.

`n = 1` is included.

The statement gives:

- `C(100) = 94`
- `C(10^6) = 922052`

We compute `C(10^13)`.

---

## Main techniques used

### 1) Enumerate only prime powers with exponent ≥ 2
We build factorizations in increasing prime order.

From a state `(limit, start_prime_index, max_exp)`:
- choose a prime `p ≥ primes[start_prime_index]`
- choose an exponent `e` with `2 ≤ e ≤ max_exp`
- recurse on `limit // p^e` with:
  - `start_prime_index := index(p) + 1`
  - `max_exp := e` (enforces non-increasing exponents)

This explores only the “powerful” part of the factorization.

### 2) The exponent-1 tail is squarefree
Once the remaining allowed exponent becomes `1`, every later exponent must also be `1`.
So the remainder is a **squarefree** product of larger primes.

Therefore every recursion state adds:
- the count of valid squarefree tails, plus
- contributions from choosing a next prime power `p^e` for `e ≥ 2`.

### 3) Squarefree counting via Möbius
Let `Q(x)` be the number of squarefree integers `≤ x` (including `1`). Then:

\[
Q(x)=\sum_{i=1}^{\lfloor\sqrt{x}\rfloor}\mu(i)\left\lfloor\frac{x}{i^2}\right\rfloor
\]

We compute the Möbius function `μ(i)` up to `⌊√N⌋` with a **linear sieve** and speed up `Q(x)`
by grouping ranges where `⌊x/i^2⌋` is constant, using prefix sums of `μ`.

This makes squarefree counting fast even for `x` near `10^13`.

### 4) Enforcing “all primes ≥ p_start” for squarefree tails
In the recursion we need squarefree numbers whose prime factors are all `≥ primes[start_idx]`.

Define:

`f(x, a) = count of squarefree n ≤ x with all prime factors ≥ primes[a]`.

Every squarefree number `> 1` has a **unique smallest prime factor**. Using that:

\[
f(x,a)=Q(x)-\sum_{i=0}^{a-1} f(\lfloor x/p_i \rfloor, i+1)
\]

Each subtracted term counts squarefree numbers whose smallest prime factor is exactly `p_i`
(because they can be written as `p_i * m`, where `m` is squarefree and uses only primes `> p_i`).

### 5) Memoization
We memoize:
- `Q(x)` (`squarefree_upto`)
- `f(x, a)` (`squarefree_min_prime_index`)
- recursion states `(limit, start_idx, max_exp)` (`count_dpowers`)

This keeps total work manageable for `N = 10^13`.

---

## Running

- `python3 main.py` prints `C(10^13)`
- `python3 main.py 100` prints `C(100)` etc.

The required statement tests are enforced with `assert` in `main.py`.
