# Project Euler 456 Solution - Triangles Containing the Origin II

<https://projecteuler.net/problem=456>:

* [456.py](456.py)

We generate points
\[
x_n = (1248^n \bmod 32323) - 16161,\quad
y_n = (8421^n \bmod 30103) - 15051
\]
and count triangles with vertices in \(P_n\) that contain the origin **strictly in the interior**.

## Key ideas

### 1) Angular ordering + “open semicircle” complement
For three non-origin points, the origin is in the **convex hull** of the triangle iff the three direction vectors are **not** contained in any *open* semicircle of width \(\pi\) (180°).

So we count:
- `total_triples = C(m,3)` for the `m` non-origin points, then subtract
- `open_semicircle_triples`: triples whose directions fit in an open semicircle.

To compute `open_semicircle_triples`, we:
1. Sort all vectors by polar angle (`atan2`).
2. Use a circular two-pointer sweep:
   - For each index `i`, advance `j` while the CCW angle from `i` to `j` is `< π`.
   - Let `k = j - i - 1`; then `C(k,2)` triples are “bad” with `i` as the first point.

This gives an \(O(m \log m)\) solution dominated by the sort, and an \(O(m)\) sweep afterwards.

### 2) Exact half-turn test with integer cross/dot
Rather than comparing floating angles to `π`, we test membership in the open semicircle using exact integer arithmetic:

- `cross(vi, vj) > 0`  ⟺ CCW angle in `(0, π)`
- `cross == 0` and `dot(vi, vj) > 0` ⟺ same ray (angle `0`)
- Otherwise the CCW angle is `≥ π` and the window stops

This prevents floating-point edge errors at exactly 180°.

### 3) Remove boundary cases: antipodal pairs
The previous step counts triangles whose convex hull contains the origin **including boundary** cases.

The origin lies on the triangle boundary iff some edge passes through the origin, which happens exactly when the triangle contains an **antipodal pair**: two points on the same line through the origin but in opposite directions.

For each undirected line through the origin:
- `a` = points on the canonical direction
- `b` = points on the opposite direction

The number of triples containing an antipodal pair on that line is:
- `a*b*(m - (a+b))` (two points on the line, third elsewhere)
- plus `C(a+b,3) - C(a,3) - C(b,3)` (all three points on the line, still invalid triangles)

Summing over all lines gives `antipodal_triples`, which are subtracted from the hull-containing count to obtain **strict interior**.

### 4) Bit-packing for speed/memory
To keep memory and updates fast:
- Each point `(x,y)` is packed into one 64-bit integer.
- Each line stores `(a,b)` as a single packed integer `a + (b << 21)` (since counts ≤ 2,000,000).

## Complexity
- Time: \(O(m \log m)\) due to sorting by angle.
- Memory: \(O(m)\) for storing the points plus a hash map for line counts.
