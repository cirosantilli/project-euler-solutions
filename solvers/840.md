# Project Euler 840 Solution - Sum of Products

<https://projecteuler.net/problem=840>:

* [840.py](840.py)

This repository contains a pure-Python solution for **Project Euler 840: “Sum of Products”**.

## Key techniques

### 1) Arithmetic derivative for `D(n)`
For `n > 1`, the function `D(n)` in the statement matches the **arithmetic derivative** `n'`, characterized by:

- `p' = 1` for primes `p`
- `(ab)' = a'b + ab'`

Using a smallest-prime-factor table `spf`, we compute it with the recurrence:

- Let `p = spf[n]` and `m = n // p` (so `p` is prime and `m < n`).
- Then `n' = m + p * m'`.

The statement’s special case `D(1) = 1` is handled explicitly.

### 2) Generating function for the partition weights
A partition’s weight is the product of `D(part)` over its parts. Summing weights over all partitions of `n` gives `G(n)`.

This is exactly the coefficient sequence of:

`F(x) = ∏_{m≥1} 1 / (1 - D(m) x^m)`

so `G(n) = [x^n] F(x)`.

### 3) Log-derivative gives a convolution recurrence
Taking the logarithmic derivative yields:

`F'(x) / F(x) = ∑_{m≥1} ∑_{k≥1} m * D(m)^k * x^{mk-1}`

Define:

`b(n) = ∑_{d|n} d * D(d)^{n/d}`

If `a(n) = G(n)` with `a(0) = 1`, coefficient extraction gives:

`n * a(n) = ∑_{k=1..n} b(k) * a(n-k)`

All arithmetic is performed modulo `999676999`.

### 4) CDQ divide-and-conquer for fast prefix DP
The recurrence has the form “new coefficients depend on a convolution of previous coefficients”. A standard **CDQ divide-and-conquer** approach computes `a(0..N)` efficiently:

- Solve the left half of an interval.
- Convolve that known left-half block with `b` to add its contribution into the right half.
- Recurse on the right half.

Small intervals are handled by a direct `O(L^2)` loop to reduce overhead.

### 5) Exact polynomial products via NTT + CRT
The modulus `999676999` is not NTT-friendly, so polynomial multiplication is done exactly using three NTT-friendly primes (each of the form `c*2^k + 1`).

For each convolution:

1. Compute the convolution modulo each prime using an in-place iterative NTT.
2. Combine the three residue results with CRT (Garner-style reconstruction).
3. Reduce the reconstructed value modulo `999676999`.

Because the kernel polynomial `b` is reused across many CDQ steps, its NTT transforms are cached for each power-of-two interval length.

## Files

- `main.py` — Computes and prints `S(50000) mod 999676999`.
  - Includes assertions for the test values given in the problem statement.
- `README.md` — This explanation.
