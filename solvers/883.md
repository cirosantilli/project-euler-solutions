# Project Euler 883 Solution - Remarkable Triangles

<https://projecteuler.net/problem=883>:

* [883.py](883.py)

This solution counts *remarkable* triangles in the triangular/hexagonal lattice:
triangles whose three vertices are lattice points, whose incenter is also a lattice
point, and whose inradius is at most `R`. Translations are considered the same;
rotations and reflections are considered different.

The implementation is entirely number-theoretic and avoids geometric floating
point work.

## 1) Hexagonal lattice model

Use integer coordinates `(x, y)` for the hexagonal lattice with quadratic form

\[
Q(x,y) = x^2 + xy + y^2
\]

which equals the squared Euclidean length in this coordinate system.
Counting lattice points inside a circle becomes counting integer pairs with
`Q(x,y) <= B`.

## 2) Classifying valid triangle “shapes” by Eisenstein triples

Fix the unique `60°` vertex (for non-equilateral triangles) at the origin.
Write the two sides adjacent to that angle as integer multiples `k` and `l` of a
lattice direction vector.

The incenter is a lattice point exactly when

\[
s = \sqrt{k^2 + l^2 - kl}
\]

is an integer (an “Eisenstein triple” condition). Primitive solutions (with
`gcd(k,l)=1`) fall into two parametrized families. For each primitive shape,
the inradius constraint depends only on

\[
d = k + l - s
\]

and the length of the direction vector.

## 3) Reducing to lattice point counts

For a given shape parameter `d`, the inradius formula implies a bound

\[
Q(p) \le \left\lfloor \frac{12R^2}{d^2} \right\rfloor
\]

for the direction vector `p`.

If `d` is divisible by `3`, every lattice direction `p` is allowed.
If `d` is not divisible by `3`, only an index‑3 sublattice is allowed; this is
handled by the scaling identity `Q((1-ω)z)=3Q(z)`, so the restricted count becomes
an unrestricted count with bound `floor(B/3)`.

Each primitive shape is generated with `k>l`; swapping the two side multipliers
creates a distinct reflected triangle, so a factor `2` is applied.

## 4) Fast counting of `Q(x,y) <= B`

Let `N(B)` be the number of integer pairs with `Q(x,y) <= B` (including the origin).
A standard identity expresses this as

\[
N(B) = 1 + 6 \sum_{d=1}^{B} \chi(d)\left\lfloor\frac{B}{d}\right\rfloor
\]

where `χ` is the nontrivial Dirichlet character modulo `3`
(`+1` on `1 mod 3`, `−1` on `2 mod 3`, `0` on multiples of `3`).

The sum is evaluated in `O(sqrt(B))` blocks by grouping equal values of
`floor(B/d)`. Prefix sums of `χ` are computed in `O(1)` because `χ` is periodic.

Results are memoized because many different shapes request the same bound.

## 5) Counting shape multiplicities

The code builds an array `M[d]` = number of primitive non-equilateral shapes that
produce the same `d`.

- **Family 1:** `d = 3uv`. For `t=uv`, the number of coprime unordered factor splits
  equals `2^{ω(t)-1}` where `ω(t)` is the number of distinct prime factors. `ω(t)` is
  computed by a sieve.
- **Family 2:** `d = (u-v)(u+2v) = a(a+3v)` with `a=u-v`. For each `v`, the range of
  feasible `a` is small for large `v`, so enumerating `(v,a)` is close to a harmonic
  series and stays fast. A `gcd` and a small modulus filter enforce primitiveness.

## 6) Equilateral triangles

Equilateral triangles must be handled separately because the “unique 60° vertex”
assumption fails. Fixing the incenter at the origin, each nonzero lattice point
`A` with `Q(A) <= floor(4R^2)` defines an equilateral triangle (vertices are
rotations of `A` by `120°`). The three choices of vertex correspond to the same
triangle, so the count is `(points - 1) / 3`.

## Complexity

Let `D = floor(sqrt(12) * R)`. Building `M[d]` is roughly `O(D log D)` due to the
sieve plus a harmonic enumeration. The point-count queries contribute about

\[
\sum_{d} O\!\left(\frac{\sqrt{12}R}{d}\right) = O(R \log R)
\]

in practice, and the full computation for `R = 10^6` runs comfortably on one core
in Python.
