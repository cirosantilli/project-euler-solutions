# Project Euler 849 Solution - The Tournament

<https://projecteuler.net/problem=849>:

* [849.py](849.py)

## Key observations

- Each pair of teams plays **two** games, and with scoring **2 / 1 / 0** the **total points awarded per game is always 2**, so the total awarded per pair is always **4**.
- Therefore, for each unordered pair `{i, j}`, the two teams’ *combined* points can be treated as a split
  \( (a_{ij}, a_{ji}) \) where \(a_{ij}\in\{0,1,2,3,4\}\) and \(a_{ij}+a_{ji}=4\).

This reduces the tournament to an integer matrix problem: choose \(a_{ij}\) for all pairs, then each team’s total score is the row sum.

## Landau-type characterization

For these “4-point tournaments”, the set of achievable **sorted** score sequences \(s_1\le\dots\le s_n\) is characterized by simple prefix-sum inequalities (an analogue of Landau’s theorem for ordinary tournaments):

- \(\sum_{i=1}^n s_i = 2n(n-1)\) (fixed total),
- and for every \(k\), \(\sum_{i=1}^k s_i \ge 2k(k-1)\).

Because the teams are **indistinguishable**, counting outcomes means counting such sorted score sequences.

## Turning global constraints into local constraints

Define a “staircase-shift” and its prefix sums:

- \(b_i = s_i - 4(i-1)\)
- \(p_i = \sum_{j=1}^i b_j\), with \(p_0 = p_n = 0\)

Then the prefix-sum inequalities become simply

- \(p_i \ge 0\) for all \(i\).

The nondecreasing condition on \(s_i\) becomes a **local second-difference constraint** on \(p\):

- \(2p_i - (p_{i-1} + p_{i+1}) \le 4\) for \(i=1..n-1\).

So \(F(n)\) equals the number of nonnegative integer sequences \(p_0..p_n\) with boundary values 0 and that local inequality.

## Dynamic programming

Let \(d_i = p_i - p_{i-1}\). The local inequality transforms to a simple “slope” rule:

- \(d_{i+1} \ge d_i - 4\).

We DP over `(height, last_slope)`:

- state after position \(i\): \((p_i, d_i)\)
- transition picks \(d_{i+1}\) satisfying the slope rule and keeps \(p_{i+1}=p_i+d_{i+1}\ge 0\).

A crucial speed trick is to update using **prefix sums over allowed previous slopes**, reducing the per-height work to \(O(V)\) where \(V = 4n-3\) is the slope range.

The code also uses a tight height bound \(p_i \le 2i(n-i)\), which keeps the DP tables small.

## Complexity

- Heights are \(O(n^2)\), slopes are \(O(n)\), and we iterate \(n\) positions.
- Overall time is about \(O(n^4)\) with a small constant; for \(n=100\) it runs comfortably in pure Python.
