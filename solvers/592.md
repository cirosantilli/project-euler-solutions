# Project Euler 592 Solution - Factorial Trailing Digits 2

<https://projecteuler.net/problem=592>:

* [592.py](592.py)

This solution computes **`f(20!)`** where, for any `N`, `f(N)` is the **last 12 hexadecimal digits before the trailing zeroes** in the hexadecimal expansion of `N!`.

## Main techniques used

### 1) Work modulo \(16^{12} = 2^{48}\)
Trailing hexadecimal zeroes come from factors of \(16=2^4\). Write
\[
N! = 2^{v_2(N!)} \cdot \text{odd}(N!)
\]
where `odd(N!)` is the odd part (remove all factors of 2). Removing all trailing hex zeroes is dividing by \(2^{4\lfloor v_2/4\rfloor}\), leaving an extra factor \(2^{v_2 \bmod 4}\). Therefore:
\[
 f(N) \equiv \text{odd}(N!) \cdot 2^{v_2(N!) \bmod 4} \pmod{2^{48}}.
\]

### 2) Compute the odd part via halving recursion
Using the identity
\[
\text{odd}(n!) = \text{odd}\bigl((\lfloor n/2\rfloor)!\bigr) \cdot \prod_{1\le i\le n,\ i\text{ odd}} i,
\]
we can compute `odd(n!) mod 2^48` by repeatedly halving `n` and multiplying by the product of odd numbers up to `n`.
This takes only \(O(\log n)\) steps.

### 3) Fast product of the first `r` odd numbers (mod \(2^{48}\))
We need
\[
\prod_{j=0}^{r-1} (2j+1) \pmod{2^{48}}
\]
for several large `r`.

To make a convergent 2-adic series possible, each factor is split into:
- a sign `±1` (depending on whether it’s `1 (mod 4)` or `3 (mod 4)`), and
- a **principal unit** congruent to `1 (mod 4)`.

On principal units, the **2-adic logarithm/exponential** series converge quickly modulo \(2^{48}\), so the product can be computed by summing logarithms and exponentiating.

### 4) Power sums using Stirling numbers (no modular division by even numbers)
The log-series needs sums like \(\sum_{j=0}^{n-1} j^m\) modulo \(2^{48}\).
Instead of Bernoulli/Faulhaber fractions (problematic mod a power of 2), we use the identity
\[
 j^m = \sum_{t=0}^m S(m,t) (j)_t
\]
with Stirling numbers of the second kind `S(m,t)` and falling factorials `(j)_t`.
Summing falling factorials yields integers via small binomial coefficients:
\[
 \sum_{j=0}^{n-1} (j)_t = \binom{n}{t+1} t!.
\]
Since all degrees here are at most 24, everything is fast and exact with integer arithmetic.

---

Running `main.py` prints the required 12-digit hexadecimal answer.
