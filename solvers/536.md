# Project Euler 536 Solution - Modulo Power Identity

<https://projecteuler.net/problem=536>:

* [536.py](536.py)

We want all integers `m ≤ N` such that for every integer `a`:

\[
a^{m+4} \equiv a \pmod m
\]

Let `S(N)` be the sum of all such `m`.

This solution computes `S(10^12)` in Python with no third‑party libraries and no parallelism.

---

## 1) Mathematical reductions

### Only one even solution
Taking `a = m-1` forces (for `m>2`) a contradiction unless `m` is odd.
So `m = 2` is the only even value that works.

### Squarefree requirement
If a prime square divides `m`, choosing a value of `a` that is nonzero modulo that prime power makes the congruence fail.
So every valid `m>2` must be **squarefree**.

### Prime-factor divisibility rule
For squarefree odd `m`, the condition reduces to the following for each prime factor `p | m`:

\[
(p-1)\ \mid\ (m+3)
\]

Equivalently, if we define

\[
\lambda(m) = \mathrm{lcm}\{\,p-1 : p \mid m\,\},
\]

then a squarefree `m` is valid exactly when:

\[
\lambda(m) \mid (m+3).
\]

### A safe gcd pruning
If a prime `r>3` divides both `m` and `\lambda(m)`, then `r` divides `m+3` as well, hence `r | 3`, impossible.
Therefore:

\[
\gcd(m,\lambda(m)) \in \{1,3\}.
\]

This property also holds for any partial product of prime factors of a valid `m`, making it a strong pruning rule during search.

### Case split when `3 ∤ m`
If `3` does not divide `m`, then `m+3` is not divisible by `3`.
But `p-1` must divide `m+3` for every prime factor `p`, so `p-1` cannot be divisible by `3`.
That implies all prime factors satisfy `p ≡ 2 (mod 3)`.
The program runs two searches:
- solutions divisible by `3`,
- solutions not divisible by `3` (restricted prime set).

---

## 2) Search strategy

We build squarefree products using a depth-first search over increasing primes while tracking:

- `x`: current product of chosen primes,
- `lam`: current `lcm(p-1)` over chosen primes.

Whenever `(x+3) % lam == 0`, `x` itself is a valid solution and is added to the sum.

### Handling the “last prime factor” efficiently
When looking for solutions of the form `x*q` where `q` is a *final* prime factor, we use two facts:

1. For the already-chosen primes, we need:
   \[
   \lambda \mid (xq+3) \iff xq \equiv -3 \pmod{\lambda}.
   \]
   This linear congruence yields an arithmetic progression `q ≡ r0 (mod step)`.

2. For the new prime factor `q`, its condition is:
   \[
   (q-1) \mid (xq+3) \iff (q-1) \mid (x+3),
   \]
   because `q ≡ 1 (mod q-1)`.

Also, if `q > sqrt(N/x)` then `x*q*q > N`, so `q` must be the last prime factor.
The implementation counts exactly these primes `q` using the arithmetic progression, checking primality by sieve.

This avoids scanning huge prime ranges and is the main performance win.

---

## 3) Implementation notes

- Primes are generated up to `2 + floor(sqrt(N+4))` using a bytearray sieve.
- Modular inverses are computed with Python’s built-in `pow(a, -1, mod)`.
- Two asserts are included for the statement’s provided test values:
  - `S(100) = 32`
  - `S(10^6) = 22868117`

Running the program prints `S(10^12)`.
