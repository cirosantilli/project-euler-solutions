# Project Euler 688 Solution - Piles of Plates

<https://projecteuler.net/problem=688>:

* [688.py](688.py)

We need:

- `f(n,k)`: maximum size of the smallest pile when splitting `n` plates into `k` **distinct positive** pile sizes
- `F(n) = Σ_k f(n,k)`
- `S(N) = Σ_{n=1..N} F(n)` for `N = 10^16` modulo `1_000_000_007`

## 1) Closed form for `f(n,k)`

If the smallest pile has size `m`, the lexicographically smallest distinct configuration is:

`m, m+1, ..., m+k-1`

This uses:

`k*m + k(k-1)/2`

So `m` is feasible iff:

`k*m + k(k-1)/2 ≤ n`

Therefore:

`f(n,k) = max(0, floor((n - k(k-1)/2)/k))`

## 2) Swap the order of summation to compute `S(N)`

Start from:

`S(N) = Σ_{n=1..N} Σ_{k≥1} f(n,k)`

Fix `k`, and count how often each `m` contributes:

- If `k*m + k(k-1)/2 ≤ n`, then the smallest pile can be at least `m`.
- For a fixed `(k,m)`, this holds for all `n` from that minimum up to `N`, i.e. for

`N - (k*m + k(k-1)/2) + 1`

values of `n`.

So:

`S(N) = Σ_k Σ_m (N+1 - (k*m + k(k-1)/2))` over all pairs satisfying the inequality.

For a fixed `k`, let:

- `b = k(k-1)/2`
- `q = floor((N - b)/k)` (the maximum feasible `m`)

Then the inner sum is an arithmetic series and collapses to:

`contribution(k) = q*(N+1-b) - k*q(q+1)/2`

Finally:

`S(N) = Σ_{k=1..kmax} contribution(k)`

where `kmax` is the largest `k` such that `k(k+1)/2 ≤ N`.

## 3) Implementation optimizations

The final algorithm is still `O(kmax) = O(√N)`, but it’s made fast in Python by:

- **Incremental triangular updates**:  
  Maintain `t = N - k(k-1)/2`. When `k` increments, the triangular term increases by `k`, so `t` decreases by `k`.
- **Avoid huge `% mod` in the loop**:  
  Maintain `t_mod = t % mod` incrementally with `t_mod -= k`.
- **Avoid `total %= mod` each iteration**:  
  Keep `total` in `[0, mod)` with one-step normalization after adding/subtracting.

The code also includes asserts for all sample values stated in the problem, plus brute-force cross-checks for small `N`.
