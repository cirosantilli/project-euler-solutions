# Project Euler 51 Solution - Prime Digit Replacements

<https://projecteuler.net/problem=51>:

* [51.py](51.py)

We search for the smallest prime that belongs to a family of **8 primes** formed by:
- choosing some digit positions (not necessarily adjacent),
- replacing all chosen positions with the same digit `0..9`,
- counting how many resulting numbers are prime (leading zero is not allowed).

## Key observations / optimizations

1. **The prime must be in its own family**
   If positions are replaced by digit `r`, then to regenerate the original prime `p`,
   all replaced positions in `p` must already contain the same digit.
   Therefore, for each prime we only consider subsets of positions where `p` has the same digit.

2. **Do not replace the last digit**
   If the last digit is replaced, most replacements produce even numbers or multiples of 5,
   so it is impossible to reach 8 primes out of 10. We skip any subset containing the last digit.

3. **Subset size multiple of 3 (mod 3 pruning)**
   Since `10^k ≡ 1 (mod 3)`, changing `k` digits changes the number mod 3 in a way that depends on `k mod 3`.
   If `k` is not a multiple of 3, at least 3 of the 10 replacements are divisible by 3, leaving too few slots
   to still have 8 primes. So we only test subsets with size `k % 3 == 0`.

4. **Fast family generation arithmetically**
   For a chosen digit `d` and subset of positions, precompute:
   - `shift = sum(10^(position_weight))` for those positions.
   Then replacement by `r` yields:
   - `new = p + (r - d) * shift`
   avoiding expensive string reconstruction.

## Algorithm
For increasing digit lengths:
- Sieve all primes up to `10^digits - 1`.
- For each prime, generate all valid position subsets (from repeated digits, excluding last digit, size multiple of 3).
- Count how many replacements are prime; once a subset yields ≥ 8 primes, return the prime.
