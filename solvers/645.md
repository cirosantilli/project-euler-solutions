# Project Euler 645 Solution - Every Day Is a Holiday

<https://projecteuler.net/problem=645>:

* [645.py](645.py)

This repository solves Project Euler problem 645 without external libraries.

## Main ideas

### 1) Poissonization (continuous-time view)

Instead of drawing emperors’ birthdays one-by-one (with replacement), assign each day an **independent exponential clock**:

- Day `i` gets its first “birthday event” at time `X_i ~ Exp(1)`.

Across all `D` days, events occur at total rate `D`, so:

- **Expected number of emperors up to completion time `T`** is `D * E[T]`.

That converts the original question into computing the expected **completion time** `T`.

### 2) What the holiday-closure rule means

The closure rule:

> if both neighbors of day `d` are holidays, then `d` becomes a holiday

implies that **a non-holiday day can only survive if it is part of a block of length ≥ 2**.
A single isolated non-holiday (pattern `H N H`) is immediately filled.

In the continuous-time model, for a fixed time `t`:

- A day is “not yet picked” with probability `p(t) = e^{-t}`.
- After closure, all days are holidays **iff** there are **no adjacent “not yet picked” days**.

So we need the probability that a cyclic length-`D` Bernoulli string with `P(1)=p` has **no adjacent 1s**.

### 3) Transfer matrix for “no adjacent 1s” on a cycle

Let `q_D(p)` be the probability that a length-`D` cycle has no adjacent 1s.

Use a 2-state transfer matrix (previous bit is 0 or 1):

\[
A = \begin{pmatrix}
1-p & p \\
1-p & 0
\end{pmatrix}
\]

The total weight of valid cyclic strings is:

\[
q_D(p) = \mathrm{trace}(A^D) = \lambda_1^D + \lambda_2^D
\]

where `λ1, λ2` are the eigenvalues of `A`.

### 4) Turning it into a 1D integral

Let `T` be the completion time. From above:

\[
P(T \le t) = q_D(e^{-t})
\]

Using the tail-integral identity:

\[
E[T] = \int_0^\infty P(T > t)\,dt
      = \int_0^\infty \bigl(1 - q_D(e^{-t})\bigr)\,dt
\]

Finally:

\[
E(D) = D \cdot E[T]
\]

### 5) Numerical integration (fast and precise)

The integrand is smooth and decays quickly (roughly like `D e^{-2t}`), so we truncate at a safe finite upper limit and evaluate it with **Gauss–Legendre quadrature**:

- 64-point Gauss–Legendre rule on each of a few sub-intervals of `[0, 25]`.

This achieves enough precision to round `E(10000)` to 4 decimals while running very fast.

## Files

- `main.py` — computes and prints `E(10000)` rounded to 4 decimals, and includes asserts for the given test values.
