# Project Euler 270 Solution - Cutting Squares

<https://projecteuler.net/problem=270>:

* [270.py](270.py)

## Key idea: turn the cutting process into a non‑crossing chord problem

All legal cut endpoints are integer lattice points on the **boundary** of an `N×N` square.

- Each boundary point lies on one side, except **corners**, which lie on **two** sides.
- A cut between two boundary points is legal iff the two points lie on **different sides**.
  A precise way to handle corners is:

> Represent each boundary point by the set of sides it lies on.
> A cut is legal iff these two side-sets are **disjoint**.

Now place the boundary points in their cyclic order on a **convex polygon** (a tiny perturbation keeps the order and removes collinearity). A straight cut becomes a chord.

- “Cuts do not cross” ⇔ chords are **non‑crossing**.
- “Proceed until no more legal cuts can be made” ⇔ the chord set is **maximal**:
  every remaining legal chord would cross an existing one.

Equivalently:

> The chords dissect the polygon into faces, and **each face contains no additional legal chord**.

## Faces must be *irreducible*

In any face (a polygon with some boundary vertices), if there exists a legal chord between two **non-adjacent** vertices of that face, then we could add it without crossing anything — contradicting maximality.

So each face must satisfy:

- For every pair of non‑adjacent vertices in the face, their side-sets **intersect**
  (i.e. the corresponding chord would be illegal).

This “irreducibility” constraint is strong and enables an efficient DP.

## Interval dynamic programming

Let the convex polygon have `M = 4N` vertices in order.

Define `dp[i][j]` as the number of maximal dissections of the subpolygon with vertices
`i, i+1, …, j` (inclusive), where the edge `(i, j)` is on the boundary of that subpolygon.

To compute `dp[i][j]`, look at the **unique face adjacent to the base edge `(i, j)`**.
That face uses a sequence of vertices:

`i = v0 < v1 < … < vk = j`

and contributes a product of independent subproblems:

`dp[v0][v1] * dp[v1][v2] * … * dp[v{k-1}][vk]`

Summing over all possible *irreducible* sequences gives `dp[i][j]`.

## A tiny “mask automaton” keeps enumeration fast

Every boundary point’s side-set is one of only **8** possibilities:

- 4 single sides: `B, R, T, L`
- 4 corner pairs: `BR, RT, TL, LB`

During enumeration of the base face boundary, we maintain an 8‑bit set `R` of which mask‑types
are still allowed for the **next** vertex so that the irreducibility constraints stay satisfied.

`R` only ever shrinks by intersections, so the number of reachable states is small.

## Complexity

- Number of vertices: `M = 4N` (for `N=30`, `M=120`)
- DP intervals: `O(M^2)`
- Each interval is solved with a small number of `(vertex, R)` states

This runs comfortably fast in Python and directly computes:

`C(30) mod 10^8 = 82282080`
