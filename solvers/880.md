# Project Euler 880 Solution - Nested Radicals

<https://projecteuler.net/problem=880>:

* [880.py](880.py)

This repository contains a dependency-free Python solution for Project Euler 880.
It computes:

- \(H(10^{15}) \bmod (1031^3+2)\)

The program prints the result and includes asserts for all explicit check values
from the problem statement.

## Core algebra

Let

\[
S = \sqrt[3]{a}+\sqrt[3]{b}+\sqrt[3]{c}.
\]

Squaring gives

\[
S^2 = \sqrt[3]{a^2}+\sqrt[3]{b^2}+\sqrt[3]{c^2} + 2\sqrt[3]{ab}+2\sqrt[3]{ac}+2\sqrt[3]{bc}.
\]

For \(S^2\) to equal \(\sqrt[3]{x}+\sqrt[3]{y}\) (exactly **two** cube-root terms), the six terms on the right must collapse.
Using linear independence of cube roots with different cube-free parts, the only way
this can happen is:

1. Terms group into three matching cube-root “types”, and
2. **One entire group cancels to zero**.

That cancellation forces one of the Diophantine relations

\[
a^2=-8bc,\quad b^2=-8ac,\quad c^2=-8ab.
\]

Because \(-8=(-2)^3\) is itself a cube, these relations align cube-root types perfectly.

## Parametrisation of primitive solutions

Solving (up to symmetry) yields two complete families of **primitive** integer triples.
At the level of \((x,y)\), it is convenient to re-parameterise so that a coprimality
test is cheap.

The implementation iterates two primitive families expressed with parameters \(p\) and \(s\):

### Family A
Start from a primitive triple with \(p\) odd and \(\gcd(p,q)=1\), then set \(s=q-2p\) so \(q=2p+s\):

\[
x = 4q\,s^3,\qquad y = p(9p+4s)^3.
\]

Here \(s\neq 0\) and \(\gcd(p,s)=1\) (since \(\gcd(p,q)=\gcd(p,s)\)).

### Family B
Start from the other primitive placement of the factor 2, requiring \(q\) odd and \(\gcd(p,q)=1\), then set \(s=q-4p\) so \(q=4p+s\):

\[
x = 4p(9p+2s)^3,\qquad y = q\,s^3.
\]

Here \(s\neq 0\), \(s\) is odd (so that \(q\) is odd), and \(\gcd(p,s)=1\).

Every nested radical pair arises from one of these primitive families (after symmetry),
plus the scaling described next.

## Square-scaling orbits

If \((x,y)\) works for some \((a,b,c)\), then for any integer \(k\ge 1\):

\[
(k^2x,\;k^2y)
\]

also works, witnessed by \((ka,kb,kc)\).

Therefore, for each **primitive** pair \((x_0,y_0)\) with \(|x_0|\le |y_0|\), all valid pairs in its orbit that satisfy
\(|y|\le N\) are obtained by choosing

\[
1 \le k \le \left\lfloor\sqrt{\frac{N}{|y_0|}}\right\rfloor.
\]

The contribution of an orbit is

\[
(|x_0|+|y_0|)\sum_{k=1}^{K}k^2,
\qquad
\sum_{k=1}^{K}k^2 = \frac{K(K+1)(2K+1)}{6}.
\]

This turns the problem into:

- enumerate primitive base pairs once,
- compute \(K\) and add the closed-form sum of squares.

## Avoiding double counting

Different parameters can sometimes generate the same canonical pair (due to symmetry).
The solver:

- canonicalises each pair so \(|x|\le |y|\),
- deduplicates using a `set` of encoded signed pairs.

## Filtering rational cube ratios

The problem excludes pairs where \(x/y\) is a rational cube.
After reducing the fraction, this holds iff both numerator and denominator are
perfect integer cubes (allowing a negative numerator).

A fast cube test combines small modular filters (mod 9, 7, 13) with an exact
integer cube-root refinement.

## Tests

The code asserts:

- the example pairs `(-4,125)` and `(5,5324)` are generated,
- `H(10^3) = 2535`.
