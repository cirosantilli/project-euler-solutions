# Project Euler 649 Solution - Low-Prime Chessboard Nim

<https://projecteuler.net/problem=649>:

* [649.py](649.py)

This solution computes the last **9 digits** of:

\[
M(10\,000\,019, 100)
\]

where `M(n, c)` counts the number of starting arrangements of `c` distinct coins on an `n × n` board for which the first player has a winning strategy, under the move rules (left or up by 2, 3, 5, or 7).

## Key techniques

### 1) Sprague–Grundy theorem (impartial games ⇒ Nim)
Each coin position is an **impartial normal-play game**. With multiple coins, a move affects exactly one coin, so the whole position is the **disjunctive sum** of the coin games.

By Sprague–Grundy, every position has a nimber (Grundy number), and the full game is winning for the next player iff:

\[
\text{nimber}_1 \oplus \text{nimber}_2 \oplus \cdots \oplus \text{nimber}_c \neq 0
\]

So we just need to count how many starting arrangements have XOR ≠ 0.

### 2) Separating the 2D coin into two 1D subtraction games
A single coin on `(x, y)` can only move **left** (change `x`) or **up** (change `y`), never both.

That means the 2D game is the sum of two independent 1D subtraction games on coordinates:

- 1D positions `t` allow moves `t → t-2, t-3, t-5, t-7` (when non-negative)
- Let `g(t)` be the 1D Grundy value
- Then for a coin on the board:

\[
G(x, y) = g(x) \oplus g(y)
\]

So we only need the frequency distribution of `g(t)` over `t = 0..n-1`.

### 3) Fast Grundy computation with a tiny mex table and a ring buffer
For subtraction games, each state’s Grundy value is:

\[
g(t) = \operatorname{mex}(\{g(t-2), g(t-3), g(t-5), g(t-7)\})
\]

There are at most 4 options, so `g(t) ≤ 4`. The implementation:

- Encodes the option set as a 5-bit mask
- Uses a precomputed `mex(mask)` table for constant-time mex
- Uses an 8-slot circular buffer to access `t-2, t-3, t-5, t-7` without storing all `n` values

This makes the `O(n)` pass over `n = 10,000,019` practical in pure Python.

### 4) Counting winning arrangements via XOR-convolution exponentiation
Let `a[k]` be the number of board squares with coin nimber `k` (for `k = 0..7`).

For `c` independent coins, the distribution of the XOR of their nimbers is the **c-fold XOR convolution** of `a` with itself. We only need the `xor = 0` entry.

Because the vector length is just 8, we compute the convolution power using **binary exponentiation** (repeated squaring), with each convolution costing only `8×8 = 64` multiply-adds modulo `10^9`.

Finally:

- `losing = count(xor == 0)`
- `total = (n^2)^c`
- `M = total - losing (mod 10^9)`

## Files

- `main.py` — computes the answer and includes asserts for the sample values:
  - `M(3,1) = 4`
  - `M(3,2) = 40`
  - `M(9,3) = 450304`
