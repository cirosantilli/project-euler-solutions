#!/usr/bin/env python3
"""
Project Euler 583 â€” Heron Envelopes
----------------------------------

Let w be the rectangle width, h the rectangle height, and the flap be an
isosceles triangle with base w and equal sides s. All sides are integral, and
all diagonals AC, AD, BD, BE, CE are integral. Also the flap height must be
smaller than the rectangle height.

Key simplification:
Let a = w/2 (it turns out w must be even, hence a is integer).
Let t be the flap height (integer).

Then the conditions become three Pythagorean conditions:

(1) a^2 + t^2 = s^2
(2) a^2 + (h + t)^2 = e^2   (AC and CE)
(3) (2a)^2 + h^2 = d^2      (rectangle diagonals AD and BE)

Let u = h + t. Then (2) says (a, u) is a Pythagorean leg-pair.

Perimeter:
P = w + 2h + 2s = 2a + 2h + 2s = 2(a + h + s)

So we want S(p) = sum of perimeters of all valid envelopes with P <= p.

Algorithm outline:
1) Build adjacency lists U[a] = {u | a^2 + u^2 is a square}, for 1 <= a,u <= N,
   where N = p/2.
2) Enumerate all Pythagorean triples (a, t, s) with s <= N (again using Euclid)
   and treat them as flap-half triangles.
3) For each (a, t, s), search u in U[a] that satisfy:
       u > 2t   (equivalent to h = u - t > t)
       h = u - t <= N - a - s  (perimeter feasibility)
   Then test rectangle condition (2a)^2 + h^2 is a square.
4) Add perimeter 2(a + h + s).

No external libraries are used (only Python stdlib).
"""

import math
from array import array


def primitive_leg_pairs(max_leg: int):
    """
    Return all primitive Pythagorean leg pairs (a,b) with a<b and b <= max_leg,
    generated by Euclid's formula.
    """
    prims = []
    gcd = math.gcd
    isqrt = math.isqrt

    # For primitive triples, max leg b = 2mn or m^2-n^2
    mmax = isqrt(2 * max_leg) + 1
    for m in range(2, mmax + 1):
        mm = m * m
        # opposite parity => m-n is odd
        n_start = 1 if (m & 1) == 0 else 2
        for n in range(n_start, m, 2):
            if gcd(m, n) != 1:
                continue
            a = mm - n * n
            b = 2 * m * n
            if a > b:
                a, b = b, a
            if b <= max_leg:
                prims.append((a, b))
    return prims


def build_u_csr(N: int):
    """
    Build CSR adjacency lists U[a] = all u such that a^2 + u^2 is a square,
    with 1 <= a,u <= N.

    Returns (offset, vals) where vals[offset[a]:offset[a+1]] are the u-values
    corresponding to a.

    Lists are unsorted; we just scan (degrees are small on average).
    """
    prims = primitive_leg_pairs(N)

    counts = array("I", [0]) * (N + 1)

    # Count edges
    for a0, b0 in prims:
        kmax = N // b0
        a = a0
        b = b0
        for _ in range(kmax):
            counts[a] += 1
            counts[b] += 1
            a += a0
            b += b0

    # Prefix sums -> offsets
    offset = array("I", [0]) * (N + 2)
    total = 0
    for i in range(N + 1):
        total += counts[i]
        offset[i + 1] = total

    vals = array("I", [0]) * total
    cursor = offset[:]  # insertion positions per row

    # Fill edges
    for a0, b0 in prims:
        kmax = N // b0
        a = a0
        b = b0
        for _ in range(kmax):
            ia = cursor[a]
            vals[ia] = b
            cursor[a] = ia + 1

            ib = cursor[b]
            vals[ib] = a
            cursor[b] = ib + 1

            a += a0
            b += b0

    return offset, vals


def S(p: int) -> int:
    """
    Compute S(p) as defined in the problem.
    """
    N = p // 2
    offset_u, uvals = build_u_csr(N)

    isqrt = math.isqrt
    gcd = math.gcd

    def is_square(x: int) -> bool:
        r = isqrt(x)
        return r * r == x

    total = 0

    # Enumerate primitive triples with hypotenuse <= N (since s must satisfy perimeter)
    mmax = isqrt(N) + 1
    for m in range(2, mmax + 1):
        mm = m * m
        n_start = 1 if (m & 1) == 0 else 2
        for n in range(n_start, m, 2):
            if gcd(m, n) != 1:
                continue

            a0 = mm - n * n
            b0 = 2 * m * n
            c0 = mm + n * n  # hypotenuse

            if c0 > N:
                continue
            if a0 > b0:
                a0, b0 = b0, a0

            kmax = N // c0
            a = a0
            b = b0
            c = c0

            for _ in range(kmax):
                # --- orientation 1: (A=a, T=b, S=c)
                A = a
                T = b
                start = offset_u[A]
                end = offset_u[A + 1]
                if start != end:
                    h_max = N - A - c
                    if h_max > T:
                        lo = 2 * T + 1
                        hi = T + h_max
                        fourA2 = (A * A) << 2
                        per_base = 2 * (A + c)
                        for u in uvals[start:end]:
                            if u < lo or u > hi:
                                continue
                            h = u - T
                            if h <= T or h > h_max:
                                continue
                            if is_square(fourA2 + h * h):
                                total += per_base + 2 * h

                # --- orientation 2: (A=b, T=a, S=c)
                A = b
                T = a
                start = offset_u[A]
                end = offset_u[A + 1]
                if start != end:
                    h_max = N - A - c
                    if h_max > T:
                        lo = 2 * T + 1
                        hi = T + h_max
                        fourA2 = (A * A) << 2
                        per_base = 2 * (A + c)
                        for u in uvals[start:end]:
                            if u < lo or u > hi:
                                continue
                            h = u - T
                            if h <= T or h > h_max:
                                continue
                            if is_square(fourA2 + h * h):
                                total += per_base + 2 * h

                a += a0
                b += b0
                c += c0

    return total


def solve() -> int:
    # Provided test value in the statement
    assert S(10**4) == 884680
    return S(10**7)


if __name__ == "__main__":
    print(solve())
