# Project Euler 626 Solution - Counting Binary Matrices

<https://projecteuler.net/problem=626>:

* [626.py](626.py)

We want `c(n)`: the number of equivalence classes of `n×n` binary matrices under

- swapping any two rows
- swapping any two columns
- flipping (bitwise complementing) any single row
- flipping any single column

The required output is `c(20) mod 1_001_001_011`.

---

## Main techniques

### 1) Group action + Burnside’s lemma

The operations form a group:

- row operations: `S_n ⋉ (Z₂)^n` (permute rows + optionally flip each row)
- column operations: `S_n ⋉ (Z₂)^n`

The full action is the direct product of row and column groups acting on the matrix entries.

`c(n)` equals the number of orbits of this action, so by Burnside:

\[
c(n)=\frac{1}{|G|}\sum_{g\in G} |\mathrm{Fix}(g)|
\]

So the problem becomes: for each group element, count how many matrices stay unchanged.

---

### 2) Product permutation cycles

A group element contains a row permutation `π_r` and a column permutation `π_c`.

Together they permute the `n²` positions `(i,j)` by the **product permutation**
\[
\sigma(i,j)=(\pi_r(i),\pi_c(j))
\]

If `π_r` has cycles of lengths `a` and `π_c` has cycles of lengths `b`, then inside the `a×b` block the product permutation splits into

- `gcd(a,b)` cycles
- each of length `lcm(a,b)`

Hence the total number of cycles of `σ` is

\[
\#\text{cycles}(\sigma) = \sum_{\text{row cycle }A}\sum_{\text{col cycle }B} \gcd(|A|,|B|)
\]

This depends only on the cycle type (partition of `n`) of the two permutations.

---

### 3) Handling flips via parity constraints (only 2-adic valuations matter)

Row/column flips add an XOR “offset” to the fixed-point equations. Along any cycle of `σ`, consistency requires the XOR of the offsets around the cycle to be `0`.

For a row cycle of length `a` and column cycle of length `b`, the constraint depends only on

- the parity of flips within that row cycle
- the parity of flips within that column cycle
- the relative powers of 2 in `a` and `b` (their `v₂` values)

Let `v₂(x)` be the exponent of 2 in `x`. Then:

- if `v₂(a) > v₂(b)`, the row-cycle parity must be `0`
- if `v₂(a) < v₂(b)`, the column-cycle parity must be `0`
- if `v₂(a) = v₂(b)`, the two parities must be equal

Because these constraints apply for **every** row-cycle/column-cycle pair, they collapse to a tiny set of cases determined by the minimum `v₂` on each side. This yields a simple count `2^d` for how many parity assignments are allowed.

---

### 4) Summing over conjugacy classes using integer partitions

Everything depends only on the cycle type of `π_r` and `π_c`, i.e. partitions of `n`.
There are only `p(20)=627` partitions, so we can sum over all `(partition_row, partition_col)` pairs.

For a partition with multiplicities `m_l` of cycle length `l`, the number of permutations is

\[
\frac{n!}{\prod_l l^{m_l} m_l!}
\]

The final Burnside sum is computed modulo `1_001_001_011`.

---

## Complexity

- partitions of 20: 627
- pairs: 627² ≈ 3.9×10⁵
- per pair: small loops over distinct cycle lengths (at most 20)

This runs comfortably fast in pure Python.

---

## Output

Running `python3 main.py` prints the answer for `n=20` modulo `1_001_001_011`.
