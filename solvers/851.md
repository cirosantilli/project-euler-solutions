# Project Euler 851 Solution - SOP and POS

<https://projecteuler.net/problem=851>:

* [851.py](851.py)

This repository contains a standalone `main.py` that computes
\(R_6(10000!)\) modulo \(10^9+7\), with no third‑party libraries.

## 1) Turning the definition into a coefficient extraction

For one coordinate, the weight is
\((u_i+v_i)\) and the constraint is \(u_i v_i\).
If \(m=u_i v_i\), then summing over all factor pairs gives

\[
\sum_{u_iv_i=m} (u_i+v_i)
= \sum_{d\mid m} \left(d+\frac{m}{d}\right)
= 2\sum_{d\mid m} d
= 2\,\sigma_1(m).
\]

Define the power series
\[
F(q)=\sum_{m\ge 1} 2\sigma_1(m)q^m.
\]
Because the dot product constraint is additive,
\(R_n(M)\) is exactly the coefficient

\[
R_n(M) = [q^M]\,F(q)^n.
\]

## 2) Expressing \(F(q)\) using the Eisenstein series \(E_2\)

The (quasi)modular Eisenstein series satisfies

\[
E_2(q)=1-24\sum_{m\ge 1}\sigma_1(m)q^m.
\]

So
\[
F(q)=\frac{1-E_2(q)}{12},
\qquad
R_n(M)=[q^M]\,\frac{(1-E_2(q))^n}{12^n}.
\]

This reduces the problem to computing coefficients of powers \(E_2(q)^k\).

## 3) Avoiding huge convolutions with Ramanujan’s differential relations

Directly expanding \(E_2^k\) would involve large convolution sums.
Instead, the code uses that the ring generated by Eisenstein series is closed
under the operator
\(D = q\frac{d}{dq}\), and Ramanujan’s differential system relates derivatives
of \(E_2,E_4,E_6\) back to polynomials in Eisenstein series.

For \(k\le 6\), each \(E_2^k\) can be written as a *short linear combination* of:

- a single Eisenstein series \(E_{2k}\),
- a few derivatives \(D^r(E_m)\) (whose coefficients are just \(n^r\) times divisor sums),
- and, only for weight 12, the cusp form \(\Delta\).

That means the coefficient of \(E_2^k\) at a specific index \(M\) can be computed
from:

- \(M^r \bmod p\) for small \(r\),
- divisor sums \(\sigma_s(M)\) for \(s\in\{1,3,5,7,9,11\}\),
- and \(\tau(M)\) (Ramanujan’s tau), the coefficient of \(\Delta\).

No term requires iterating up to \(M\).

## 4) Fast arithmetic at \(M=10000!\)

### Divisor sums

For a factorization \(M=\prod p^{e_p}\),

\[
\sigma_s(M)=\prod_p \frac{p^{s(e_p+1)}-1}{p^s-1}.
\]

For \(10000!\), the exponents \(e_p=v_p(10000!)\) are computed by the standard
Legendre formula \(\sum_{t\ge1}\lfloor 10000/p^t\rfloor\).
All computations are performed modulo \(10^9+7\).

### Ramanujan tau at a factorial

The tau function is multiplicative, so
\(\tau(\prod p^{e_p})=\prod \tau(p^{e_p})\).

The code obtains \(\tau(p)\) for all primes \(p\le 10000\) by a recurrence coming
from the identity
\(D(\Delta)=E_2\Delta\), then uses the prime‑power recurrence

\[
\tau(p^{k+1})=\tau(p)\tau(p^k)-p^{11}\tau(p^{k-1})
\]

with fast exponentiation (2×2 matrix powering) to evaluate \(\tau(p^{e_p})\)
for large exponents \(e_p\).

## 5) Built-in checks

The problem statement provides three reference values.
`main.py` computes those and asserts they match before printing the final result.

---

Run:

```bash
python3 main.py
```
