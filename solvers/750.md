# Project Euler 750 Solution - Optimal Card Stacking

<https://projecteuler.net/problem=750>:

* [750.py](750.py)

This repository contains a clean Python (no external libraries) solution to **Project Euler 750**.

## Core Observations

### 1. Stack-merge direction is forced
Dragging stack `A` onto stack `B` places `A` *on top* of `B`.  
A merge is valid only if the resulting stack is consecutive **top-to-bottom increasing**:

- If `A = [l..k]` and `B = [k+1..r]`, then the merge is valid.
- Cost is the horizontal drag distance between their current positions.

### 2. The stack's position is determined by its maximum label
The bottom-most card is always the largest value in that stack.  
Because smaller stacks must be placed on top of larger ones, the final merged stack `[l..r]`
must remain located at the position of card `r`.

This removes positional ambiguity and makes dynamic programming feasible.

---

## Dynamic Programming

Let:

- `pos[x]` be the array position of label `x`.
- `dp[l][r]` be the minimal drag cost to build stack `[l..r]`.

Then the final merge for `[l..r]` must split at some `k`:

- Build `[l..k]`
- Build `[k+1..r]`
- Drag `[l..k]` onto `[k+1..r]`

This yields:

\[
dp[l][r] = \min_{k=l}^{r-1} \left( dp[l][k] + dp[k+1][r] + |pos[k]-pos[r]| \right)
\]

Answer is `dp[1][N]`.

---

## Optimization Used

A naive DP would still work but we reduce overhead by:

- Processing by increasing right endpoint `r`
- Maintaining a small local cache `col[i] = dp[i][r]`

This avoids repeated 2D lookups for `dp[k+1][r]`, improving constant factors while keeping
the same mathematical recurrence.

---

## Correctness Checks

The program asserts:

- `G(6) = 8`
- `G(16) = 47`

as stated in the problem.

---

## Running

```bash
python3 main.py
