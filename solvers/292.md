# Project Euler 292 Solution - Pythagorean Polygons

<https://projecteuler.net/problem=292>:

* [292.py](292.py)

A **pythagorean polygon** is a *convex* polygon with:

- at least 3 vertices,
- no three vertices collinear,
- integer coordinates for every vertex,
- integer length for every edge.

Let `P(n)` be the number of such polygons (distinct up to translation) with perimeter `≤ n`.

The problem asks for `P(120)` and provides:

- `P(4)  = 1`
- `P(30) = 3655`
- `P(60) = 891045`

---

## Core ideas used in `main.py`

### 1) Integer edge length ⇒ Pythagorean lattice vectors
An edge from `(x1,y1)` to `(x2,y2)` is a lattice vector `(dx,dy)`.

Its length is integer iff:

\[
dx^2 + dy^2 = c^2
\]

for some integer `c`. So every allowed direction comes from a (possibly scaled) **Pythagorean triple**.

The code generates **primitive** triples with Euclid’s formula and then allows integer scaling.

Axis-aligned edges `(k,0)` and `(0,k)` are included separately (they correspond to `c=1`).

---

### 2) Convex polygon ↔ edge vectors sorted by angle
A key geometric fact:

> If a set of edge vectors sums to zero and you traverse them in increasing polar angle order,
> the resulting closed walk is a convex polygon (strictly convex if no direction repeats).

So we can count polygons by counting **sets of directed edge vectors** that:

- have distinct directions (enforced by choosing **at most one** scaled vector per primitive direction),
- sum to `(0,0)`,
- total perimeter `≤ n`.

This automatically handles “distinct up to translation”, because translations don’t change edge vectors.

---

### 3) Split into upper/lower half-planes + symmetry
Partition directions by the sign of `dy`:

- **upper half**: `dy > 0` plus the `+x` axis,
- **lower half**: the negations of the upper directions.

If the upper selection sums to displacement `v`, then the lower selection must sum to `-v`.

By symmetry, “#ways to get `v` in upper” = “#ways to get `-v` in lower”, so the code computes a DP
for the upper half only and matches equal displacements during the final count.

---

### 4) 2D knapsack-style DP with perimeter constraint
For the upper half-plane, we do:

- state: `(perimeter, displacement)` → number of ways
- transition: for each primitive direction, either skip it or pick exactly one scale `s ≥ 1`

The DP is stored as `dp[p] = {displacement_key: count}`.

A compact integer key encodes `(x,y)` to make dictionary operations cheaper.

---

### 5) Subtract degenerate “polygons”
The raw DP convolution includes two invalid cases:

- the empty selection (0 edges),
- a 2-edge back-and-forth segment `(v, -v)`.

These are subtracted explicitly.

---

## Result
Running `main.py` prints the answer to the original problem:

- `P(120) = 3600060866`

The script also asserts the three values given in the problem statement.
