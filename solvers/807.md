# Project Euler 807 Solution - Loops of Ropes

<https://projecteuler.net/problem=807>:

* [807.py](807.py)

This solution computes

- **P(n)** = probability that the two closed loops (red and blue) can be separated,
- and prints **P(80)** rounded to **10 digits after the decimal point**.

## Key idea

Although the points are chosen continuously on a circle, only their **cyclic order** matters (ties happen with probability 0). The “new rope lies above all previous ropes” rule gives a well-defined over/under pattern, and the question “split vs linked” reduces to a purely **combinatorial count**.

For this construction one can show that:

\
**P(n) = A(2n−1, n) / (2n−1)!**

where **A(m, k)** is an **Eulerian number** (counting permutations of `m` items with a prescribed number of ascents/descents). The numerator is the *central Eulerian number* often indexed as **OEIS A025585(n)**.

So the entire problem becomes: compute a single Eulerian number exactly, then divide by a factorial and round.

## Computing the central Eulerian number

We use the classic alternating-sum formula (an inclusion–exclusion style expression for Eulerian numbers):

\
`a(n) = Σ_{j=0..n} (−1)^j * C(2n, j) * (n−j)^(2n−1)`

This yields an exact integer with Python’s built-in big integers.

## Rounding

To avoid floating-point error, the program performs rounding using **exact integer arithmetic**:

- compute `floor(P(n) * 10^digits)` and its remainder,
- apply **half-up** rounding based on whether the remainder is at least half the denominator.

## Complexity

For `n = 80` the sum has only 80 terms, each involving a power with exponent 159, so it runs quickly:

- Time: `O(n)` big-integer power/multiply operations
- Memory: `O(1)` aside from big integers
