# Project Euler 519 Solution - Tricoloured Coin Fountains

<https://projecteuler.net/problem=519>:

* [519.py](519.py)

## What the program computes

Let `T(n)` be the total number of **proper 3‑colourings** over **all** coin fountains that use exactly `n` coins (coins touching must have different colours).  
Project Euler 519 asks for the **last 9 digits** of `T(20000)`.

The provided `main.py` prints that 9‑digit value.

It also includes the statement’s check values:

- `T(4) = 48`
- `T(10) = 17760`

## Main techniques used

### 1) Dynamic programming with a Catalan/Dyck encoding

Coin fountains can be encoded by a Dyck/Catalan “boundary growth” process in which we append a new “column” of height `k`, and:

- the total coin count increases by `k`, and
- the next column height can increase by **at most 1** compared to the previous height.

This leads to a compact 2‑parameter DP table:

- `dp[s][h]` = aggregated number of valid 3‑colourings over all fountains of size `s` that end in boundary‑height `h`.

Recurrence:

- Base: `dp[1][1] = 3`
- Transition (add a column of height `k`): for `1 ≤ k ≤ h+1`

  `dp[s+k][k] += dp[s][h] * w(h,k)`

  with a small weight:

  - `w(h,k) = 2` if `h == 1` or `k == 1`
  - `w(h,k) = 1` otherwise

Finally:

- `T(n) = sum_{h : h*h ≤ 2n} dp[n][h]`

The bound `h*h ≤ 2n` is safe because reaching height `h` needs at least `1+2+…+h = h(h+1)/2` coins.

### 2) Suffix‑sum optimisation (reducing an inner loop)

A direct implementation of the transition would be `O(n * H^2)` with `H ≈ √(2n)`.

Notice that for fixed `s`, updates to a given `k` depend on a **suffix sum** of `dp[s][h]`:

- For `k ≥ 3`: only `h ≥ k-1` contribute, all with weight `1`
- For `k = 1`: everyone contributes with weight `2`
- For `k = 2`: everyone contributes, but `h=1` has weight `2`

So we compute once per `s`:

`S[t] = sum_{h ≥ t} dp[s][h]`

and update all `k` in `O(H)` time.  
Overall complexity becomes **`O(n * √n)`**.

### 3) Rolling buffer to keep memory small

Updates only jump forward by at most `H`, so we only need to keep a window of about `H` DP rows.  
`main.py` uses a circular buffer of size `H+3`, bringing memory down to `O(H^2)`.

## Complexity

For `n = 20000`:

- `H ≈ √(40000) ≈ 200`
- Time: `O(n √n)` (fast in Python)
- Memory: `O(√n²)` (a few tens of thousands of integers)

## Running

```bash
python3 main.py
```

Optional: run for a different `n`:

```bash
python3 main.py 10
```
