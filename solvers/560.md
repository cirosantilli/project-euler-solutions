# Project Euler 560 Solution - Coprime Nim

<https://projecteuler.net/problem=560>:

* [560.py](560.py)

This solution computes

\[
L(n,k) = \#\{(a_1,\dots,a_k)\in[1,n-1]^k : \text{starting position is losing}\}
\]

for **Coprime Nim**, and prints \(L(10^7,10^7)\bmod 1\,000\,000\,007\).

## 1) Grundy numbers

Coprime Nim is an impartial game, so a position with multiple piles is losing iff the xor of the piles’ **Grundy numbers** is 0.

A move from a pile of size \(m\) removes \(r\) stones where \(\gcd(r,m)=1\), leaving \(m-r\).

Let \(g(m)\) be the Grundy number of a single pile of size \(m\).

### Closed form for \(g(m)\)

One can show:

- \(g(0)=0\), \(g(1)=1\)
- if \(m\) is even, then **\(g(m)=0\)**
- if \(m\) is odd and \(m>1\), let \(p=\operatorname{spf}(m)\) be the smallest prime factor of \(m\), then

\[
g(m)=\pi(p)
\]

where \(\pi(p)\) is the **prime index**: \(\pi(2)=1,\ \pi(3)=2,\ \pi(5)=3,\dots\).

**Why this works (sketch):**

- If \(m\) is even, every legal removal \(r\) is odd, so every reachable pile size \(m-r\) is odd, and their Grundy values are \(\ge 1\). Thus 0 is missing and \(\mathrm{mex}=0\).
- If \(m\) is odd with smallest prime factor \(p\):
  - There exist legal moves to even pile sizes, so Grundy 0 is reachable.
  - For every smaller prime \(q<p\), \(q\) is coprime to \(m\), so removing \(q\) is legal and reaches a position whose Grundy value is \(\pi(q)\).
  - Any reachable \(m-r\) is coprime to \(m\), hence **not divisible by \(p\)**, so its smallest prime factor is \(<p\), meaning its Grundy value is at most \(\pi(p)-1\).
  - Therefore values \(\{0,1,\dots,\pi(p)-1\}\) are reachable while \(\pi(p)\) is not, so \(\mathrm{mex}=\pi(p)\).

So counting losing positions reduces to counting how many pile sizes have each smallest prime factor.

## 2) Counting losing k-tuples via XOR convolution + FWHT

Let `c[g]` be the number of pile sizes in \([1,n-1]\) with Grundy value `g`.

A k-pile starting position is losing iff

\[
g(a_1)\oplus g(a_2)\oplus \cdots \oplus g(a_k)=0.
\]

So \(L(n,k)\) is exactly the k-fold **XOR convolution** of `c` evaluated at index 0.

The **Walsh–Hadamard Transform (FWHT)** diagonalizes XOR convolution:

- Let \(C = \mathrm{FWHT}(c)\) (unnormalized).
- The FWHT of the k-fold XOR convolution is \(C_i^k\) pointwise.
- The inverse transform at index 0 equals the **average**:

\[
L(n,k) = \frac{1}{M}\sum_{i=0}^{M-1} C_i^k \pmod{10^9+7},
\]

where \(M\) is the transform size (a power of two large enough to hold all Grundy values).

## 3) Odd-only sieve for smallest prime factors

To build `c` up to \(n=10^7\):

- Count all even pile sizes directly → contributes to `c[0]`.
- Sieve only odd numbers up to \(n-1\), storing `spf` for odds.
- When discovering an odd prime \(p\), mark each *previously unmarked* odd multiple starting at \(p^2\); each first mark increments the count of numbers whose smallest prime factor is \(p\).
- After sieving up to \(\sqrt{n}\), all remaining unmarked odds (excluding 1) are primes \(>\sqrt{n}\) and each contributes 1.

This yields `c[pi(p)]` for every odd prime \(p\).

## Complexity

For \(n=10^7\):

- Sieve: \(O(n\log\log n)\) time, \(O(n/2)\) memory (odd-only `spf`).
- FWHT: \(O(M\log M)\) with \(M\approx 2^{20}\).
- Final sum: \(O(M)\) modular exponentiations using Python’s built-in `pow`.

The code includes `assert`s for all sample values from the problem statement.
