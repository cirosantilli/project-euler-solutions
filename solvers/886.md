# Project Euler 886 Solution - Coprime Permutations

<https://projecteuler.net/problem=886>:

* [886.py](886.py)

This solution counts permutations of `{2,3,…,n}` where every adjacent pair is coprime.

## 1) Parity forcing: the key simplification
All even numbers share a factor of `2`, so **no two evens can be adjacent** in any valid permutation.

For `n = 34`, there are 17 evens and 16 odds in `{2,…,34}`, so any valid permutation must alternate parity and must start and end with an even:
`E O E O … O E`.

This removes all “odd–odd” and “even–even” adjacency checks; only **even–odd** edges matter.

## 2) Prime-mask compression
For an even `e` and an odd `o`, `gcd(e,o)=1` fails exactly when they share an odd prime factor.

Only odd primes that appear among the **even** numbers can ever block an even–odd adjacency.
So we build a *relevant prime set* from the odd prime factors of the evens, and represent each number by a bitmask over these primes.

Numbers with the same mask have identical compatibility behavior across parity, so we compress them into **types** `(mask → count)`.

## 3) Counting alternating type-sequences with DP
We count alternating sequences of these types using each type exactly its multiplicity, enforcing:
`(even_mask & odd_mask) == 0` for every adjacent even/odd pair.

The DP state is:
- last chosen type on the current parity
- remaining counts of even types
- remaining counts of odd types

To make states fast and hash-friendly, remaining count vectors are encoded into integers using a mixed-radix index, and transitions use precomputed decrement tables.

## 4) Restoring distinct labels
The DP counts sequences where items within the same mask-type are indistinguishable.
To get permutations of actual numbers, multiply by `∏ factorial(count_of_type)` over both parities.

## 5) Correctness checks
The implementation asserts the two values given in the statement:
- `P(4) = 2`
- `P(10) = 576`

Then it prints `P(34) mod 83,456,729`.
