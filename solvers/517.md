# Project Euler 517 Solution - A Real Recursion

<https://projecteuler.net/problem=517>:

* [517.py](517.py)

This repo contains a self-contained Python solution (no external libraries) for Project Euler 517.

## Key ideas

### 1) Re-interpret the recursion as counting step sequences
For a fixed `a > 1`, the recursion

- `g_a(x) = 1` for `x < a`
- `g_a(x) = g_a(x-1) + g_a(x-a)` for `x >= a`

can be read as:

> Starting from `x`, you may subtract either `1` or `a` while you remain `>= a`.  
> Once you drop below `a`, the process stops.

So `g_a(n)` counts the number of valid step sequences (choices of `1` or `a`) whose running total first exceeds the threshold `n - a`.

For this problem `a = sqrt(n)`.

### 2) Split by the **last step** (the one that crosses the threshold)
Let `s = n - sqrt(n)`.

A sequence stops exactly when its partial sum first becomes `> s`. The last step is either:

- **Last step = 1**  
  For each `i` = number of `sqrt(n)`-steps before the last step, there is a unique
  `c = floor(n - (i+1)*sqrt(n))` giving the number of `1`-steps before the last step.
  The number of sequences is a binomial coefficient `C(c+i, i)`.

- **Last step = sqrt(n)**  
  For each `c` = number of `sqrt(n)`-steps before the last step, the admissible number
  of `1`-steps `k` lies in an interval `[L, U]`, and the count is `C(k+c, c)`.  
  Summing over `k` is done with the **hockey-stick identity**:
  `sum_{k=L..U} C(k+c, c) = C(c+U+1, c+1) - C(c+L, c+1)`.

Both parts run in `O(sqrt(n))` time per `n`.

### 3) Exact floor computations using integer square roots
To avoid floating-point edge cases, floors like `floor(m*sqrt(n))` are computed exactly:

`floor(m*sqrt(n)) = isqrt(m*m*n)`

For prime `n`, `sqrt(n)` is irrational, so `ceil(m*sqrt(n)) = floor(m*sqrt(n)) + 1`.

This makes terms like `floor(n - m*sqrt(n))` computable with pure integer arithmetic.

### 4) Fast binomials modulo `1_000_000_007`
All required binomials have `n` up to about `10^7`. We precompute:

- `fac[i] = i! mod MOD`
- `invfac[i] = (i!)^{-1} mod MOD`

Then `C(n,k)` is `O(1)`.

### 5) Segmented sieve for primes in a short interval
The prime range is only 10,000 wide, so a segmented sieve marks composites efficiently using base primes up to `sqrt(10_010_000)`.

## What the program prints
Running `main.py` prints:

`sum(G(p)) mod 1_000_000_007` for primes `p` with `10_000_000 < p < 10_010_000`.

It also includes the required assertion from the problem statement:

- `G(90) == 7564511`
