# Project Euler 919 Solution - Fortunate Triangles

<https://projecteuler.net/problem=919>:

* [919.py](919.py)

## 1) Geometry → A simple cosine condition
For any triangle with circumradius `R` and orthocentre `H`, the distance from a vertex `A` to `H` satisfies:

- `AH = 2R * |cos(A)|`
- `AO = R` (since `O` is the circumcentre)

The problem condition is:

`AH = 1/2 * AO`

Substitute:

`2R * |cos(A)| = 1/2 * R`  
`|cos(A)| = 1/4`

So a triangle is **fortunate** iff **at least one angle has cosine ±1/4**.

---

## 2) Law of Cosines → A Diophantine equation
If the fortunate angle is between adjacent sides `a` and `b`, opposite side `c`, then:

`cos(C) = (a² + b² - c²) / (2ab) = ± 1/4`

Rearranging gives two quadratic forms:

- **Acute case** (cos = +1/4):
  `2a² - ab + 2b² = 2c²`
- **Obtuse case** (cos = -1/4):
  `2a² + ab + 2b² = 2c²`

These are homogeneous quadratic Diophantine equations.

---

## 3) Conic parametrisation → Integer families
Each case can be transformed into a rational conic and parametrised, giving explicit integer formulas:

### Family A (cos = +1/4)
Raw triangle (adjacent, adjacent, opposite):

- `A = 8pq`
- `B = 15q² - p² + 2pq`
- `C = 15q² + p²`

Constraint for a valid triangle: `p < 5q`.

### Family B (cos = -1/4)
- `A = 8pq`
- `B = 15q² - p² - 2pq`
- `C = 15q² + p²`

Constraint: `p < 3q`.

---

## 4) Primitive reduction + counting multiples efficiently
A raw triple `(A,B,C)` may share a gcd `g`. The primitive triangle is:

`(A/g, B/g, C/g)`

All multiples `k*(primitive)` are also fortunate, and their perimeters contribute:

For primitive perimeter `p0`, let `n = floor(P / p0)`:

`p0*(1 + 2 + ... + n) = p0 * n(n+1)/2`

So we only enumerate primitives and add this closed-form contribution.

---

## 5) Pruning via gcd structure
A key optimisation is recognising that the **odd part** of `gcd(A,B,C)` can only come from primes `3` and `5`.

In fact, for coprime `(p,q)`, the odd gcd is exactly:

`g_odd = gcd(p, 15)`

We group `p` by `d ∈ {1,3,5,15}`, iterate `p = d*m`, enforce `gcd(p,15)=d`,
and apply necessary perimeter bounds using the maximum possible 2-adic factor (≤ 8).

This reduces the search from ~100M pairs to ~10M.

---

## 6) Correctness checks
The implementation asserts the two statement examples:

- `S(10) = 24`
- `S(100) = 3331`

Then computes and prints `S(10^7)`.

---

## Complexity
The runtime is dominated by iterating feasible `(p,q)` pairs and a few `gcd` calls.
The pruning reduces the loop count dramatically and makes `P=10^7` feasible in pure Python.
