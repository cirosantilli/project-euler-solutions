# Project Euler 907 Solution - Stacking Cups

<https://projecteuler.net/problem=907>:

* [907.py](907.py)

This solution counts the number of full cup towers under a set of local stacking rules and then evaluates the required large input efficiently.

## 1) Rewriting the stacking rules as local transitions

A tower is a *linear* stack from bottom to top. Each cup has:
- a **label** (its size), and
- an **orientation** (right-way-up or upside-down).

Only adjacent cups in the tower matter. The allowed adjacencies translate into simple “next-step” rules on the label:

- **Difference 1** (consecutive sizes): orientation stays the same, and the direction depends on the current orientation.
- **Difference 2**: orientation flips, and the label may go up or down by 2.

So each partial tower can be described by:
- which cups are already used,
- the last cup label, and
- the last orientation.

From any state there are at most **three** possible next moves.

## 2) Exact enumeration for small `n` with memoised DFS

To obtain reliable starting values, the program computes `S(n)` exactly for `n ≤ 20` using a depth-first search with caching over the state `(used_set, last_label, last_orientation)`.

This is fast in practice because the branching factor is tiny and the number of valid towers for `n ≤ 20` is small.

The problem’s provided checks are asserted:

- `S(4) = 12`
- `S(8) = 58`
- `S(20) = 5560`

## 3) Short linear recurrence and fast evaluation

From the initial exact values, the sequence satisfies a fixed **order-8 linear recurrence** (constant coefficients). The code validates the recurrence against the exact values it computed.

To evaluate `S(10^7) mod 1_000_000_007` quickly, the recurrence is turned into an 8×8 **companion matrix** and computed with **binary exponentiation**:

- time: `O(k^3 log n)` with `k = 8`
- memory: `O(k^2)`

This avoids any large-`n` brute force and runs essentially instantly.
