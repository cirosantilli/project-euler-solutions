# Project Euler 767 Solution - Window into a Matrix II

<https://projecteuler.net/problem=767>:

* [767.py](767.py)

This solver targets `B(k, n)` for a **16×n** binary matrix with the constraint:

> every contiguous **2×k** window has sum **k** (exactly half the entries are `1`).

It prints `B(10^5, 10^16) mod 1,000,000,007` and checks the two sample values from the statement.

## Key ideas

### 1) Sliding-window sum ⇒ period `k` (for each adjacent row pair)
Fix any adjacent row pair `(r, r+1)`. For a given column `j`, define:

` s_j = row_r[j] + row_{r+1}[j] ∈ {0,1,2} `

The condition “every 2×k window sums to k” becomes:

` s_j + s_{j+1} + … + s_{j+k-1} = k ` for all possible `j`.

Subtract consecutive windows to get `s_{j+k} = s_j`, so each `s_j` is **k-periodic**.

When `n` is divisible by `k` (true for all values used here), the matrix splits into `k` residue classes
(modulo `k`), each repeated `m = n/k` times.

### 2) Column-types and a special “alternating” type
Within a single residue class, all columns share the same 15-vector of adjacent sums:

` t = (x1+x2, x2+x3, …, x15+x16) `

where `x1..x16` are the bits in that column.

For almost all such `t`, the column `x1..x16` is uniquely determined. The only exception is:

- `t = (1,1,…,1)` (all adjacent sums are 1), which corresponds to **two** alternating columns
  (`0101…` and `1010…`).

Because each residue class is repeated `m` times:
- a “unique” type contributes weight `1`
- the special alternating type contributes weight `2^m`

Let `A = 2^m mod MOD` be that special weight.

### 3) Turning the 15 constraints into simple alternating row-sums
Suppose `a` residue classes use the special alternating type.
Then each of the 15 adjacent-pair constraints already gets contribution `a` from those classes.

The remaining `L = k-a` residue classes must satisfy:

` sum(t_i over those L classes) = L ` for every adjacent pair `i`.

For the “unique” types, the residue-class column is fixed, so the constraint becomes:

` rowSum[i] + rowSum[i+1] = L ` for `i=1..15`.

This forces **alternating row sums**:
- all odd rows have the same sum `t`
- all even rows have sum `L - t`

So for each `L`, the count reduces to “how many 16×L binary matrices have alternating row sums”
**while excluding** the two alternating columns (because those are handled by `a` and `A`).

### 4) Inclusion–exclusion over the two forbidden columns
If we temporarily allow all columns, row sums are independent:
the count for a fixed `t` is `C(L,t)^{16}`.

We then exclude the two forbidden columns with inclusion–exclusion.
After summing over `t`, the result for a given `L` becomes a binomial transform involving

` f[r] = sum_{x=0..r} C(r,x)^{16} `

(these are “Franel-like” numbers).

### 5) Fast computation of `f[r]` via an EGF convolution
Use:

` C(r,x)^{16} = r!^{16} / (x!^{16} (r-x)!^{16}) `

so

` f[r] = r!^{16} * [y^r] ( Σ_{n≥0} y^n / n!^{16} )^2 `.

Thus `f[0..k]` can be obtained from a single polynomial convolution of the series
`a[n] = 1/n!^{16}` with itself.

### 6) Two polynomial convolutions + binomial transform
The overall computation uses:
1. `a * a` to get `f[r]`
2. another convolution to apply the binomial transform that produces the per-`L` counts `S[L]`

Finally:

` B(k,n) = Σ_{a=0..k} C(k,a) * A^a * S[k-a]  (mod MOD)`

### 7) NTT under 3 primes + CRT
Since `1,000,000,007` is not NTT-friendly, the code performs NTT-based convolutions under
three NTT primes and uses CRT/Garner reconstruction to obtain the **exact integer convolution**
coefficients (which are safely below the product of the three primes for our bounds), then reduces
mod `1,000,000,007`.

## Complexity
Let `k = 100000`, and the convolution size is the next power of two ≥ `2k+1` (here `262144`).

- Time: `O(N log N)` for each convolution (two total), plus `O(k)` linear work.
- Memory: `O(N)`.

## Files
- `main.py` — full solver (prints the final result; does not hard-code it)
- `README.md` — this explanation
