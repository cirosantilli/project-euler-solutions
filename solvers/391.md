# Project Euler 391 Solution - Hopping Game

<https://projecteuler.net/problem=391>:

* [391.py](391.py)

This solution computes

\[
\sum_{n=1}^{1000} M(n)^3
\]

where `M(n)` is the largest winning first move in a subtraction-style game constrained to positions

\[
S = \{ s_k \}_{k\ge 0}, \quad s_k = \text{(total number of 1-bits in binary representations of }0..k)
\]

## Key Techniques

### 1) Recasting the game as a “scan with reset”
The allowed positions satisfy:

\[
s_{k+1} - s_k = \mathrm{popcount}(k+1)
\]

The game “move” of adding `m` (with `1 ≤ m ≤ n`) while staying inside `S` can be analyzed via a backward scan over these increments. This reduces `M(n)` to a deterministic process:

- Scan a structured sequence of values (popcounts) **in descending order**
- Maintain an accumulator `s`
- Update with a reset rule:

\[
s \leftarrow
\begin{cases}
s+v & \text{if } s+v \le n\\
0   & \text{otherwise}
\end{cases}
\]

The final `s` after scanning is exactly `M(n)`.

### 2) Divide-and-conquer structure of popcount sequences
Popcounts over `[0, 2^k)` have a classic recursive structure:

\[
P(k) = P(k-1)\ \Vert\ (P(k-1)+1)
\]

When scanning *descending*, that corresponds to “upper half first (offset +1), then lower half (offset +0)”.

This gives a recurrence for processing a whole block of size `2^k` with a fixed offset `off`:

\[
F(k,off) = F(k-1,off)\ \circ\ F(k-1,off+1)
\]

where `F(k,off)` is the **state transform** (a function mapping input accumulator `s` to output accumulator).

### 3) Using small finite transforms (tables) instead of huge sequences
For a fixed `n`, the accumulator `s` always lies in `[0..n]` (here at most 1000), so each transform can be represented as a table of length `n+1`.

Composition is cheap:

\[
(A\circ B)[s] = A[B[s]]
\]

So each composition costs `O(n)`.

### 4) Early saturation (crucial performance trick)
Although the theoretical block size for `M(n)` involves `2^{n+1}`, in practice the transform `F(k,0)` becomes **constant** (independent of `s`) at a relatively small `k` (≈ 20–25 for `n ≤ 1000`).

Once `F(k,0)` is constant, all larger `k` remain constant because composing anything after a constant transform still yields a constant output.

This allows the code to stop early, making the full `n=1..1000` computation run in reasonable time.

## Correctness Checks
The code includes asserts for the problem statement’s sample values:

- `M(2) = 2`
- `M(7) = 1`
- `M(20) = 4`
- \(\sum_{n=1}^{20} M(n)^3 = 8150\)
