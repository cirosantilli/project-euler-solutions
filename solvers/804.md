# Project Euler 804 Solution - Counting Binary Quadratic Representations

<https://projecteuler.net/problem=804>:

* [804.py](804.py)

We need

\[
T(N)=\sum_{n=1}^{N} g(n),
\quad
g(n)=\#\{(x,y)\in\mathbb Z^2 : x^2+xy+41y^2=n\}.
\]

Instead of summing `g(n)` directly, we count **all** integer pairs `(x,y)` whose quadratic form value is **at most** `N`.

## 1) Turn the summation into a lattice-point count

Because the form is positive definite, each pair `(x,y)` produces exactly one non-negative value. Therefore:

\[
T(N)=\#\{(x,y)\in\mathbb Z^2 : 1 \le x^2+xy+41y^2 \le N\}.
\]

This is the number of lattice points inside an ellipse, excluding the origin.

## 2) Complete the square and remove fractions

Complete the square:

\[
x^2+xy+41y^2 = \left(x+\frac{y}{2}\right)^2 + \frac{163}{4}y^2
           = \frac{(2x+y)^2 + 163y^2}{4}.
\]

Let

\[
u = 2x+y.
\]

Then `(x,y)` are integers **iff** `u ≡ y (mod 2)` and the inequality becomes:

\[
u^2 + 163y^2 \le 4N.
\]

So `T(N)` is a lattice-point count for `u^2 + 163y^2 <= 4N` with a simple parity constraint.

## 3) Count `u` for each `y` using integer square roots

For fixed `y`, define:

\[
t = \left\lfloor \sqrt{4N - 163y^2} \right\rfloor.
\]

Then all valid `u` satisfy `|u| <= t` and `u ≡ y (mod 2)`:

- If `y` is even, `u` must be even ⇒ count is `2*floor(t/2)+1`.
- If `y` is odd, `u` must be odd  ⇒ count is `2*floor((t+1)/2)`.

Sum over `y` in `[-y_max, y_max]` (using symmetry to only loop over `y >= 0`) and subtract the origin so only positive `n` are included.

## 4) Micro-optimization: incremental `y^2`

To keep the loop fast for `N = 10^16`, the implementation updates `163*y^2` incrementally:

- `y^2` increases by successive odd numbers `1,3,5,...`
- so `163*y^2` increases by `163, 3*163, 5*163, ...`

This avoids per-iteration multiplication for `y*y` and keeps the work essentially to one `isqrt` per `y`.
