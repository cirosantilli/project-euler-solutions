# Project Euler 906 Solution - A Collective Decision

<https://projecteuler.net/problem=906>:

* [906.py](906.py)

## Key idea: Condorcet winner ⇔ disjoint “above” sets (3 voters)

Fix an option `i`. For each of the three voters, look at the set of other options they rank **above** `i`.
Call the sizes `a, b, c` (each between `0` and `n-1`).

With 3 voters, `i` loses a head-to-head match against some other option `j` **iff** `j` is ranked above `i` by
at least two voters. Therefore:

> `i` is a Condorcet winner **iff** no option appears above `i` in two voters’ rankings, i.e. the three “above”
> sets are pairwise disjoint.

Because each voter’s ranking is a random permutation, conditional on `a` the “above” set is a uniformly random
subset of size `a` from the `N = n-1` remaining options, and the three voters’ subsets are independent.

## Turning it into a computable sum

For given sizes `a, b, c`, the probability that three random subsets of sizes `a, b, c` are disjoint is:

- Pick voter 1’s `a`-subset.
- Voter 2 must choose its `b`-subset from the remaining `N-a` elements:
  \[
  \frac{\binom{N-a}{b}}{\binom{N}{b}}
  \]
- Voter 3 must choose its `c`-subset from the remaining `N-a-b` elements:
  \[
  \frac{\binom{N-a-b}{c}}{\binom{N}{c}}
  \]

Ranks are uniform, so `a, b, c` are independent uniform integers in `[0, N]`.
If a Condorcet winner exists it is unique, so
\[
P(n) = n \cdot \Pr(\text{a fixed } i \text{ is a Condorcet winner}).
\]

## Collapsing one dimension with a binomial identity

A direct triple sum is too slow. The crucial simplification is that the innermost sum over `c` can be done in
closed form:

\[
\sum_{c=0}^{N-t} \frac{\binom{N-t}{c}}{\binom{N}{c}} = \frac{N+1}{t+1},
\quad \text{where } t = a+b.
\]

This turns the problem into a **positive** double sum over `(a,b)`.

## Efficient evaluation

Two implementation tricks make `n = 20000` fast:

1. **Multiplicative updates (no factorials).**  
   The ratio \(\binom{N-a}{b} / \binom{N}{b}\) is updated via a simple product recurrence:
   \[
   g_{b} = g_{b-1} \cdot \frac{N-a-(b-1)}{N-(b-1)}.
   \]
   This makes each row (fixed `a`) cheap to compute.

2. **Provable early stopping per row.**  
   For fixed `a`, the terms are decreasing in `b`, so the remaining tail is bounded by
   `current_term * remaining_count`. Once that bound is below a tiny `eps_row`, we stop the inner loop.
   The accumulated truncation error is far below what’s needed for 10 decimal places.

For numerical robustness, the running sum uses **Kahan summation**.

---

Run:

```bash
python3 main.py
It prints P(20000) rounded to 10 digits after the decimal point.
