# Project Euler 732 Solution - Standing on the Shoulders of Trolls

<https://projecteuler.net/problem=732>:

* [732.py](732.py)

This repository contains a reference implementation in **pure Python** (`main.py`).

## Key ideas

### 1) Only the *total* remaining shoulder-height matters
If the current set of trolls remaining in the hole has total shoulder-height `S` and a troll with arm length `l` is placed on top of any stack of the others, the maximum hand height he can achieve is:

- support height from all other trolls: `S - h`
- plus his own shoulder height: `+ h`
- plus his arm length: `+ l`

So the hand height simplifies to `S + l` (independent of `h`).

Let `D = (sum h) / sqrt(2)` be the fixed hole depth. A troll can escape exactly when:

`S + l >= D`.

Because `S + l` is an integer, this is equivalent to:

`S + l >= ceil(D)`.

### 2) Convert “escaping” into a scheduling problem
Let:

- `H = sum(h)` be the initial total shoulder-height.
- `Y = ceil(H / sqrt(2))` (computed *exactly* with integer arithmetic).
- `W` be the cumulative shoulder-height of trolls that have already escaped.

Then the remaining total shoulder-height is `S = H - W`.
A troll with arm length `l` can escape when:

`H - W + l >= Y`  ⇔  `W <= H - (Y - l)`.

This is a **start-time constraint**: by the time the cumulative removed height reaches `W`, you must have started escaping that troll.

Since each escape increases `W` by that troll’s shoulder-height `h`, the start-time constraint is equivalent (for integer time) to a standard **completion deadline**:

`W + h <= (H - (Y - l)) + h`.

So each troll becomes a job with:

- processing time `p = h`
- profit `q`
- deadline `d = (H - Y) + l + h`

We want the maximum total profit of any subset of jobs that can be completed by their deadlines.

### 3) Solve with 0/1 knapsack DP over time
After sorting jobs by increasing deadline, we run a classic 0/1 knapsack:

- `dp[t] = best total IQ achievable with total processing time exactly t`
- transitions: `dp[t] = max(dp[t], dp[t-p] + q)` for `t <= d`

The maximum deadline is about `(H - Y) + 300`, which is roughly `0.293 * H + 300`.
For `N = 1000` this is around **30k**, making the DP fast.

## Integer trick for `ceil(H / sqrt(2))`
We avoid floating point by using:

`Y = min { y ∈ Z : sqrt(2) * y >= H }`  ⇔  `2*y^2 >= H^2`.

An exact formula using `isqrt` is:

`Y = isqrt((H^2 - 1) // 2) + 1`.

## Complexity
- Generating trolls: `O(N)`
- DP: `O(N * Dmax)` where `Dmax ≈ 3e4` for `N=1000`
- Memory: `O(Dmax)`

## Running

```bash
python3 main.py
```

The program includes asserts for the sample values `Q(5)` and `Q(15)` from the problem statement and prints `Q(1000)`.
