# Project Euler 582 Solution - Nearly Isosceles $120$ Degree Triangles

<https://projecteuler.net/problem=582>:

* [582.py](582.py)

We want to count integer-sided triangles `(a, b, c)` with:

- one angle equal to **120°**
- `a ≤ b ≤ c`
- `b - a ≤ 100`
- `c ≤ N`

Define `T(N)` as the number of such triangles, and compute `T(10^100)`.

The program in `main.py` prints the answer and includes the problem’s check values:
`T(1000) = 235` and `T(10^8) = 1245`.

## Key idea 1: Reduce to a Pell-type equation

If the 120° angle is opposite side `c`, the law of cosines gives:

\[
c^2 = a^2 + b^2 + ab
\]

Let `k = b - a` with `1 ≤ k ≤ 100`, so `b = a + k`. Substitute:

\[
c^2 = a^2 + (a+k)^2 + a(a+k) = 3a^2 + 3ka + k^2
\]

Now set

- `x = 2c`
- `y = 2a + k`

A short algebraic manipulation yields:

\[
x^2 - 3y^2 = k^2
\]

So for each fixed `k`, we’re looking for integer solutions `(x, y)` to
`x^2 - 3y^2 = k^2`, with the extra constraints:

- `x` is even (so `c = x/2` is an integer)
- `y ≡ k (mod 2)` (so `a = (y-k)/2` is an integer)
- `y > k` (equivalently `a > 0`) for an actual triangle

Each solution with `y > k` corresponds to exactly one valid triangle:
`a = (y-k)/2`, `b = a+k`, `c = x/2`.

## Key idea 2: Unit-group recurrence (fast enumeration)

In `Q(√3)`, the fundamental unit is:

\[
\varepsilon = 2 + \sqrt{3}, \quad \text{with norm } 1
\]

Multiplying a solution `(x + y√3)` by `ε` produces another solution with the same norm:

\[
(x + y\sqrt{3})(2 + \sqrt{3})
= (2x + 3y) + (x + 2y)\sqrt{3}
\]

So for **even** `k` we can iterate with:

- `x' = 2x + 3y`
- `y' = x + 2y`

For **odd** `k`, the parity of `(x, y)` flips under `ε`, and `x` may become odd.
To stay in the parity class that yields integer `c`, we iterate by `ε² = 7 + 4√3`:

- `x' = 7x + 12y`
- `y' = 4x + 7y`

These recurrences grow exponentially, so for `N = 10^100` each orbit contributes only
`O(log N)` solutions.

## Key idea 3: Seeds (orbit representatives)

For each `k`, solutions form a small number of “orbits” under the chosen recurrence.

`main.py` finds a finite set of **seeds** by brute-forcing small `y` values and removing
anything that has a valid predecessor under the inverse recurrence.

Important detail: we must also allow degenerate solutions with `y ≤ k` (which correspond
to `a ≤ 0`) while building seeds, because some orbits enter the valid region (`a > 0`)
only after one or more recurrence steps.

Once seeds are known, we iterate each orbit until `x = 2c > 2N`, counting only states with
`y > k`.

## Complexity

- Seed search is tiny (`k ≤ 100` and `y` bounded by a small constant).
- Enumeration is roughly a few tens of thousands of big-integer recurrence steps.

This runs very quickly in pure Python.
