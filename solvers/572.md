# Project Euler 572 Solution - Idempotent Matrices

<https://projecteuler.net/problem=572>:

* [572.py](572.py)

We count **3×3 integer matrices** `M` such that:

- `M*M = M` (idempotent), and
- every entry of `M` lies in `[-n, n]`.

Let this number be `C(n)`.

The problem statement gives:

- `C(1) = 164`
- `C(2) = 848`

This solution computes `C(200)`.

---

## 1) Rank decomposition

For an idempotent matrix, all eigenvalues are `0` or `1`, so the rank can only be `0, 1, 2, 3`.

- **rank 0**: only the zero matrix.
- **rank 3**: only the identity matrix.

So the task reduces to counting ranks **1** and **2**.

---

## 2) Rank 1: outer-product form

A rank-1 idempotent integer matrix can be written as:

- `P = u v^T` with integer vectors `u, v ∈ Z^3`, and
- `u·v = 1`.

Indeed, `(u v^T)^2 = u (v^T u) v^T = (u·v) (u v^T)`.
So `P^2 = P` iff `u·v = 1`.

Two pairs represent the same matrix: `(u, v)` and `(-u, -v)`, so after counting ordered pairs we divide by 2.

### Bounding trick via √n
For rank 1 inside `[-n, n]`, every entry is a product `u_i v_j`, so it is enough to enforce:

- `max(|u_i|) * max(|v_j|) ≤ n`.

Let `T = floor(sqrt(n))`. Since `(T+1)^2 > n`, for any pair with `max(u) * max(v) ≤ n`, at least one of `max(u) ≤ T` or `max(v) ≤ T` must hold.

That gives an inclusion–exclusion count:

- count pairs with `max(u) ≤ T` (then `v` lies in a cube of side `2*(n//max(u))+1`)
- by symmetry, the same count for `max(v) ≤ T`
- subtract the overlap where both are ≤ `T`

So we only enumerate `u` in the small cube `[-T, T]^3` (for `n=200`, that’s `T=14`).

---

## 3) Fast counting of `u·v = 1` in a box

For each fixed `u = (a,b,c)`, we need to count integer `v = (x,y,z)` in a rectangular box such that:

`a*x + b*y + c*z = 1`.

This is done without brute-forcing the whole 3D box:

1. Choose one variable (the one with the smallest range) and iterate it.
2. For each value, reduce to a **2-variable** Diophantine equation, e.g.
   `b*y + c*z = 1 - a*x`.
3. Count solutions of `A*y + B*z = C` inside a rectangle using:
   - `g = gcd(A,B)` for feasibility (`C % g == 0`)
   - one particular solution from **extended gcd**
   - the standard parameterization of all solutions with an integer parameter `t`
   - intersecting the allowed `t`-intervals from the `y` and `z` bounds

This makes each count essentially **O(range of one variable)** with only integer arithmetic.

---

## 4) Rank 2 via complement

A rank-2 idempotent matrix can be written as:

`M = I - P`, where `P = u v^T` is rank-1 idempotent (`u·v = 1`).

The entry bounds on `M` translate to bounds on `P`:

- off-diagonal: `|u_i v_j| ≤ n` for `i ≠ j`
- diagonal: `1-n ≤ u_i v_i ≤ 1+n`

With `T=floor(sqrt(n))` and for the specific constraints of this problem (including the diagonal shift), a valid pair always has at least one of `max(u) ≤ T` or `max(v) ≤ T`.
So we again use inclusion–exclusion:

- count pairs with `max(u) ≤ T` (but now each coordinate of `v` gets its **own** bound, coming from the off-diagonal constraints plus the diagonal interval)
- double by symmetry
- subtract the overlap where `max(u) ≤ T` and `max(v) ≤ T`

The same “linear equation in a box” routine from the rank-1 case handles these per-coordinate ranges.

---

## 5) Final formula

For `n ≥ 1`:

`C(n) = 2 + (#rank1) + (#rank2)`

where the `2` accounts for the zero matrix and the identity matrix.

The code includes asserts for the statement’s test values and prints `C(200)`.
