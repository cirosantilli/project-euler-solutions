# Project Euler 475 Solution - Music Festival

<https://projecteuler.net/problem=475>:

* [475.py](475.py)

We have **12n** musicians. Day 1 they are split into **3n fixed quartets** (groups of 4). Day 2 they must form **4n trios** (groups of 3) such that **no trio contains two musicians from the same quartet**.

Let `f(12n)` be the number of valid trio partitions.

`main.py` computes `f(600) mod 1,000,000,007`, and it asserts the two statement checks:

- `f(12) = 576`
- `f(24) mod 1,000,000,007 = 509089824`

---

## Technique 1: Count an ordered version, then divide by symmetry

Temporarily treat trios as:

- **edges are labeled** `1..4n`
- **each trio has 3 ordered positions** (row 1,2,3)

This gives a `3 × 4n` array of musicians. For the real answer we divide by:

- `3!^{4n}` for permuting the 3 positions inside each trio
- `(4n)!` for permuting the trios themselves

Musicians inside each quartet are still distinct, so later we multiply by `4!` for each of the `3n` quartets (i.e. `24^{3n}`).

---

## Technique 2: A symmetric-polynomial coefficient

Let there be one variable `x_q` per quartet (so there are `m = 3n` variables). A single ordered trio must use **three distinct quartets**, so its contribution is:

`x_a x_b x_c` with `a,b,c` all different.

Define

`S = Σ_{a,b,c distinct} x_a x_b x_c`.

Then `S^{4n}` corresponds to choosing `4n` ordered trios, and the condition “each quartet contributes exactly 4 musicians total” becomes:

`[x_1^4 x_2^4 ... x_m^4] S^{4n}`.

That coefficient (call it `B`) counts valid `3 × 4n` arrays at the *quartet level* (ignoring which musician of the quartet is used where). The full ordered-musician count is `24^{m} · B`.

---

## Technique 3: Rewrite S using power sums

Let

- `p1 = Σ x_i`
- `p2 = Σ x_i^2`
- `p3 = Σ x_i^3`

Using inclusion–exclusion on repeated indices:

`S = p1^3 − 3 p1 p2 + 2 p3`.

Now expand `S^{4n}` with a multinomial over the three terms.

---

## Technique 4: Closed-form coefficient for p1^A p2^j p3^k

After expansion, we need coefficients of the form:

`[x_1^4 ... x_m^4] (p1^A)(p2^j)(p3^k)`.

For a single variable `x`, exponent 4 can only be composed from contributions `1` (from `p1`), `2` (from `p2`), `3` (from `p3`) in these four ways:

| type | from p1 | from p2 | from p3 |
|------|---------|---------|---------|
| T0   | 4       | 0       | 0       |
| T1   | 2       | 1       | 0       |
| T2   | 1       | 0       | 1       |
| T3   | 0       | 2       | 0       |

Let the counts of quartets of these types be `(a,b,c,d)`.
They satisfy:

- `a+b+c+d = m`
- total `p3` selections imply `c = k`
- total `p2` selections imply `b + 2d = j`
- total `p1` selections imply `4a + 2b + c = A`

For this problem’s parameters, the system reduces to a **single free integer** `d` in a small range, and the coefficient becomes a short sum over `d` involving factorials and powers of `2` and `24`.

All arithmetic is done **modulo 1,000,000,007**, using factorials and modular inverses.

---

## Complexity

For `n = 50`:

- outer loops over `(i,j)` with `i+j ≤ 4n` → about 20k states
- an inner sum over `d` of length ≤ `j/2` (≤ 100)

So it runs in a few million modular operations.

---

## Final assembly

The final answer is obtained from the reduced sum `sigma`:

`f(12n) = 24^{3n} · (3n)! · sigma / 6^{4n}   (mod M)`

(The factor `(4n)!` cancels between the generating-function expansion and the “unlabel trios” division.)

Run:

```bash
python3 main.py
```

or for an explicit `n`:

```bash
python3 main.py 50
```
