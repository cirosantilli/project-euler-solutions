# Project Euler 600 Solution - Integer Sided Equiangular Hexagons

<https://projecteuler.net/problem=600>:

* [600.py](600.py)

## Key idea: turn geometry into integer counting

An equiangular hexagon has all interior angles equal to `120°`, so each successive side direction rotates by `60°`.
Place the first side along direction `0°`, then the next along `60°`, then `120°`, etc.  
Let the (positive integer) side lengths in order be:

`(a, b, c, d, e, f)`.

Using vectors in those six directions, the polygon closes iff the vector sum is zero.  
Because directions come in opposite pairs, this reduces to two linear constraints:

- `a + b = d + e`
- `b + c = e + f`

(And the third similar relation is redundant.)

From these, define the common “offset”:

`t = a - d = e - b = c - f`.

## Remove congruence by choosing a canonical representative

Congruence allows rotation, reflection, and a `180°` rotation (which swaps opposite sides).
Using these symmetries we can uniquely represent each congruence class by enforcing:

- `t ≥ 0` (if `t < 0`, apply a `180°` rotation)
- `b ≤ d ≤ f` (choose a starting side among the alternating triple)

Now write the ordered triple with nonnegative gaps:

- `d = b + y`
- `f = d + z = b + y + z`

with `y, z ≥ 0`.

Then the remaining sides are forced by `t`:

- `a = d + t = b + y + t`
- `e = b + t`
- `c = f + t = b + y + z + t`

So every hexagon corresponds to integers:

- `b ≥ 1`
- `y, z, t ≥ 0`

## Perimeter becomes a weighted sum

Add the six sides:

`P = a + b + c + d + e + f = 6b + 4y + 2z + 3t`.

We need `P ≤ n`.

Let `b' = b - 1 ≥ 0`, and introduce a slack variable `s ≥ 0` to absorb leftover perimeter:

`6b' + 4y + 2z + 3t + s = n - 6`.

So `H(n)` is exactly the number of nonnegative integer solutions to that equation.

Equivalently, `H(n)` is the coefficient of `x^(n-6)` in the generating function:

```
1 / ((1-x)(1-x^2)(1-x^3)(1-x^4)(1-x^6)).
```

## Computing the coefficient

This is the classic “coin change / integer partition with fixed coin sizes” problem.

We compute the coefficient with a 1D DP:

- `dp[k]` = number of ways to make sum `k` using coin sizes `{1,2,3,4,6}`
- iterate coins outermost to avoid counting permutations

Time: `O(n)` (here ~55k)  
Memory: `O(n)`

The implementation is in `main.py`, with asserts for the provided checks.
