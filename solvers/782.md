# Project Euler 782 Solution - Distinct Rows and Columns

<https://projecteuler.net/problem=782>:

* [782.py](782.py)

This solution computes

- `c(n, k)`: the minimum “complexity” (number of distinct rows **and** columns) among all `n×n` binary matrices with exactly `k` ones
- `C(n) = Σ_{k=0..n²} c(n,k)` and asks for `C(10⁴)`.

## 1) Turning the sum into a counting problem

For `n ≥ 2`:

- `c(n,0) = c(n,n²) = 1` (all-zero / all-one matrices)
- all other `c(n,k)` lie in `{2,3,4}`

So it’s enough to count how many `k` have minimum complexity `2`, and how many force complexity `4`.

Let

- `N2` = number of `k` whose minimum complexity is exactly `2`
- `N4` = number of `k` whose minimum complexity is exactly `4`

Then (algebra on the sum)

`C(n) = 3·(n²+1) - 4 - N2 + N4`.

## 2) Complexity 2: explicit characterization

If only **two** distinct bitstrings appear among all rows and columns, the matrix (after permuting rows/columns) must be one of a small set of block shapes. That yields the exact attainable `k` values:

- `k = a²` and `k = n² - a²`
- `k = 2a(n-a)` and `k = n² - 2a(n-a)`

for some integer `0 ≤ a ≤ n`, excluding `k=0` and `k=n²` (which have complexity `1`).

So `N2` is computed by building this small set (size `O(n)`).

## 3) Complexity ≤ 3: reduce to 3×3 “blow-ups”

If the total number of distinct row/column patterns is at most `3`, then after grouping equal rows and equal columns the matrix becomes a **3×3 block matrix**, where each block is all-0 or all-1.

Equivalently:

- pick a 3×3 binary “template”
- choose group sizes `(a,b,c)` with `a+b+c=n`
- “blow up” the template: block `(i,j)` contributes `size_i · size_j` ones if that template entry is `1`

So every achievable `k` is a quadratic form in `(a,b,c)`.

### 7 canonical quadratic forms

Among all 3×3 templates with at most 3 distinct row/column patterns, after accounting for:

- permuting the 3 groups
- complementing the matrix (`k ↔ n²-k`)

all achievable `k` values come from **7 canonical quadratic forms** in the group sizes.

The implementation marks all attainable `k` values from these forms.

## 4) Complement symmetry and half-range marking

Complementing a matrix preserves complexity and maps `k → n²-k`.

So when building the set of achievable `k`, the code stores only

`min(k, n²-k)` in the range `0..⌊n²/2⌋`

and reconstructs the full count from the “half” count.

## 5) Performance tricks

- A bytearray is used as a dense “seen” table for `0..⌊n²/2⌋`.
- The largest family (“multiplication-table” products) is marked with **slice assignment** on arithmetic progressions, which runs in C and is much faster than Python loops.
- For another large family that depends only on `a(s-a)` with `s=a+b`, the solver iterates only **distinct** values (using symmetry `a ↔ b`) to cut work roughly in half.

---

The final program is a single-file, standard-library-only solver with asserts for all test values given in the problem statement.
