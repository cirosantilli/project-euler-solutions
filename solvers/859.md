# Project Euler 859 Solution - Cookie Game

<https://projecteuler.net/problem=859>:

* [859.py](859.py)

## Key ideas

### 1) View each pile as a combinatorial game
A position is an **unordered multiset** of piles. A move always acts on a **single pile** and replaces it by two equal smaller piles, so the whole position is the **disjunctive sum** of independent pile-games.

Treat **Odd** as **Left** and **Even** as **Right** in normal-play combinatorial game theory.

For a pile of size `n`:

- If `n` is **odd**, only Left can move:
  - eat 1 cookie and split the remaining evenly
  - the option is two piles of size `(n-1)/2`

- If `n` is **even**, only Right can move:
  - eat 2 cookies and split the remaining evenly
  - the option is two piles of size `(n-2)/2`

So each pile has moves for **only one player**.

### 2) Each pile reduces to an integer “value”
Let `g(n)` be the game value of a single pile of size `n`, measured as an advantage for Left.

Because each pile has moves on only one side, it is a **cold game (a number)**. Here, it turns out every `g(n)` is an **integer**, and it can be computed by a simple recurrence.

- Base: `g(0) = 0`.

- If `n = 2m+1` is odd, Left’s only option is `2*g(m)`.
  - If that option is negative, then **0** is already a legal (and simplest) number greater than it, so `g(n)=0`.
  - Otherwise the simplest integer greater than it is `2*g(m)+1`.

- If `n = 2m` is even, Right’s only option is `2*g(m-1)`.
  - If that option is positive, then **0** is already a legal (and simplest) number less than it, so `g(n)=0`.
  - Otherwise the simplest integer less than it is `2*g(m-1)-1`.

With these rules, `g(n)` for all `n ≤ 300` can be computed in a single forward pass.

### 3) A whole position is just a sum of pile values
For a partition `n = p1 + p2 + ... + pk`, the total game value is:

`g(p1) + g(p2) + ... + g(pk)`

Then, with Odd starting (Left to move):

- Odd wins iff the total value is **> 0**
- Even wins iff the total value is **≤ 0** (including the `0` case, where the second player wins)

So `C(N)` becomes:

> the number of integer partitions of `N` whose summed `g(p)` is `≤ 0`.

### 4) Count winning partitions via 2D partition DP
We count unordered partitions using the standard “coin change” dynamic programming order (iterate part sizes from `1..N`).

We track two totals:

- `cookies` = sum of pile sizes
- `value` = sum of pile values `g(size)`

DP state:

`dp[cookies][value] = number of partitions with those totals`

For `N=300`, the value range is small enough to keep an array DP:

- Each even pile contributes at worst about `-size/2`, so total value is at least `-N//2`.
- Each pile contributes at most `+size`, so total value is at most `N`.

Finally:

`C(N) = sum_{value <= 0} dp[N][value]`

## Correctness checks
The solution includes assertions for the example values given in the problem statement:

- `C(5) = 2`
- `C(16) = 64`

## Complexity
Let `W` be the number of tracked value states (about `N + N//2 + 1`).

- Time: `O(N^2 * W)` with small constants (fits easily for `N=300`).
- Memory: `O(N * W)`.
