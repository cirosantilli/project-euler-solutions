# Project Euler 780 Solution - Toriangulations

<https://projecteuler.net/problem=780>:

* [780.py](780.py)

This repository contains a **pure-Python** solution skeleton for Project Euler 780.

The implementation follows the standard mathematical decomposition used by fast solutions:

## 1) Geometry → arithmetic structure (strip tilings)

When a torus is tiled by unit equilateral triangles, extending the tiling periodically to the plane shows that the triangles must align in **parallel strips**.

This reduces counting tilings to counting:

- a strip multiplicity `k` (how many strips wrap around the torus),
- a coprime direction pair `(a,b)` that determines the strip slope,
- and an inequality constraint where `sqrt(3)` appears from the strip height.

A key trick is to avoid iterating over `(a,b)` directly by grouping them by
`x = a*b` and using the fact:

- The number of **ordered coprime factorizations** of `x` equals `2^{ω(x)}`,
  where `ω(x)` is the number of distinct prime factors of `x`.
  (Each prime power must go entirely to one side to keep `gcd(a,b)=1`.)

## 2) Summing over all `n ≤ N` directly

Instead of counting each `n` individually, we count how many `m = n/2` satisfy
the strip constraint. This turns the per-`n` divisor condition into a range count:

- for each `(k, x)` we add a factor like  
  `floor(M/k) - floor(sqrt(3)*k*x)`.

This is what the reference implementation does in `G_reference(N)`.

## 3) Hexagonal-pattern correction

Some tilings have **three equivalent strip directions** (hexagonal symmetry).
The strip-based counting counts these tilings three times, so we must subtract
two copies.

For `n = 4m`, the number of hexagonal tilings has a multiplicative form:

- For primes `p ≡ 1 (mod 3)` the exponent contributes `(e+1)^2`,
- For other primes it contributes `(e+1)`.

We sum this correction for `m ≤ N/4`.

## 4) Exact integer arithmetic (no floating point)

The problem is sensitive to rounding when `sqrt(3)` is multiplied by large integers.
The code avoids floating point entirely:

- `floor(sqrt(3)*t) = isqrt(3*t*t)` is exact.
- `floor(n/(m*sqrt(3)))` is computed with an integer-square-root estimate and a
  tiny correction loop.

## Complexity

The `main.py` file keeps a **direct reference summation** that is fast enough
for the statement-scale checks and demonstrates the correct integer-safe technique.

For `N = 10^9`, additional optimization is required (the same mathematics, but
sublinear summation and/or faster multiplicative summatory methods).
