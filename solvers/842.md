# Project Euler 842 Solution - Irregular Star Polygons

<https://projecteuler.net/problem=842>:

* [842.py](842.py)

This solution treats an “\(n\)-star polygon” as an **undirected Hamiltonian cycle** on the \(n\) labelled vertices of a regular \(n\)-gon (matching the statement’s count of 12 for \(n=5\)).

## Key techniques

### 1) Swap “sum over polygons” for “sum over intersection points”
For a fixed \(n\), consider **all diagonals** of the regular \(n\)-gon.

Every interior intersection point \(P\) is the common meeting point of **\(m\ge 2\)** diagonals. A particular Hamiltonian cycle contributes **1** to \(I(S)\) for \(P\) *iff* it uses **at least two** of those \(m\) diagonals as edges.

So:
\[
T(n)=\sum_{P} \#\{\text{cycles that use at least 2 diagonals through }P\}.
\]

### 2) Multiplicity matters, not which diagonals
If two diagonals intersect at an interior point, they **cannot share endpoints**, so the \(m\) diagonals through a point form a **matching** (pairwise disjoint edges).

That means the number of Hamiltonian cycles that use \(\ge 2\) of them depends only on \((n,m)\), not on the specific vertices.

### 3) Counting cycles containing edges via contraction + binomial inversion
For the complete graph \(K_n\), the number of Hamiltonian cycles containing a fixed set of \(k\) **disjoint** edges is
\[
A_k = 2^{k-1}(n-k-1)!.
\]
(Contract each forced edge into a super-vertex, count cycles in the smaller complete graph, then expand with 2 orientations per forced edge.)

Let \(c_j\) be the number of cycles that contain exactly \(j\) edges from a matching of size \(m\). Using the identity
\[
\sum_{j\ge k} \binom{j}{k}c_j = \binom{m}{k}A_k,
\]
we obtain \(c_0\) and \(c_1\) by binomial inversion / inclusion–exclusion, and finally
\[
\#(\ge 2) = \text{total} - c_0 - c_1.
\]

### 4) Recovering diagonal multiplicities from geometry
Every interior intersection point with multiplicity \(m\) is produced by exactly \(\binom{m}{2}\) crossing diagonal pairs, each corresponding to exactly one vertex 4‑tuple \((a<b<c<d)\) (using diagonals \((a,c)\) and \((b,d)\)).

So we can:

1. Enumerate all \(a<b<c<d\).
2. Compute the intersection point of diagonals \((a,c)\) and \((b,d)\).
3. Group equal points (via quantized \((x,y)\) keys).
4. For each group count \(q\), recover \(m\) from \(q=\binom{m}{2}\).

### 5) Final assembly
For each \(n\), we sum over all intersection multiplicities \(m\):
\[
T(n) = \sum_m P_m(n)\,g(n,m),
\]
where \(P_m(n)\) is the number of distinct intersection points with \(m\) diagonals, and \(g(n,m)\) is the number of cycles that use at least two edges from an \(m\)-edge matching.

The program validates the statement’s sample values with assertions and prints
\(\sum_{n=3}^{60} T(n)\bmod (10^9+7)\).
