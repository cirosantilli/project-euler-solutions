# Project Euler 541 Solution - Divisibility of Harmonic Number Denominators

<https://projecteuler.net/problem=541>:

* [541.py](541.py)

We need

- \(H_n = \sum_{k=1}^n \frac1k = \frac{a_n}{b_n}\) in lowest terms
- \(M(p)\) = the largest \(n\) such that \(p \nmid b_n\).

The problem asks for \(M(137)\) and provides checks: \(M(3)=68\), \(M(7)=719102\).

## Key ideas

### 1) Convert “\(p \nmid b_n\)” into a modular condition

Let \(e = \lfloor \log_p(n)\rfloor\). Then the highest power of \(p\) that can appear in the unreduced denominator of \(H_n\) is at most \(p^e\).  
A classic trick is to multiply by that power:

\[
p^e H_n = \sum_{k=1}^n \frac{p^e}{k}.
\]

This is always a **\(p\)-adic integer**, and

\[
p \nmid b_n \quad\Longleftrightarrow\quad p^e H_n \equiv 0 \pmod{p^e}.
\]

Crucially, modulo \(p^e\), every term with \(p\nmid k\) vanishes because \(\frac{p^e}{k}\) still contains a factor \(p^e\).  
So only \(k\) that are divisible by \(p\) matter, which makes the condition depend only on counts of multiples of \(p, p^2, \dots\).

### 2) “Block” behavior

For a fixed block \(n \in [pm, pm + (p-1)]\), the set of multiples of \(p^t\) below \(n\) is the same for all \(n\) in the block.  
Therefore the value of \(p^e H_n \bmod p^e\) is **constant on these blocks**, so solutions come in whole blocks.

That means it’s enough to work with the block index \(m=\lfloor n/p \rfloor\) and then take the block maximum \(pm+(p-1)\).

### 3) A tree-lift on base-\(p\) digits

Define a block-value function

\[
V_e(m) \equiv \sum_{t=1}^e p^{e-t}\,U\!\left(\left\lfloor\frac{m}{p^{t-1}}\right\rfloor\right)\pmod{p^e},
\]

where

\[
U(N) = \sum_{1\le k\le N,\;p\nmid k} k^{-1} \pmod{p^s}
\]

is a “unit inverse” harmonic sum.

A key algebraic fact:

- If \(m = pq + a\) (base-\(p\) digit expansion), then \(V_e(m) = p^{e-1}U(m) + V_{e-1}(q)\).
- So if \(V_{e-1}(q)\equiv 0 \pmod{p^{e-1}}\), deciding whether \(m\) is a solution modulo \(p^e\) only depends on a **single digit constraint** involving \(a\).

This gives a **tree**: solutions at level \(e\) only extend from solutions at level \(e-1\), and each node has only a few children.

### 4) Fast computation of \(U(N)\) via a \(p\)-adic series

To compute

\[
U(N) = \sum_{1\le k\le N,\;p\nmid k} k^{-1} \pmod{p^s}
\]

efficiently for huge \(N\), split \(k = ip + j\) with \(j \in \{1,\dots,p-1\}\):

\[
\frac1{ip+j}
= \frac1j\cdot\frac1{1 + \frac{ip}{j}}
\equiv \sum_{m=0}^{s-1} (-1)^m\, i^m p^m\, j^{-(m+1)} \pmod{p^s}.
\]

Then the sum over \(i\) needs power sums \(\sum_{i=0}^{q-1} i^m\) (with \(q=\lfloor N/p\rfloor\)), and the sum over \(j\) is precomputed.

Power sums are computed **without division** using a base-\(p\) recursion, which keeps everything valid even when small primes would break Faulhaber formulas modulo \(p^s\).

## Result

Running `main.py` prints the value of \(M(137)\), and includes asserts for the provided checks \(M(3)\) and \(M(7)\).
