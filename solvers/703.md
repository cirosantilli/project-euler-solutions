# Project Euler 703 Solution - Circular Logic II

<https://projecteuler.net/problem=703>:

* [703.py](703.py)

This solution counts the number of Boolean functions \(T : B^n \to B\) such that
for every state \(x\), the pair \((x, f(x))\) is **never** simultaneously mapped to `true`.
The program outputs \(S(20) \bmod 1{,}001{,}001{,}011\).

## Key ideas

### 1) Functional graph viewpoint
The map \(f : B^n \to B^n\) gives a directed graph where every vertex has **out-degree 1**.
Such graphs are *functional graphs*: each connected component consists of one directed cycle,
with directed in-trees feeding into the cycle.

The constraint

\[
T(x) \land T(f(x)) = \text{false}
\]

means you can’t select both endpoints of any directed edge. Since every vertex appears as
the tail of exactly one edge, this is exactly the **independent set** constraint on the
underlying (undirected) edges \(\{x, f(x)\}\).

So \(S(n)\) = *number of independent sets* in that functional graph.

### 2) Pruning to find cycles (Kahn-style indegree elimination)
To separate trees from cycles efficiently:

- compute indegrees of all nodes
- repeatedly remove nodes with indegree 0, decrementing their successor’s indegree
- what remains are exactly the cycle nodes

This runs in \(O(2^n)\) time and avoids recursion.

### 3) Tree DP absorbed into cycle node “weights”
For every node, consider its incoming nodes (its “children” in the in-tree rooted at its successor).

For a rooted tree, the independent-set DP is:

- `dp0[v]`: ways in the subtree when `v` is **not** chosen  
  \(\prod_{u \in children(v)} (dp0[u] + dp1[u])\)
- `dp1[v]`: ways in the subtree when `v` **is** chosen  
  \(\prod_{u \in children(v)} dp0[u]\)

During pruning, children are processed before their parent, so we can accumulate products
incrementally and end up with `acc0/acc1` values for each cycle node representing the whole
in-tree attached to that node.

### 4) Cycle DP with two boundary cases
After absorbing trees, each cycle node has:

- `weight0` = ways if the cycle node is **not** selected
- `weight1` = ways if the cycle node **is** selected

Now we count independent sets on a cycle with weighted nodes. This is done by converting
it into two path problems:

1. first node **not** selected
2. first node **selected** (which forces the last node **not** selected)

Each path is solved with a simple two-state DP (previous node selected vs not selected).

### 5) Modular arithmetic + memory efficiency
All computations are done modulo the required modulus.
The state space is size \(2^n\), so the implementation uses:

- `array('I')` (32-bit integers) for large numeric arrays
- `bytearray` for boolean markers

This keeps memory usage low enough even for \(n=20\).

## Complexity
Let \(N = 2^n\).

- Time: \(O(N)\)
- Memory: \(O(N)\)
