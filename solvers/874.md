# Project Euler 874 Solution - Maximal Prime Score

<https://projecteuler.net/problem=874>:

* [874.py](874.py)

This solution computes `M(7000, p(7000))`, where:

- `p(t)` is the `(t+1)`-th prime (`p(0)=2`, `p(1)=3`, …).
- The **prime score** of `[a1..an]` is `Σ p(ai)`.
- `M(k, n)` is the maximum prime score among all length‑`n` lists with `0 ≤ ai < k` and `Σ ai ≡ 0 (mod k)`.

## Key ideas

### 1) Start from the best unconstrained list

Because prime numbers increase with the index, each `ai` individually contributes more score when it’s larger.

So without any constraint, the best choice is:

- `ai = k − 1` for all `i`.

Let `top = p(k−1)` be the prime contributed by `k−1`.

### 2) Convert the modular constraint into a “total reduction” problem

Write each element as:

- `ai = (k−1) − di` with `di ≥ 0`.

Then:

- `Σ ai = n·(k−1) − Σ di`.

The constraint `Σ ai ≡ 0 (mod k)` becomes:

- `n·(k−1) − D ≡ 0 (mod k)` where `D = Σ di`.

Since `k−1 ≡ −1 (mod k)`, this means:

- `D ≡ −n (mod k)`.

Let:

- `r = (−n) mod k` with `0 ≤ r < k`.

Any extra reduction by adding multiples of `k` (i.e. using `D = r + mk`) only decreases the score, so the optimum always uses **exactly** `D = r`.

### 3) Minimize score loss for an exact reduction using unbounded knapsack

Reducing one element by `d` changes it from `k−1` to `k−1−d`, which decreases the score by:

- `loss[d] = p(k−1) − p(k−1−d)`.

Now we need to choose reductions `d1, d2, ...` such that:

- `d1 + d2 + ... = r`

and the total loss `loss[d1] + loss[d2] + ...` is minimized.

This is an **unbounded knapsack** / **min‑cost exact sum** DP:

- `dp[s] = minimum loss to achieve total reduction s`
- `dp[0]=0`
- `dp[s] = min(dp[s−d] + loss[d])` for all `d ≤ s`

Finally:

- `M(k,n) = n·p(k−1) − dp[r]`.

### 4) Prime generation with a sieve

We need:
- the first `7000` primes (to know `p(0)` through `p(6999)`), and
- the `7001`‑st prime `p(7000)` for the list length `n`.

A standard sieve of Eratosthenes with a safe upper bound provides these efficiently.

## Included test

The problem statement gives:

- `M(2, 5) = 14`

The code includes an `assert` for this value.
