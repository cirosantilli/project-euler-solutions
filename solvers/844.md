# Project Euler 844 Solution - $k$-Markov Numbers

<https://projecteuler.net/problem=844>:

* [844.py](844.py)

This solver computes:

- A **k-Markov number**: any positive integer that appears in a solution of  
  \[
  \sum_{i=1}^{k} x_i^2 = k \prod_{i=1}^{k} x_i
  \]
- \(M_k(N)\): sum of **distinct** k-Markov numbers \(\le N\)
- \(S(K,N)=\sum_{k=3}^{K} M_k(N)\)

Target: \(S(10^{18},10^{18}) \bmod 1\,405\,695\,061\).

---

## Core techniques

### 1) Vieta jumping / root flipping (tree of solutions)
Fix all variables except one \(x\). The equation is quadratic in \(x\), and if \(x\) is one
integer root, the other root is:

\[
x' = k\left(\prod_{j\ne i}x_j\right) - x
\]

Replacing \(x\) with \(x'\) keeps a valid integer solution. Repeating these “jumps”
generates all solutions from the all-ones solution, and **increasing jumps** form a tree.

The code explores only solutions with `max(entry) <= N`, which is enough because any k-Markov
number \(m \le N\) appears in some solution whose maximum is \(\le m\).

---

### 2) Compressed state representation
Many solutions contain lots of 1s. Instead of storing all \(k\) coordinates, a state stores only:

- the **sorted tuple of non-1 entries**,
- the number of ones is implicit: `ones = k - len(non_ones)`.

This makes the search fast even when \(k\) is large.

---

### 3) A cutoff that eliminates “3 non-1” solutions
To create the **third** non-1 value from the all-ones solution with increasing jumps:

- \(a_1 = k-1\)
- \(a_2 = k(k-1)-1\)
- \(a_{3,\min} = k(k-1)a_2 - 1 = k^4 - 2k^3 + k - 1\)

If \(a_{3,\min} > N\), then **no** solution with maximum \(\le N\) can contain 3 (or more)
non-1 entries. So for all \(k\) above the cutoff, every relevant solution has **at most two**
non-1 entries.

For \(N=10^{18}\), this cutoff is about \(N^{1/4}\) (≈ 3×10⁴), so only a small prefix of k
needs explicit enumeration.

---

### 4) Closed forms for the large-k tail
When \(k\) is above the cutoff, only the “two non-1” chain matters, and (because the 4th chain
term exceeds \(N\) in this regime) \(M_k(N)\) collapses into simple polynomials:

- If \(a_3(k)\le N\): \(M_k(N)=k^3-2k\)
- Else if \(a_2(k)\le N\): \(M_k(N)=k^2-1\)
- Else: \(M_k(N)=k\)

So most of \(S(K,N)\) becomes sums of \(k\), \(k^2\), \(k^3\) over huge ranges, computed with
integer closed forms and reduced mod \(1\,405\,695\,061\).

---

## Validation
The program includes asserts for all values supplied by the problem statement:

- \(M_3(10^3)=2797\)
- \(M_8(10^8)=131493335\)
- \(S(4,10^2)=229\)
- \(S(10,10^8)=2383369980\)

---

## Run
```bash
python3 main.py
```

It prints the required value modulo \(1\,405\,695\,061\).
