# Project Euler 486 Solution - Palindrome-containing Strings

<https://projecteuler.net/problem=486>:

* [486.py](486.py)

We work with binary strings (over `{0,1}`).

- `F₅(n)`: number of strings of length **at most** `n` that contain a palindromic substring of length **at least 5**.
- `D(L)`: number of integers `n` with `5 ≤ n ≤ L` such that `F₅(n)` is divisible by `87654321`.
- Goal: compute `D(10¹⁸)`.

## 1) Reduce “palindrome length ≥ 5” to local constraints

Any palindrome of length ≥ 7 contains a palindromic substring of length 5 (odd case) or 6 (even case) at its center.  
So it’s enough to detect palindromes of **length 5 or 6**.

Instead of counting strings that **contain** such a palindrome, count the complement:

- `A(n)`: number of binary strings of **exact** length `n` that avoid palindromic substrings of length 5 and 6.
- `B(n) = Σ_{k=0..n} A(k)`: number of palindrome-free strings of length ≤ `n`.

Total binary strings of length ≤ `n` is `2^(n+1) - 1` (including the empty string), so:

\[
F_5(n) = (2^{n+1}-1) - B(n)
\]

## 2) Regular language → tiny automaton → eventual periodicity

Avoiding palindromes of length 5 and 6 is a *regular* constraint: when you append a bit, you only need the last 5 bits to decide whether a forbidden length-5 or length-6 palindrome ends at the new position.

Computing `A(n)` from this automaton shows a striking fact:

- `A(0..6) = 1, 2, 4, 8, 16, 24, 30`
- For `n ≥ 7`, `A(n)` becomes **periodic with period 6**:

\[
A(7..12) = [32, 32, 32, 34, 36, 34] \text{ and it repeats forever.}
\]

Therefore `B(n)` is an *affine* function of `q = ⌊(n-6)/6⌋` with a 6-way lookup table for the remainder.

## 3) Turn the divisibility test into a modular equation

We want:

\[
F_5(n) \equiv 0 \pmod{M}, \quad M = 87654321
\]

Using `F₅(n) = 2^{n+1} - 1 - B(n)`:

\[
2^{n+1} \equiv 1 + B(n) \pmod{M}
\]

Write `n = 6q + r + 6` with `r ∈ {0,1,2,3,4,5}`.  
Because of the period-6 structure of `B(n)`:

\[
1 + B(n) \equiv C_r + 200q \pmod{M}
\]

Also:

\[
2^{n+1} = 2^{6q+r+7} = 2^{r+7} \cdot 64^{q}
\]

So for each fixed `r` we solve:

\[
2^{r+7}\cdot 64^{q} \equiv C_r + 200q \pmod{M}
\]

## 4) Use the multiplicative order of 64 and CRT to enumerate residues

Let `o = ord_M(64)`. Here:

- `ord_9(64) = 1`
- `ord_1997(64) = 998`
- `ord_4877(64) = 2438`

so `o = lcm(1, 998, 2438) = 1,216,562`.

Let `k = q mod o`. Then `64^q mod M` depends only on `k`, so the left side is known once `k` is known.

The equation becomes **linear in `q (mod M)`**:

\[
200q \equiv (2^{r+7}\cdot 64^{k} - C_r) \pmod{M}
\]

Since `gcd(200, M) = 1`, this determines a unique `q (mod M)` for each `k`.

Now we have two congruences:

- `q ≡ k (mod o)`
- `q ≡ q₀(k) (mod M)`

and `gcd(o, M)=1`, so CRT gives a unique residue `q_res (mod M·o)`.

As `k` ranges from `0..o-1`, we get **exactly one** solution residue per `k`.

## 5) Count up to L without per-solution divisions

For a fixed `r`, the allowed `q` are `0 ≤ q ≤ q_max`, where `q_max = ⌊(L-r-6)/6⌋`.

Solutions repeat modulo `Lq = M·o`. Let `N = q_max+1`, and write:

- `N = Q·Lq + R` with `0 ≤ R < Lq`

Then every residue occurs `Q` times, and residues `< R` occur one extra time.

So the count is:

\[
\text{solutions}(r) = Q\cdot o + \#\{q_\text{res} < R\}
\]

We compute `# { q_res < R }` by a simple comparison while enumerating `k = 0..o-1`.

## Complexity

- Time: `O(o)` modular steps, where `o = 1,216,562`.
- Memory: `O(1)`.

The implementation also validates the sample values from the statement using `assert`.
