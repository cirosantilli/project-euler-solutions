# Project Euler 467 Solution - Superinteger

<https://projecteuler.net/problem=467>:

* [467.py](467.py)

This solution computes:

- `P^D`: the digital roots of the prime numbers
- `C^D`: the digital roots of the composite numbers
- `P_n`, `C_n`: the first `n` digits of those sequences
- `f(n)`: the **smallest positive integer** whose digits contain both `P_n` and `C_n` as subsequences

The required output is `f(10_000) mod 1_000_000_007`.

## Key idea: smallest common superinteger = lexicographically smallest shortest common supersequence

Treat `P_n` and `C_n` as two strings (here: digit sequences in `1..9`).

A number `s` is a *common superinteger* iff it is a **common supersequence** of both strings.
Among all such `s`, the **smallest integer** is obtained by:

1. minimizing the length (any shorter digit string is always a smaller positive integer),
2. among equal lengths, taking the **lexicographically smallest** digit string.

That is exactly the **lexicographically smallest shortest common supersequence (SCS)** problem.

Also, for strings `A`, `B`:

- `|SCS(A,B)| = |A| + |B| - |LCS(A,B)|`

So optimal choices can be guided by **LCS lengths** of suffixes.

## Fast LCS lengths with bit-parallel DP

A standard bit-vector (bit-parallel) LCS-length algorithm keeps a bitset `D` and updates it per character:

- Precompute `matches[d]`: bit `i` is 1 iff `X[i] == d`.
- For each character `ch` of `Y`:

```
U = D | matches[ch]
V = (U - ((D << 1) | 1)) mod 2^n
D = U & ~V
```

After processing a prefix of `Y`, `popcount(D)` equals the LCS length against the full `X`.

### Turning suffix queries into prefix queries

The greedy SCS reconstruction needs LCS lengths of many suffix pairs `LCS(A[i:], B[j:])`.

Reverse both strings:

- `X = reverse(A)`
- `Y = reverse(B)`

Then:

- `LCS(A[i:], B[j:]) == LCS(X[:n-i], Y[:n-j])`

So we store the DP bitset `D` after every prefix of `Y` (an array `rows[b]`).
A prefix-length query is answered by counting set bits in a masked prefix:

- `LCS(X[:a], Y[:b]) = popcount(rows[b] & ((1<<a)-1))`

This makes each LCS query **very fast**.

## Greedy construction of the smallest shortest SCS

Let `L(i,j) = LCS(A[i:], B[j:])`. For `A[i] != B[j]`:

- `L(i,j) = max(L(i+1,j), L(i,j+1))`

To keep the SCS as short as possible we choose the branch that keeps the LCS maximal:

- if `L(i+1,j) > L(i,j+1)` → take `A[i]`
- if `L(i+1,j) < L(i,j+1)` → take `B[j]`
- if equal → both lengths are optimal, so take the **smaller next digit** for lexicographic minimality

If `A[i] == B[j]`, we always take that digit and advance both pointers.

While constructing the digit string, we update the modulo value incrementally:

- `value = (value * 10 + digit) mod M`

## Complexity

For `n = 10_000`:

- Sieve to generate primes and composites: well under a second in Python.
- Bit-parallel LCS DP: `O(n^2 / word_size)` big-int operations; very fast in practice.
- Greedy SCS reconstruction: `O(|SCS|)` LCS queries (≈ up to 20,000), each using a couple of big-int ops.

Memory:

- `rows`: ~10,001 Python integers holding 10,000-bit bitsets.
- a small list of prefix masks.

## Correctness checks (from the statement)

The code asserts:

- `P_10 = 2357248152`
- `C_10 = 4689135679`
- `f(10) = 2357246891352679`
- `f(100) mod 1_000_000_007 = 771661825`
