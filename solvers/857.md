# Project Euler 857 Solution - Beautiful Graphs

<https://projecteuler.net/problem=857>:

* [857.py](857.py)

This repository contains a standalone Python solution (`main.py`) that prints `G(10^7)` modulo `10^9+7`.

## Main techniques used

### 1) Structural reduction to an ordered partition

Call an edge **undirected** if it is green or brown, and a **directed-pair** if it is red/blue (one direction red, the opposite direction blue).

Define a relation on vertices:

- `u ~ v` iff the edge `{u,v}` is undirected.

The “every directed cycle contains red iff it contains blue” rule implies:

- If `u ~ v` and `v ~ w`, then `{u,w}` cannot be a directed-pair: otherwise you can go along the red direction of `{u,w}` and return from `w` to `u` using undirected edges, producing a directed cycle that has red but no blue.

So `~` is transitive and therefore an **equivalence relation**. The vertices split into blocks (equivalence classes) where:

- **inside a block**: every edge is undirected (green/brown)
- **between two different blocks**: every edge must be a directed-pair

Next, between two blocks `A` and `B`, all directed-pair edges must share the same red direction. If not, you can pick `a1,a2 ∈ A` and `b ∈ B` with conflicting red directions and form a directed cycle using two red steps and one undirected step inside `A`.

Thus each block-to-block relation is oriented one way, giving a tournament on blocks. The same cycle rule forbids a directed cycle of red edges among blocks, so the tournament is **acyclic**, hence **transitive**, hence the blocks are **totally ordered**.

In short: every beautiful graph corresponds to an **ordered partition** of the vertices into blocks.

### 2) Ramsey restriction inside blocks

Inside a block, every edge is either green or brown. The second condition (“no all-green or all-brown triangle”) means the 2-colouring of the complete graph on that block has **no monochromatic triangle**.

By the classic Ramsey fact `R(3,3)=6`, such a colouring can exist only for block sizes `≤ 5`. Therefore every ordered partition uses parts of size at most 5.

For each block size `s ∈ {1,2,3,4,5}`, the solution precomputes `a_s`, the number of valid green/brown colourings of `K_s`, by brute force (at most `2^10 = 1024` colourings).

### 3) Counting via a constant-coefficient recurrence

For an ordered partition with block sizes `(s1, s2, ..., sk)`:

- choose which labels go into each block (a multinomial factor)
- multiply by the independent internal counts `a_{si}`
- all edges between blocks are forced by the block order

This yields a simple recurrence:

- `G(0) = 1`
- `G(n) = Σ_{s=1..5} C(n,s) * a_s * G(n-s)`

For large `n` modulo a prime, we convert to a constant-coefficient recurrence by dividing by `n!`:

- Let `f_n = G(n) / n!`.
- Then `f_n = Σ_{s=1..5} (a_s / s!) * f_{n-s}`.

Now `f_n` is computed in `O(n)` time using only the last five values (rolling window), while `n! mod MOD` is accumulated in the same loop.

## Complexity

- Precomputation of `a_s`: negligible (≤ 1024 cases).
- Main loop for `n = 10^7`: `O(n)` arithmetic operations.
- Memory: `O(1)` beyond a handful of integers.
