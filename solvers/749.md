# Project Euler 749 Solution - Near Power Sums

<https://projecteuler.net/problem=749>:

* [749.py](749.py)

This solution computes:

- A **near power sum** is a positive integer `n` such that for some integer `k ≥ 1`,
  the sum of the `k`-th powers of its decimal digits equals `n-1` or `n+1`.
- `S(d)` is the sum of all near power sums with at most `d` digits.
- The program prints `S(16)` and asserts the statement’s test values `S(2)` and `S(6)`.

## Core ideas

### 1) Enumerate digit multisets instead of numbers
`n` is determined by its digit multiset (how many 0s, 1s, …, 9s it contains).

For a fixed multiset `c_d` and exponent `k`:

```
t(k) = Σ c_d * d^k
```

If `n` is a near power sum for this `k`, then `n` must be either `t(k)-1` or `t(k)+1`,
*and* `n` must have **exactly the same digit multiset**.

Enumerating multisets up to 16 digits is feasible (stars-and-bars), while enumerating all 16‑digit numbers is not.

### 2) Tighten the search with magnitude bounds on `k`
Let `m` be the maximum digit present in the multiset, and `c_m` its count.

We always have:

- `c_m * m^k ≤ t(k) ≤ L * m^k` where `L` is the digit length.

Because `n` has `L` digits and `t(k) = n±1`, we only need `k` such that:

- `10^(L-1) - 1 ≤ t(k) ≤ 10^L`.

Using the inequalities above gives a small candidate range of `k` for each `(L, m, c_m)`,
often just 1–3 values, dramatically reducing work.

### 3) Fast “same digits” checks via packed digit-count signatures
A digit multiset is encoded as a single integer with 5 bits per digit:

```
sig = Σ count[d] << (5*d)
```

Counts never exceed 16, so 5 bits per digit is enough.

To compute a candidate number’s signature quickly, the code splits the number into **4‑digit chunks**
and uses precomputed tables for those chunks. This avoids per-digit loops over large integers.

## What the code outputs
Running `python3 main.py` prints `S(16)` and performs assertions for the given examples.
