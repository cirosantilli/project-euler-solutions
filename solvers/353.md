# Project Euler 353 Solution - Risky Moon

<https://projecteuler.net/problem=353>:

* [353.py](353.py)

This solution computes the minimum “risk” for travelling from the North Pole station to the South Pole station on the integer lattice points of a sphere.

## Key ideas

### 1) Generate lattice points on the sphere efficiently
For a fixed radius `r`, stations satisfy:

- `x^2 + y^2 + z^2 = r^2`, with integers `(x,y,z)`.

Iterate over `z ≥ 0` (only the northern hemisphere is needed for the later symmetry reduction). For each `z`:

- `x^2 + y^2 = r^2 - z^2 = (r - z)(r + z)`.

Because both factors are at most `2r`, we can factor them quickly using a smallest-prime-factor sieve up to `2*(2^15-1)`.  
From the prime factorization, all integer solutions of `x^2 + y^2 = N` can be enumerated using the multiplicative structure of Gaussian integers:

- primes `≡ 3 (mod 4)` must appear with even exponent
- primes `≡ 1 (mod 4)` contribute combinations via splitting exponents between a Gaussian prime and its conjugate
- square factors are pulled out as a plain integer multiplier

This produces all `(x,y)` pairs for each `z`, and expanding signs/swaps yields all points with that `z`.

### 2) Use an equatorial symmetry reduction
Let `N = (0,0,r)` and `S = (0,0,-r)`. Reflecting a station across the equator sends:

- `(x,y,z) → (x,y,-z)`.

Because the station set and the edge-risk definition are symmetric under this reflection, an optimal journey can be chosen to be symmetric as well. This reduces the full problem to:

- Run Dijkstra from `N` to compute `dist(N,p)` for `z(p) ≥ 0`
- For each such `p`, consider a symmetric completion through the “reflection edge” `p → reflect(p)`:

`M(r) = min_p ( 2*dist(N,p) + risk(p, reflect(p)) )`.

The reflection-edge risk depends only on `z`, so it is precomputed once per `r`.

### 3) Avoid the complete graph with spatial hashing
Every pair of stations is connected in principle, but using the full graph is too large.

Instead, the program builds a **local neighbor graph**:
two points are connected only if their coordinate differences satisfy:

- `|dx|, |dy|, |dz| ≤ L`

for a radius-dependent threshold `L`. A 3D grid (hash map from cell coordinates to point indices) lets us query candidate neighbors in nearby cells in roughly constant expected time.

Dijkstra’s algorithm is then run on this sparse graph using a binary heap (`heapq`).

## Output
The program prints the required sum for `r = 2^n - 1` (for `n=1..15`) formatted to 10 digits after the decimal point. No final numeric constant is embedded in the code.
