# Project Euler 740 Solution - Secret Santa

<https://projecteuler.net/problem=740>:

* [740.py](740.py)

This solution models the process as a **finite Markov chain** and evaluates the desired probability with **dynamic programming over compressed states**.

## Key ideas

### 1) Symmetry / exchangeability
All non-last participants are initially identical. When we only keep track of aggregate counts (how many people have 0/1/2 slips remaining), the identity of “who goes next” does not matter for the distribution of these aggregates. This lets us treat the next drawer as a uniformly random unprocessed person in that aggregate state.

### 2) State compression
A naïve state would track how many slips remain for every person, which is infeasible.

We compress everything into:

- `u1`: number of **unprocessed** (not yet drawn) non-last people with **1** slip left in the hat  
- `u2`: number of **unprocessed** non-last people with **2** slips left  
- `k`: how many slips of the **last** person remain (`0..2`)  
- `sp`: total number of slips in the hat that belong to **processed** people (they will never draw again)

The important observation is that, once a person is processed, their remaining slips behave like an **indistinguishable pool**: future draws only care about the *total* number of such slips, not how they are split across processed names.

### 3) Two-step transition per person
Each person draws **two** slips sequentially. For each draw:

- the draw is uniform among slips **excluding** the drawer’s own remaining slips
- removing a slip updates `(u1, u2, k, sp)` depending on whether it belonged to:
  - the last person (`k` decreases),
  - an unprocessed person with 1 slip (moves `1 → 0`),
  - an unprocessed person with 2 slips (moves `2 → 1`),
  - the processed slip pool (`sp` decreases)

After the two draws, the drawer becomes processed and their remaining slips are added into `sp`.

### 4) Complexity
The number of reachable compressed states is small (a few thousand for `n=100`), so iterating all transitions is fast in pure Python.

## Running
```bash
python3 main.py
```

The program asserts the example probabilities (rounded to 10 decimals) from the statement, then prints `q(100)` rounded to 10 decimal places.
