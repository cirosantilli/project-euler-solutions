# Project Euler 520 Solution - Simbers

<https://projecteuler.net/problem=520>:

* [520.py](520.py)

## Key idea: count by digit–occurrence constraints using EGFs

For a length-`k` digit string, if the digit counts are `c_0, …, c_9`, then the number of strings with those counts is:

`k! / (c_0! c_1! … c_9!)`.

This makes **exponential generating functions (EGFs)** natural:

- If a digit may appear in counts from a set `S`, its EGF factor is  
  `f(x) = Σ_{c∈S} x^c / c!`.

Then the number of length-`k` strings satisfying all digit constraints is:

`A_k = k! · [x^k] Π_d f_d(x)`.

## Turn the “simber” constraints into simple EGF factors

- Even digits (including `0`) must occur an **even** number of times:  
  `Σ_{c even ≥ 0} x^c/c! = cosh(x)`.

- Odd digits may occur either **0 times** or an **odd** number of times:  
  `1 + Σ_{c odd ≥ 1} x^c/c! = 1 + sinh(x)`.

So (ignoring the “no leading zero” rule), for 5 even digits and 5 odd digits:

`F(x) = cosh(x)^5 · (1+sinh(x))^5`,  
and `A_k = k!·[x^k]F(x)`.

## Handle the “no leading zero” rule by subtraction

Let `B_k` be the number of valid **k-digit numbers** (first digit nonzero).

Count all valid length-`k` strings (`A_k`) and subtract those whose first digit is `0`.

Fixing the first digit to `0` forces the remaining `k-1` positions to have an **odd** number of `0`s (so that total `0` count is even). The EGF for `0` becomes `sinh(x)` (odd counts only), while other digits stay the same:

`G(x) = sinh(x) · cosh(x)^4 · (1+sinh(x))^5`,  
`C_m = m!·[x^m]G(x)` counts the length-`m` remainders.

Thus:

`B_k = A_k − C_{k−1}`.

And the required function is:

`Q(n) = Σ_{k=1..n} B_k`.

## Convert coefficient extraction into small sums of powers

Use:

- `cosh(x) = (e^x + e^{-x})/2`
- `sinh(x) = (e^x − e^{-x})/2`

So `F(x)` and `G(x)` become **Laurent polynomials** in `E = e^x`, i.e.

`F(x) = Σ_t α_t e^{t x}`, `G(x) = Σ_t β_t e^{t x}`,

where `t` ranges only from `−10..10`.

Then the EGF coefficient identity gives:

`k!·[x^k] e^{t x} = t^k`,

so:

- `A_k = Σ_t α_t t^k`
- `C_m = Σ_t β_t t^m`

This reduces counting to **21 terms**.

## Prefix sums are geometric series

`Q(n)` needs sums like `Σ_{k=1..n} t^k` and `Σ_{m=0..n−1} t^m`, which are geometric series and can be computed with fast modular exponentiation.

Special cases:
- `t = 0` and `t = 1` are handled directly.

## Complexity

Each `Q(n)` evaluation costs `O(21)` modular exponentiations, each `O(log n)`.  
The final answer is `Σ_{u=1..39} Q(2^u) mod 1,000,000,123`, which is fast.

The implementation also includes the two asserts given in the problem statement:
- `Q(7) = 287975`
- `Q(100) mod 1,000,000,123 = 123864868`
