# Project Euler 253 Solution - Tidying Up A

<https://projecteuler.net/problem=253>:

* [253.py](253.py)

This solution computes the **exact** expected value of `M`, the maximum number of contiguous segments encountered while placing pieces `1..N` in a random order.

For `N=40`, it prints the answer rounded to 6 decimals.

---

## Core techniques used

### 1) State compression via *gap lengths*
At any moment, the placed pieces form contiguous **segments** on the line.  
Instead of storing which positions are filled, we store only the lengths of the **empty gaps**:

- Two **edge gaps**: left of the leftmost segment and right of the rightmost segment  
- A multiset of **internal gaps** between neighboring segments

The **segment lengths don’t matter** for future evolution — only the empty gap lengths do — so this is a valid Markov state compression.

The state is canonicalized as:

- Edge gaps stored unordered as `(min_edge, max_edge)`
- Internal gaps stored as a sorted tuple (multiset)

---

### 2) Enumerating transitions with multiplicities
From a given gap-length state, placing the next piece is equivalent to choosing one of the remaining empty positions.

Instead of iterating every position explicitly, we group choices that produce the same next compressed state and add a **multiplicity**:

- **Internal gap** of length `g`:
  - `g=1`: filling it merges two segments (gap removed)
  - `g>1`: choosing an end extends a segment (gap becomes `g-1`)
  - choosing an interior point creates a new segment and splits the gap

- **Edge gap** of length `g`:
  - choosing the position adjacent to the segment extends it (gap becomes `g-1`)
  - choosing any other position creates a new segment, turning part of the edge gap into an internal gap

All resulting next states are collected with their counts of position-choices.

---

### 3) Exact counting DP over permutations
We do a step-by-step dynamic programming over the number of placed pieces:

`dp[state][max_so_far] = number_of_prefixes (partial permutations) producing this state and max`

Each transition multiplies counts by the transition multiplicity.

After `N` steps, only the fully-filled state remains, and the DP yields the exact distribution of `M`.

---

### 4) Using the distribution to get the expectation
From the final distribution:

- `count[M] = number of permutations with maximum segment count equal to M`
- Total permutations = `N!`

Then:

`E[M] = sum(M * count[M]) / N!`

We compute this exactly with big integers and convert to `Decimal` for correct rounding to 6 decimal places.

---

## Checks from the problem statement
The code includes asserts for `N=10`:

- Distribution:
  - `M=1: 512`
  - `M=2: 250912`
  - `M=3: 1815264`
  - `M=4: 1418112`
  - `M=5: 144000`
- Mean:
  - `385643/113400 = 3.400732...`

---

## Run

```bash
python3 main.py
