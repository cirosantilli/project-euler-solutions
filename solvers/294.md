# Project Euler 294 Solution - Sum of Digits - Experience #23

<https://projecteuler.net/problem=294>:

* [294.py](294.py)

We need to count digit strings of length `n` (i.e. numbers `k < 10^n`) such that:

- `k ≡ 0 (mod 23)`
- the decimal digit sum `d(k) = 23`

Because `d(k) = 23`, the number is automatically positive, so we can safely count length-`n` strings **with leading zeros**.

## Key techniques

### 1) Digit DP as a generating function

Each digit position contributes independently:

- digit sum contribution: `d`
- remainder contribution: `d * 10^pos (mod 23)`

So the whole problem is a coefficient extraction from a product of per-position generating functions.

### 2) Periodicity of `10^pos (mod 23)`

Since 23 is prime and `gcd(10,23)=1`, Fermat’s little theorem gives:

- `10^22 ≡ 1 (mod 23)`

Therefore `10^pos (mod 23)` repeats with period `22`.

That means all positions with the same `pos mod 22` have the **same** remainder “weight”.

### 3) Group positions by residue class (mod 22)

Let `N_r` be the number of positions `pos` with `pos ≡ r (mod 22)`.
For each residue `r`, all those positions share one generating function:

`F_r(x, y) = Σ_{d=0..9} x^d · y^{d·w_r}`  
where `w_r = 10^r (mod 23)` and `y` tracks the remainder class.

The full generating function is:

`Π_{r=0..21} F_r(x,y)^{N_r}`

We want the coefficient of:

- `x^23` (digit sum 23)
- remainder `0 mod 23`

### 4) Truncate aggressively (degree ≤ 23)

We only care about digit sum 23, so all polynomials are truncated to degree 23.
This keeps state size tiny.

### 5) Binomial theorem for huge exponents

For each residue class:

`F_r = 1 + H_r` where `H_r` has no constant term.

Then:

`F_r^{N_r} = (1 + H_r)^{N_r} = Σ_{m=0..23} C(N_r,m) · H_r^m`

We can stop at `m=23` because higher powers can’t contribute to degree ≤ 23.

This avoids expensive matrix exponentiation with exponent `n = 11^12`.

## Complexity

- Only 22 residue classes.
- Degree is capped at 23.
- Remainders are only 23 values.

So the whole computation runs quickly in pure Python.

## Implementation notes

- Polynomials are stored as a flattened array indexed by `(degree, remainder)`.
- Multiplication does convolution in `degree` and cyclic convolution in `remainder (mod 23)`.
- The final answer required by the problem is `S(11^12) mod 10^9`.
