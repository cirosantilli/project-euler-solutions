# Project Euler 621 Solution - Expressing an Integer as the Sum of Triangular Numbers

<https://projecteuler.net/problem=621>:

* [621.py](621.py)

## Key transformation: triangular numbers → odd squares

A triangular number is:

- \(T_k = \frac{k(k+1)}{2}\)

It satisfies the identity:

- \(8T_k + 1 = (2k+1)^2\)

So a representation

- \(n = T_a + T_b + T_c\)

is equivalent to

- \((2a+1)^2 + (2b+1)^2 + (2c+1)^2 = 8n + 3\)

Let \(N = 8n+3\). Because \(N \equiv 3 \pmod 8\), every representation of \(N\) as a sum of three squares has *all three squares \(\equiv 1 \pmod 8\)*, hence all three integers are odd automatically.

If we count **ordered integer triples with signs** \((x,y,z)\in\mathbb{Z}^3\) such that:

- \(x^2 + y^2 + z^2 = N\)

then each positive-odd triple corresponds to exactly \(2^3=8\) signed versions, so:

- \(G(n) = \dfrac{r_3(N)}{8}\)

where \(r_3(N)\) is the “sum of three squares” representation count that includes order and signs.

## Gauss/Cohen formula for \(r_3(N)\) (the only case we need)

Write:

- \(N = n_0 \, f^2\) where \(n_0\) is squarefree (the squarefree kernel of \(N\))

For \(N \equiv 3 \pmod 8\), one has \(n_0 \equiv 3 \pmod 4\), and the corresponding negative **fundamental discriminant** is:

- \(D = -n_0\)

A classical formula (Gauss; modern presentation by Cohen) gives:

- \(r_3(N) = 12 \, L(\chi_D,0)\, \bigl(1-(D/2)\bigr)\, \sum_{d\mid f} \mu(d)\, (D/d)\, \sigma(f/d)\)

For our congruence class \(D\equiv 5 \pmod 8\), \((D/2)=-1\), so the factor becomes \(2\), and therefore:

- \(G(n) = \dfrac{r_3(N)}{8} = 3 \, L(\chi_D,0)\, \sum_{d\mid f} \mu(d)\, (D/d)\, \sigma(f/d)\)

Also:

- \(L(\chi_D,0) = \dfrac{h(D)}{w(D)/2}\)

where \(h(D)\) is the imaginary quadratic **class number**, and \(w(D)\in\{2,4,6\}\) counts roots of unity (only \(D=-3\) and \(D=-4\) are special).

Since \(\mu(d)=0\) whenever \(d\) is not squarefree, the divisor sum only needs squarefree \(d\), so it can be done by iterating over subsets of primes dividing \(f\).

## Computing the class number \(h(D)\) exactly

For negative discriminants, \(h(D)\) equals the number of **reduced** primitive positive definite binary quadratic forms \((a,b,c)\) with:

- \(b^2 - 4ac = D\)

Reduced forms satisfy:

- \(|b|\le a \le c\), and if \(|b|=a\) or \(a=c\) then \(b\ge 0\)

A standard bound gives \(a \le \sqrt{|D|/3}\), so we can enumerate all reduced forms by looping over \(a\) up to that limit. For each \(a\), instead of scanning all \(b\in[-a,a]\) (which is too slow), we solve the congruence:

- \(b^2 \equiv D \pmod{4a}\)

In this problem’s discriminant class (\(D\equiv 5 \pmod 8\)), it turns out that **only odd** \(a\) contribute, and the congruence can be handled efficiently by:

- factoring \(a\) via a smallest-prime-factor sieve
- finding square roots modulo each prime power using **Tonelli–Shanks** + **Hensel lifting**
- combining them with **CRT**

Each valid residue produces at most one candidate \(b\) in \([-a,a]\) with the required parity, and then \(c\) follows from \(c=(b^2-D)/(4a)\).

## Implementation techniques used

- Deterministic Miller–Rabin (64-bit) + Pollard–Rho for integer factorization
- Tonelli–Shanks modular square root (odd primes)
- Hensel lifting to prime powers
- Chinese Remainder Theorem to combine modular roots
- Reduced binary quadratic form enumeration to compute class numbers
- Subset enumeration over prime divisors for the Möbius-weighted divisor sum

The included `main.py` asserts the sample values from the problem statement and prints the required answer.
