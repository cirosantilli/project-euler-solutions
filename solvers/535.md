# Project Euler 535 Solution - Fractal Sequence

<https://projecteuler.net/problem=535>:

* [535.py](535.py)

This solution avoids constructing the sequence.

## Key observations

The sequence contains two kinds of terms:

- **Circled terms**: the first occurrence of each integer, so the circled values are exactly `1, 2, 3, ...` in order.
- **Non‑circled terms**: if you remove all circled terms, the remaining sequence is identical to the original `S`
  (self‑similar / fractal property).

A defining rule links them:

- Immediately before a non‑circled value `x`, there are exactly `⌊√x⌋` adjacent circled values.

## Turning the definition into equations

Let:

- `T(n) = sum_{i=1..n} S_i`
- `G(n) = sum_{i=1..n} ⌊√(S_i)⌋`
- `phi(n)` = number of non‑circled terms among the first `n` terms.

For the first `n` terms:

- There are `m = n - phi(n)` circled terms, and their **values are exactly** `1..m`.
- The non‑circled terms (in order) are exactly `S_1..S_{phi(n)}`.

So we get:

- `T(n) = T(phi(n)) + (1 + 2 + ... + m)`
- `G(n) = G(phi(n)) + Σ_{k=1..m} ⌊√k⌋`

The position of the `r`‑th non‑circled term is:

- `P(r) = r + G(r)`

because each of the first `r` non‑circled values contributes `⌊√x⌋` circled terms immediately before it.

Therefore:

- `phi(n) = max r such that r + G(r) ≤ n`

## Fast helper sums (O(1))

Two summations appear repeatedly:

1. `1 + 2 + ... + m = m(m+1)/2`
2. `Σ_{k=1..m} ⌊√k⌋` can be computed in O(1) by grouping ranges where `⌊√k⌋` is constant:
   - `⌊√k⌋ = t` for `k ∈ [t², (t+1)² - 1]` (count `2t+1`)

This reduces the √-sum to simple polynomial formulas.

## Computing `phi(n)`

`r + G(r)` is strictly increasing, so `phi(n)` is found by binary search over `r ∈ [0, n-1]`,
using memoized `G(r)` calls.

## Performance

Each evaluation reduces the problem size from `n` to `phi(n)` (much smaller), and memoization ensures
each needed `T(n)`, `G(n)`, and `phi(n)` is computed once.

The final program computes the requested result quickly using only integer arithmetic.
