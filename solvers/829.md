# Project Euler 829 Solution - Integral Fusion

<https://projecteuler.net/problem=829>:

* [829.py](829.py)

This repository contains a reference implementation for **Project Euler 829**.
It computes

\[
\sum_{n=2}^{31} M(n)
\]

where `M(n)` is the smallest integer whose *binary factor tree* has the same **unlabelled shape** as the binary factor tree of `n!!`.

## Key ideas and techniques

### 1) Canonical factor-tree shape
A number’s factor tree is deterministic:

- If `n` is prime, the tree is a single leaf.
- Otherwise, split `n = a·b` with `a ≤ b` and minimal difference `b - a`.
  This is equivalent to choosing the **largest divisor `a` with `a ≤ √n`**.

The implementation represents the unlabelled shape as nested tuples:

- `None` for a leaf (prime node)
- `(left_shape, right_shape)` for an internal (composite) node

and memoizes `shape_of(n)`.

### 2) Fast primality testing and factoring (64-bit)
All numbers needed for this problem fit within 64 bits because `M(n) ≤ n!! ≤ 31!!`.

To work efficiently:

- **Deterministic Miller–Rabin** is used for primality checks on `n < 2^64`.
- **Pollard Rho (Brent variant)** is used to factor composites quickly.
- Results are cached to avoid repeated work.

### 3) Finding the “closest-to-√n” divisor via meet-in-the-middle
Given the prime factorization of `n`, the best split needs the largest divisor `d ≤ √n`.

Instead of scanning down from `⌊√n⌋`, the code:

1. Splits the prime-power list into two halves.
2. Enumerates all partial products (divisors) in each half.
3. For each `a` in the left list, binary-searches the right list for the largest `b` with `a·b ≤ √n`.

This yields the optimal divisor efficiently even when `n` has many divisors.

### 4) Computing `M(n)` via lazy enumeration by shape
For a fixed shape `S`, define the set of all integers whose factor-tree shape equals `S`.

The key observation is that any composite root shape `(L, R)` must be some product `x·y` where

- `shape_of(x) = L`
- `shape_of(y) = R`
- `x ≤ y`

The implementation builds, for every shape seen in the target instances, a **lazy increasing sequence** of values that realize that shape.

For an internal shape, candidates are generated as a **k-way merge** of the sorted lists
`left[i]·right[j]` (subject to `left[i] ≤ right[j]`) using a min-heap. Each candidate is verified by computing `shape_of(candidate)`.

The **first** value produced by this sequence is precisely the minimal value for the shape — i.e., the required `M(n)`.

### 5) Validation
The problem statement provides the check value:

- `M(9) = 72`

The program asserts this and then prints the requested sum.

## Files

- `main.py` — solution implementation (prints the final result when run)
