# Project Euler 362 Solution - Squarefree Factors

<https://projecteuler.net/problem=362>:

* [362.py](362.py)

We want

- **Fsf(n)**: the number of factorizations of `n` into **squarefree** factors `> 1`, where order does not matter.
- **S(N)**: `sum_{k=2..N} Fsf(k)`, specifically `S(10^10)`.

## 1) Rewriting the counting problem (Fsf)

Let

```
n = p1^e1 * p2^e2 * ... * pk^ek
```

A squarefree factor can contain each prime **at most once**. So each factor corresponds to a **nonempty subset** of `{p1, …, pk}`.

If we let `m_A` be the multiplicity of subset `A` in the factor multiset, then:

- For each prime `pi`, its exponent must be matched exactly:

```
sum_{A contains i} m_A = ei
```

So **Fsf(n)** becomes:

> The number of nonnegative integer solutions `{m_A}` to the linear system above  
> (one variable for each nonempty subset).

This depends only on the **exponent multiset** `(e1,…,ek)`, not on the prime values.

### Computing Fsf from exponents

That solution count is exactly a multivariate generating-function coefficient:

```
Fsf = [x1^e1 ... xk^ek]  ∏_{A≠∅} 1 / (1 - ∏_{i∈A} xi)
```

Because `k ≤ 10` for `n ≤ 10^10`, the state space is small. The implementation performs a compact multi-dimensional “unbounded knapsack” DP in mixed radix to extract the needed coefficient efficiently, with memoization on the exponent tuple.

Special case:
- If all exponents are `1` (squarefree `n`), then `Fsf(n)` is the **Bell number** `B_k` (set partitions of the `k` primes).

## 2) Summing up to 10^10 without iterating all n

Every `n > 1` has a unique factorization with **increasing primes**:

```
n = p1^a1 * p2^a2 * ... * pk^ak,   with p1 < p2 < ... < pk
```

So we can sum over all possible **ordered exponent sequences** `(a1,...,ak)` and count how many prime tuples realize them:

```
S(N) = Σ_{exponent sequences a}  Fsf(sorted(a)) * count_primes(a, N)
```

### Counting prime tuples for a fixed exponent sequence

For a sequence `(a1,...,ak)`, we count tuples `p1 < ... < pk` such that

```
p1^a1 * ... * pk^ak ≤ N
```

This is done by recursion over the prime choices, with an important pruning step:

- For each recursion level, we compute the **minimal possible product** for the remaining suffix using the *next* consecutive primes.
- Once the minimal suffix can’t fit, we **break** (monotonicity guarantees no later primes can work).

The last prime choice uses `π(x)` (prime counting) instead of iterating primes.

## 3) Fast π(x) via Lehmer prime counting

Counting primes up to `10^10` requires something faster than sieving to `10^10`.

This solution uses **Lehmer’s prime counting algorithm**:

- A sieve up to about `N^(2/3)` (≈ 5 million) provides small primes and a lookup table `π(x)` for `x ≤ sieve_limit`.
- Lehmer’s formula reduces `π(x)` to a few recursive `π()` calls and `φ(x, s)` computations.

A small cache for `φ(x, s)` (only for small `x`) keeps memory reasonable while still accelerating `π(x)`.

## Included checks

The code asserts the statement’s examples:

- `Fsf(54) = 2`
- `S(100) = 193`

Running `main.py` prints `S(10^10)`.
