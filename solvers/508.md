# Project Euler 508 Solution - Integers in Base $i-1$

<https://projecteuler.net/problem=508>:

* [508.py](508.py)

This repository contains a standalone Python solution (no external libraries) for **Project Euler 508**.

## Key ideas

### 1) Division algorithm in \(\mathbb{Z}[i]\) with base \(\beta=i-1\)
Every Gaussian integer \(z=a+bi\) has a unique base-\(\beta\) expansion with digits \(0/1\).
The least significant digit \(r\in\{0,1\}\) is determined by parity:

- \(r=1\) iff \(a\) and \(b\) have different parity (equivalently \((a\oplus b)\&1=1\)).
- Then \(z-r\) is divisible by \(i-1\) and we continue with the quotient.

This gives an efficient `f_gauss(a,b)` that repeatedly:

1. picks \(r\)
2. subtracts \(r\) from the real part
3. divides by \(i-1\)

Counting how many times \(r=1\) occurs is exactly \(f(z)\).

### 2) Turn the big sum into a recursive region sum
We need
\[
B(L)=\sum_{|a|\le L,\ |b|\le L} f(a+bi).
\]
Using the identity \(z=\beta q + r\), summing over a region \(R\) becomes:

\[
\sum_{z\in R} f(z)
= \sum_{r\in\{0,1\}}\ \sum_{q\in Q_r} \bigl(f(q)+r\bigr)
= \sum_{r} \sum_{q\in Q_r} f(q)\ +\ |Q_1|.
\]

So each step reduces the problem to *two* smaller regions \(Q_0\) and \(Q_1\), plus a simple count term.

### 3) Two coordinate systems that make preimages simple
The affine map \(z=(i-1)q+r\) is linear up to the digit \(r\). The trick is to represent regions in the coordinate system where the preimage is easy:

- **Rectangles** in \((a,b)\): axis-aligned \([x_0..x_1]\times[y_0..y_1]\).
- **Diamonds** via \(u=a+b\), \(v=a-b\): a box \([u_0..u_1]\times[v_0..v_1]\) with the constraint that \(u\equiv v\pmod 2\).

Under the map \(z=(i-1)q+r\):

- The preimage of a **rectangle** becomes a **diamond** (simple bounds on \(u=A+B\) and \(v=A-B\)).
- The preimage of a **diamond** becomes a **rectangle** (independent bounds on \(A\) and \(B\), each halved).

This alternation is what keeps the recursion efficient.

### 4) Digit-DP style memoization
Many subregions repeat. The solution memoizes:

- `sum_rect(x0,x1,y0,y1)`
- `sum_diamond(u0,u1,v0,v1)`

Each call splits into two children (for \(r=0\) and \(r=1\)), and the sizes shrink quickly (about one bit of information per step). The number of distinct states stays small (on the order of a few thousand even for \(L=10^{15}\)).

### 5) Small-region brute force as a base case
When a region contains at most a few thousand lattice points, the code switches to direct enumeration using `f_gauss()`. This keeps the implementation simple and fast.

## What the program does

- Verifies all example representations and values from the problem statement with `assert`.
- Verifies \(B(500)=10795060\).
- Prints \(B(10^{15})\bmod 1\,000\,000\,007\).
