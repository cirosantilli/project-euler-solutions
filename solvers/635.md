# Project Euler 635 Solution - Subset Sums

<https://projecteuler.net/problem=635>:

* [635.py](635.py)

This repo contains a pure-Python solution (no external libraries) for Project Euler **635**.

## Key ideas

### 1) Reduce the subset condition to residues mod `p`
For `n = p` prime, the set `{1,2,…,q p}` contains each residue `1..p` **exactly `q` times**.

Because we only care about the subset sum **mod `p`**, each chosen number contributes just its residue (multiples of `p` vanish mod `p`). So the problem becomes:

> Choose `p` elements from a multiset that has `q` copies of each residue `1..p`, and count those whose residue-sum is `0 (mod p)`.

### 2) Roots-of-unity filter (character sum)
Use a generating function for choosing items, tracking:
- subset size by `x`
- residue-sum by `y`

For a fixed residue `r`, selecting `j` of its `q` copies contributes `C(q,j) x^j y^{jr}`, so the per-residue factor is `(1 + x y^r)^q`.

Then
\[
A_q(p)= [x^p]\frac{1}{p}\sum_{t=0}^{p-1}\prod_{r=1}^p(1+x\omega^{tr})^q,
\]
where \(\omega\) is a primitive `p`-th root of unity.

For **odd** prime `p`:
- `t = 0` gives \(\prod_{r=1}^p(1+x)^q=(1+x)^{qp}\), so the coefficient is `C(qp,p)`.
- `t ≠ 0` permutes all `p`-th roots of unity, and
  \(\prod_{r=1}^p(1+x\omega^{tr}) = 1 + x^p\),
  so the `x^p` coefficient of `(1+x^p)^q` is just `q`.

Therefore, for odd primes:
\[
A_q(p)=\frac{1}{p}\left(\binom{qp}{p} + q(p-1)\right).
\]

The prime `p=2` is a small exception handled directly.

### 3) Fast computation of \(\binom{2p}{p}\) and \(\binom{3p}{p}\) for all odd `p ≤ L`
Let
- `C(n) = C(2n, n)`,
- `D(n) = C(3n, n)`.

These are **hypergeometric sequences**, so they satisfy simple multiplicative recurrences. We only need values at odd `n` (since primes > 2 are odd), and we advance by `2` each step.

After algebraic simplification (and cancelling factors of `2`), the update for odd `n` can be done using a small fixed number of modular multiplications and modular inverses.

### 4) Batch modular inverses (no per-step `pow`)
We need many inverses modulo `MOD = 1_000_000_009` (prime). Computing `pow(x, MOD-2, MOD)` for each `x` would be far too slow.

Instead we use **batch inversion** on blocks:
- Compute prefix products in a block,
- invert the total once with `pow(...)`,
- sweep backwards to recover each individual inverse.

We precompute:
- inverses of all integers `1..(L+1)/2` (used for `((n+1)/2)^{-1}`), and
- inverses of all odd numbers up to `2L+3` (used for `n^{-1}`, `(n+2)^{-1}`, `(2n+1)^{-1}`, `(2n+3)^{-1}`).

### 5) Prime sieve (odd-only)
A memory-efficient sieve stores only odd numbers:
- index `i` corresponds to number `2*i+1`.

This allows fast prime checks while iterating odd `n`.

## What the program outputs
Running `main.py` prints:
\[
(S_2(10^8) + S_3(10^8)) \bmod 1{,}000{,}000{,}009.
\]

The script also includes `assert`s for all test values stated in the problem statement.

## Files
- `main.py`: solution code
- `README.md`: this summary
