# Project Euler 217 Solution - Balanced Numbers

<https://projecteuler.net/problem=217>:

* [217.py](217.py)

A positive integer with `k` decimal digits is **balanced** if the sum of its first `ceil(k/2)` digits equals the sum of its last `ceil(k/2)` digits. Let `T(n)` be the **sum of all balanced numbers** less than `10^n`. The task is to compute:

- `T(47) mod 3^15`

The problem statement provides:
- `T(1) = 45`
- `T(2) = 540`
- `T(5) = 334795890`

These are used as asserts in the solution.

## Key observations

### 1) Odd-length simplification
For odd `k = 2L + 1`, the first `ceil(k/2)` digits and last `ceil(k/2)` digits both include the middle digit, so it cancels out.  
Thus, for both even and odd lengths, the balance condition becomes:

- **sum(left half of length L) == sum(right half of length L)**

The middle digit (when `k` is odd) is unconstrained.

### 2) Digit DP by (length, digit-sum)
For digit strings of fixed length `L` (allowing leading zeros), we build DP tables:

- `count[L][s]`: number of length-`L` digit strings with digit sum `s`
- `sum[L][s]`: sum of the **numeric values** of those strings (as `L` digits, leading zeros allowed)

Transition when appending a digit `d`:
- new_count[s+d] += old_count[s]
- new_sum[s+d]   += old_sum[s]*10 + old_count[s]*d

This is only needed up to `L = floor(47/2) = 23`, so sums go up to `9*23 = 207`.

### 3) Handling the non-zero leading digit
For the **left half**, the first digit of the whole number must be non-zero.

We build left-half tables from the unrestricted DP by fixing the first digit `1..9` and attaching an unrestricted tail of length `L-1`:
- `value = first_digit * 10^(L-1) + tail_value`

### 4) Combining halves (and middle digit)
For a fixed length:

- **Even** (`k = 2L`): `number = X * 10^L + Y`
- **Odd** (`k = 2L + 1`): `number = X * 10^(L+1) + d * 10^L + Y`, with `d in 0..9`

For each digit-sum `s`, we combine all left halves with sum `s` and all right halves with sum `s`, using:
- counts and sums for `X` and `Y`
- precomputed `10^p` mod `3^15`
- `sum(d)` for middle digit = `0+1+...+9 = 45`

### 5) Modular arithmetic throughout
We only need `T(47) mod 3^15`, so all DP counts/sums and all combinations are computed modulo `3^15` (except for the small exact asserts).

## Complexity
- DP size: `L ≤ 23`, digit sums `≤ 207`
- Time: `O(L * sum * 10)` for the DP, plus `O(n * sum)` for combining lengths
- Easily runs in under a second in Python.

## Output
Running the script prints the required value:
- `6273134`
