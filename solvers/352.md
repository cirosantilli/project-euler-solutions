# Project Euler 352 Solution - Blood Tests

<https://projecteuler.net/problem=352>:

* [352.py](352.py)

This repository contains a standalone Python solution (no third‑party libraries) for **Project Euler 352**.

## Core modeling trick: two DP states

A pooled PCR test on a set of animals answers only one question:

- **Negative**: every animal in the pool is virus‑free.
- **Positive**: at least one animal in the pool is infected.

The problem’s restriction (“finish screening everyone who contributed to a mixed sample before touching others”) means we can treat the process as **resolving one pool completely, then moving on**.

That leads to an efficient state reduction:

- `U[n]`: expected tests to fully classify `n` animals where each is infected independently with probability `p` (unconditional).
- `P[n]`: expected *additional* tests to fully classify `n` animals given that **at least one** of them is infected (i.e., the pool is known positive).

Base cases:

- `U[0] = 0`, `U[1] = 1` (one test is needed to classify a single animal).
- `P[1] = 0` (if a single animal is known to be in a positive pool, it must be infected, so no test is needed).

## Key probability identities

Let `a = 1 - p` (probability an animal is *not* infected).

For a pool of size `k`:

- `Pr(pool negative) = a^k`
- `Pr(pool positive) = 1 - a^k`

Inside a **known positive** group of size `n`, if we test a subset of size `k`:

- `Pr(subset positive | group positive) = (1 - a^k) / (1 - a^n)`

This works because “subset positive” implies “group positive”.

## Recurrences

### Unconditional group `U[n]`

Choose a pool size `k` (test those `k` animals next):

- Always spend 1 test for the pooled sample.
- If the pooled test is **negative**, those `k` animals are done; we still need `U[n-k]`.
- If it’s **positive**, we must resolve that pool: expected cost `P[k]`, then still do `U[n-k]`.

So:

```
U[n] = min_k  { 1 + U[n-k] + (1 - a^k) * P[k] }
```

### Known‑positive group `P[n]`

Choose a subset size `k` (`1 ≤ k < n`) to test next:

- Spend 1 pooled test.
- If subset is **negative**, the remaining `n-k` animals are still a known‑positive group → `P[n-k]`.
- If subset is **positive**, we resolve the subset as `P[k]`, and the remaining `n-k` animals are *unconditional* again → `U[n-k]`  
  (infections are independent and the “at least one infected” condition is already satisfied by the positive subset).

So:

```
P[n] = min_k { 1
              + q * (P[k] + U[n-k])
              + (1-q) * P[n-k] }
where q = (1 - a^k) / (1 - a^n)
```

## Performance

For each `p`, we precompute `a^k` and fill `P[1..K]`, `U[0..10000]` with dynamic programming.

A pool size cap `K=100` is enough for the entire range `p = 0.01..0.50`; increasing the cap does not change the optimal results for this problem (and it matches the official example values).

Time per `p` is `O(10000*K)` with small constants; total runtime across 50 values of `p` is comfortably fast in Python.

## Output

`main.py` prints:

- `sum_{p=0.01..0.50} T(10000, p)` rounded to 6 decimals

and includes asserts for the statement’s example values:

- `T(25, 0.02) = 4.155452`
- `T(25, 0.10) = 12.702124`
