# Project Euler 342 Solution - The Totient of a Square Is a Cube

<https://projecteuler.net/problem=342>:

* [342.py](342.py)

We want the sum of all integers `n`, `1 < n < 10^10`, such that `φ(n²)` is a perfect cube.

## Key ideas used

### 1) Bounding the relevant primes
If `φ(n²)` is a cube, write `φ(n²) = i³`.  
Every prime divisor of `φ(n²)` must divide `i`, so it is `≤ i`.

Also, every prime divisor of `n` divides `φ(n²)` (because `φ(p^{2a})` contains `p^{2a-1}`), so every prime divisor of `n` is `≤ i`.

Since `n² < 10²⁰`, we have `i³ = φ(n²) < 10²⁰`, hence:

- `i ≤ ⌊(10²⁰-1)^{1/3}⌋ = 4,641,588`

So all primes involved are `≤ 4,641,588`, which makes sieving feasible.

### 2) Reversing the totient formula on a square
For `n = ∏ p^{a_p}`:

- `φ(n²) = n² ∏_{p|n} (1 - 1/p) = n² ∏_{p|n} (p-1)/p`

If `φ(n²) = i³` and `P` is the set of distinct primes dividing `n`, then:

- `n² = i³ · ∏_{p∈P} p/(p-1)`

For a fixed `i`, the possible prime set `P` must be a subset of the distinct prime factors of `i` (because `p | n ⇒ p | φ(n²) ⇒ p | i`).

So for each `i` we:
1. factor `i` to get its distinct primes,
2. enumerate all non-empty subsets `P`,
3. compute the candidate `n²` via the fraction above,
4. check if `n²` is a perfect square and that the primes dividing `n` are *exactly* `P`.

### 3) Fast factorization with an SPF table
We build an SPF (smallest prime factor) table up to `4,641,588` using a **linear sieve**.  
That gives `O(log n)` factorizations for each `i`, which is fast enough for ~4.6 million values.

### 4) Exact division using GCD reductions
To test whether

`n² = i³ · Π p / Π(p-1)`

is an integer, we reduce the denominator using `gcd` against the numerator factors.  
If anything remains in the denominator, the subset cannot work.

### 5) Integer square test
We use `math.isqrt` to check perfect squares exactly:
- `n = isqrt(n²)` and verify `n*n == n²`.

## Complexity (informal)
- SPF sieve: `O(M)` where `M ≈ 4.64×10⁶`
- Main loop: for each `i`, subsets are at most `2^k - 1` with `k ≤ 7` (distinct prime factors of `i`), so the subset enumeration is small.

This runs comfortably in pure Python.
