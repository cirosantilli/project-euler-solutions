# Project Euler 958 Solution - Euclid's Labour

<https://projecteuler.net/problem=958>:

* [958.py](958.py)

This repository contains a single-file Python solution (`main.py`) with no external dependencies.

## Core ideas

### 1) Turn subtraction steps into a tree distance
The subtraction-only Euclidean algorithm repeatedly replaces the larger number by the difference of the two numbers.  
For coprime inputs, it ends at `(1, 1)`.

If you reverse one subtraction step, you replace a pair `(x, y)` by one of:

- `(x + y, x)`
- `(x + y, y)`

(keeping the larger component first). Starting from `(1, 1)` and repeatedly applying these “reverse” moves generates all coprime pairs exactly once. Therefore, the number of subtraction steps `d(n, m)` is the length of the unique path from `(n, m)` down to `(1, 1)`.

So to minimize `d(n, m)` for a fixed `n`, we search *backwards* from the penultimate state `(2, 1)` and find the first depth where some state `(n, m)` appears. If multiple `m` occur at that minimal depth, we choose the smallest `m`.

### 2) Iterative deepening with strong pruning
We do a depth-limited search from `(2, 1)`, increasing the limit until a solution appears. Several pruning rules keep the search small:

- **Monotone growth:** the first component strictly increases each move, so any state with `x > n` cannot lead to `x = n`.
- **Slow-growth lower bound:** even if we always keep the smaller second component, `x` grows by at least `y` per remaining step, so if `x + s·y > n` (with `s` steps left), we can prune.
- **Fast-growth upper bound via Fibonacci:** with `s` steps left, the maximum achievable first component is  
  `F_{s+1}·x + F_s·y`, where `F` are Fibonacci numbers. If this maximum is still `< n`, we can prune.

### 3) Cheap feasibility test using Bézout coefficients
A necessary condition to ever reach first component `n` from `(x, y)` is that `n` lies in the nonnegative cone generated by `x` and `y`:

`n = a·x + b·y` with `a, b ≥ 0`.

A standard check uses the modular inverse of `x (mod y)`. Recomputing an inverse from scratch everywhere is expensive, so the code carries Bézout coefficients `(p, q)` satisfying:

`p·x + q·y = 1`.

Then `p ≡ x⁻¹ (mod y)` immediately, and the minimal `a ≥ 0` solving `a·x ≡ n (mod y)` is:

`a = (n·p) mod y`.

We only need to test `a·x ≤ n` to confirm `b ≥ 0`. The Bézout pair updates in **O(1)** alongside each tree step, so the feasibility check stays cheap.

## Files

- `main.py` — computes `f(10^12 + 39)` and prints it; includes asserts for the sample values.
