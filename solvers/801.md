# Project Euler 801 Solution - $x^y \equiv y^x$

<https://projecteuler.net/problem=801>:

* [801.py](801.py)

This repository contains a pure-Python solution for Project Euler problem 801.

## Key ideas

### 1) Reduce to the prime case
The target sum is over primes `p`, so we only need to compute `f(p)` for prime moduli.

### 2) Split by whether numbers are multiples of `p`
The range is `1 ≤ x,y ≤ p^2 - p = p(p-1)`.

- If `p | x` and `p | y`, then `x^y ≡ 0 ≡ y^x (mod p)` and every such pair works.
- If exactly one of `x,y` is divisible by `p`, the congruence cannot hold because one side is `0` and the other is nonzero.

So the “multiple of `p`” contribution is simply `(p-1)^2`.

### 3) A bijection that turns the big range into a small product space
Write any `x` not divisible by `p` as

`x = r + p·a` with `1 ≤ r ≤ p-1` and `0 ≤ a ≤ p-2`.

Then:
- `x mod p = r`
- `x mod (p-1) ≡ r + a (mod p-1)` because `p ≡ 1 (mod p-1)`

As `a` runs over `0..p-2`, the value `(r+a) mod (p-1)` hits every residue exactly once.
So the set `{ x : 1 ≤ x ≤ p(p-1), p ∤ x }` is in bijection with

`(F_p^*) × (Z_(p-1))`.

The same holds for `y`.

### 4) Convert to a purely modular counting problem
For nonzero residues, Fermat gives exponent reduction mod `p-1`, so the condition becomes:

`(x mod p)^(y mod (p-1)) ≡ (y mod p)^(x mod (p-1)) (mod p)`.

Because `F_p^*` is cyclic of order `m = p-1`, choose a generator `g` and write
`x mod p = g^u`, `y mod p = g^v`. The congruence becomes a linear relation:

`u·A ≡ v·B (mod m)`

where `A = y mod m` and `B = x mod m`.

So the hard part is counting the number of quadruples `(u,A,v,B) ∈ (Z_m)^4`
satisfying `uA ≡ vB (mod m)`. Call this count `g(m)`.

Finally:

`f(p) = (p-1)^2 + g(p-1)`.

### 5) Use multiplicativity (CRT)
The equation `uA ≡ vB (mod m)` splits independently over coprime factors of `m`
by the Chinese Remainder Theorem, so `g(m)` is **multiplicative** in `m`.

That means it is enough to compute `g(q^e)` for prime powers and multiply.

### 6) Closed form for prime powers
For `m = q^e`, the divisor structure becomes simple, yielding a short closed form:

`g(q^e) = (q-1)^3 * Σ_{t=1..e} t^2 * q^{3e-t-2} + q^{2e-2} * (e(q-1)+q)^2`.

The code evaluates this in `O(e)` time per prime power, and multiplies the results.

### 7) Practical number theory tooling
To handle primes around `10^16` efficiently:

- **Segmented marking by small primes** in the interval `[10^16, 10^16+10^6]`
  filters out most composites quickly.
- Remaining candidates are verified with **deterministic Miller–Rabin for 64-bit**.
- Each `(p-1)` is factorized using **Pollard–Rho** (with a small trial-division pre-pass),
  and `g(p-1)` is computed multiplicatively from its prime powers.

All computations are done modulo `993353399` for the final sum.
