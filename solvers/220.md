# Project Euler 220 Solution - Heighway Dragon

<https://projecteuler.net/problem=220>:

* [220.py](220.py)

This solution computes the turtle/cursor position after a huge number of steps in the
Heighway Dragon L-system **without** generating the exponentially large instruction string.

## Core ideas

### 1) Treat `a` and `b` as nonterminals (L-system)
The problem defines rewrite rules:

- `a → a R b F R`
- `b → L F a L b`

When drawing, only:

- `F` = move forward 1 unit
- `L` / `R` = turn 90°
- `a` / `b` = ignored (but they expand into future drawing commands)

So `a` and `b` act like **nonterminals** that represent large instruction blocks.

### 2) Precompute “block transforms” for each recursion depth
For each depth `n`, we precompute the effect of executing the **entire expansion** of:

- `A[n]` = expansion of `a` after `n` rewrites
- `B[n]` = expansion of `b` after `n` rewrites

Each block is summarized as:

- `steps`: how many `F` moves occur inside
- `(dx, dy)`: net displacement in a *local frame* (starting direction = up)
- `rot`: net rotation in quarter turns (mod 4)

Because turns are always multiples of 90°, rotation is tracked as an integer in `{0,1,2,3}`.

Blocks are composed like rigid transforms:
- total displacement of `block1` + (rotated displacement of `block2`)
- total rotation = sum (mod 4)
- total steps = sum

This makes full-block execution **O(1)**.

### 3) Execute only a prefix using step counts (divide-and-conquer skipping)
We need the position after `k` *forward moves* (`F`), not after executing the entire string.

The key routine executes a **prefix** of an expanded symbol:

- If `k` is at least the block’s `steps`, apply the precomputed block transform and subtract.
- Otherwise, recursively descend into the symbol’s production (at depth `n-1`) and keep consuming steps.

Commands `L` and `R` consume **0 steps**, but must still be applied while we’re still looking for remaining `F`s, because they change orientation for later moves.

This yields a runtime essentially proportional to the recursion depth (≤ 50), not to the number of steps.

## Complexity
- Precomputation: `O(n)` blocks with constant work per level (here `n=50`)
- Query (position after `k` steps): `O(n)` recursion with small constant branching (rules length 5)
- Memory: `O(n)` transforms

## Included check
The problem statement notes that in `D10` the cursor is at `(18,16)` after `500` steps.  
The script includes:

```python
assert position_after(10, 500) == (18, 16)
```
