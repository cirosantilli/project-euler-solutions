# Project Euler 511 Solution - Sequences with Nice Divisibility Properties

<https://projecteuler.net/problem=511>:

* [511.py](511.py)

We count “nice” sequences `(a1..an)` where:

1. `ai | n` for every `i` (so each `ai` is a **positive divisor** of `n`)
2. `n + a1 + … + an ≡ 0 (mod k)`

Let `Seq(n,k)` be the number of such sequences. The task asks for the **last 9 digits** of `Seq(1234567898765, 4321)`.

---

## Key ideas

### 1) Reduce the problem to a cyclic convolution power

Let `D` be the set of divisors of `n`. Only the residues `d mod k` matter.

Create a vector `v` of length `k`:

- `v[r] = #{ d ∈ D : d ≡ r (mod k) }`

Choosing each `ai` independently means the distribution of the sum of residues is the **n-fold cyclic convolution** of `v` with itself:

- `v^{*n}[s] = # of length-n picks whose residue-sum ≡ s (mod k)`

The constraint `n + sum(ai) ≡ 0 (mod k)` is equivalent to:

- `sum(ai) ≡ -n (mod k)`

So:

- `Seq(n,k) = v^{*n}[ (-n) mod k ]`

We only need it modulo `10^9` (last nine digits).

---

### 2) Exponentiation by squaring in the convolution algebra

We compute `v^{*n}` with binary exponentiation:

- Identity element is `[1,0,0,…]`
- Multiplication is cyclic convolution modulo `10^9`

This takes `O(log n)` multiplications.

---

### 3) Fast cyclic convolution for `k = 4321 = 29 × 149`

A naive convolution is `O(k^2)`, too slow for `k=4321` and ~60 multiplications.

We accelerate each cyclic convolution with a length-4321 DFT:

- Because `4321 = 29 × 149` and `gcd(29,149)=1`, we can use the
  **Good-Thomas / Prime Factor Algorithm** to compute the DFT via two small DFTs:
  - 29-point DFTs on columns
  - 149-point DFTs on rows
- This gives about `29^2·149 + 149^2·29` operations per transform (much less than `4321^2`).

---

### 4) Exact modular results with floating FFT via coefficient splitting

We must compute convolution **mod `10^9`**, but the FFT uses floating complex numbers.

To keep rounding reliable, each coefficient `x (mod 10^9)` is split into 15-bit chunks:

- `x = x0 + x1·B`, with `B = 2^15`
- `x0 < B`, `x1` is small

Then only **three** integer convolutions are needed:

- `c00 = conv(x0, y0)`
- `c11 = conv(x1, y1)`
- `cs  = conv(x0+x1, y0+y1)`
- `cross = cs - c00 - c11 = conv(x0,y1) + conv(x1,y0)`

Each intermediate integer convolution coefficient stays below `2^53`, so rounding back to integers is stable; then we recombine everything modulo `10^9`.

We also use a faster “square” path for `a*a`, saving FFTs during exponentiation.

---

## What the program outputs

Running `main.py` prints the last 9 digits of `Seq(1234567898765, 4321)`.

The script also includes the problem statement’s check values as `assert`s:

- `Seq(3,4) = 4`
- `Seq(4,11) = 8`
- last 9 digits of `Seq(1111,24)` is `840643584`
