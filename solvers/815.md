# Project Euler 815 Solution - Group by Value

<https://projecteuler.net/problem=815>:

* [815.py](815.py)

This solution computes the expected **maximum number of non-empty piles** when dealing a shuffled deck containing four copies of each value `1..n`, where piles are formed by value and removed once they reach four cards.

## Key techniques

### 1) Symmetry-based state compression
Instead of tracking each value separately, we track only how many values are in each “seen count” category:

- `x0`: values seen 0 times (4 cards still in the deck)
- `x1`: values seen 1 time (3 remaining) → pile size 1
- `x2`: values seen 2 times (2 remaining) → pile size 2
- `x3`: values seen 3 times (1 remaining) → pile size 3
- `x4`: values seen 4 times (0 remaining) → completed and removed (implicit)

The number of active piles at any time is `x1 + x2 + x3`.

### 2) Markov process with an acyclic graph
From any state `(x0,x1,x2,x3)` a single dealt card always reduces the total number of remaining cards by exactly 1:

`R = 4*x0 + 3*x1 + 2*x2 + x3`

Because `R` strictly decreases on every move, the state graph is **acyclic**, which enables straightforward dynamic programming in increasing `R` order (no linear-system solving needed).

### 3) Expected maximum via tail-sum (CDF) method
For an integer-valued random variable `M = max #active piles`, we use:

`E[M] = sum_{k>=1} P(M >= k) = sum_{k=1..n} (1 - P(M < k))`

For each threshold `k`, we compute `P(M < k)` by dynamic programming that treats any state with `x1+x2+x3 >= k` as “failed”.

### 4) Efficient enumeration and indexing
All feasible states `(x0,x1,x2,x3)` with `x0+x1+x2+x3 <= n` are enumerated once. A compact combinatorial indexing scheme maps each state to an integer index, so transitions can be stored in arrays and evaluated quickly.

## Output
Running `main.py` prints `E(60)` rounded to 8 digits after the decimal point, and includes an assert for the provided sample value `E(2)` (rounded to 8 decimal places).
