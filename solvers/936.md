# Project Euler 936 Solution - Peerless Trees

<https://projecteuler.net/problem=936>:

* [936.py](936.py)

## Core idea
A *peerless* tree forbids an edge whose two endpoints have the same **degree**.

To count **unlabelled** trees efficiently, the solution switches to rooted variants
and uses classic generating-function machinery for **unlabelled multisets**.

## 1) Planted trees turn the rule local
Cut an edge and look at one side. The endpoint on that side has one “parent” edge
(the cut) plus some number of children.

- Define the **outdegree** of a vertex as its number of children (excluding its parent).
- In a *planted* tree every vertex has a parent edge, so the usual degree is
  `outdegree + 1`.
- Therefore, the peerless condition along an internal edge becomes simply:
  **adjacent outdegrees must be different**.

This makes the restriction local and compatible with recursive counting.

## 2) Unlabelled multisets via Pólya / cycle index
Children of a rooted tree form an **unlabelled multiset** of subtrees.
For a class with ordinary generating function `A(x)`, the multiset construction gives

```
M(u, x) = exp( sum_{k>=1} u^k/k * A(x^k) )
```

`u` marks the number of children. The coefficient of `u^m` counts structures with
**exactly** `m` children.

Instead of expanding the exponential directly, the program extracts `u^m` using the
standard recurrence for the coefficients `E_m(x)`:

```
E_0(x) = 1
E_n(x) = (1/n) * sum_{k=1..n} A(x^k) * E_{n-k}(x)
```

The key implementation trick is to compute coefficients in `x` **degree-by-degree**.
Because `A(0)=0`, the coefficient `[x^d] E_n` depends only on smaller `x`-degrees,
so no fixed-point iteration is needed.

## 3) From planted to unrooted: dissymmetry theorem
Let
- `V(x)`: peerless trees rooted at a vertex
- `E(x)`: peerless trees rooted at an undirected edge
- `O(x)`: peerless trees rooted at a directed edge

The dissymmetry theorem for trees gives:

```
U(x) = V(x) - O(x) + E(x)
```

For peerless trees, the two endpoints of any edge have different degrees, so an
edge cannot be flipped by an automorphism. That implies `O(x) = 2E(x)` and thus:

```
U(x) = V(x) - E(x)
```

Finally, `S(50)` is computed from `P(n) = [x^n] U(x)`.

## Complexity
The implementation works with coefficient arrays up to `x^50` and performs only
integer arithmetic; it runs quickly in plain Python.
