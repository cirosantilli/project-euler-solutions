# Project Euler 366 Solution - Stone Game III

<https://projecteuler.net/problem=366>:

* [366.py](366.py)

This game is the classic **Fibonacci Nim**:

- First move: take `1..n-1`
- Later moves: take at most `2 * (opponent's previous take)`
- Taking the last stone wins

We define `M(n)` as the **maximum** winning first move from a winning start, otherwise `0`,
and we need:

- `Σ M(n)` for `n ≤ 10^18` (mod `10^8`)

## Main techniques used

### 1) Fibonacci Nim + Zeckendorf representation

A key theorem for Fibonacci Nim says:

- Write the current pile size `r` in **Zeckendorf form** (sum of non-consecutive Fibonacci numbers using `1,2,3,5,8,...`).
- Let `s(r)` be the **smallest Fibonacci number** in that representation.
- With current quota `q` (max removable stones), the position is **winning** iff `q ≥ s(r)`.

For the initial move the quota is `n-1`, so the start is losing exactly when `n` itself is a Fibonacci number.

### 2) Characterizing losing positions after the first move

If the first player removes `x`, then the opponent faces:

- remaining pile `r = n - x`
- quota `q = 2x`

To make the opponent lose we need:

`2x < s(r)`

So `M(n)` is the maximum `x` satisfying that inequality.

### 3) Greedy “same-parity Fibonacci subtraction” for `M(n)`

Let `F_i` be the largest Fibonacci number (with `F_1=1, F_2=2`) such that `F_i ≤ n`.

- If `n = F_i`, then `M(n) = 0` (losing).
- Otherwise start with `rem = n - F_i`.

If `2*rem ≥ F_i`, leaving `F_i` is **not** safe (the opponent’s quota becomes too large),
so we “shift” the remaining position by subtracting the next smaller Fibonacci of the **same parity**:

- `rem ← rem - F_{i-2}`, `i ← i-2`

Repeat until the strict inequality `2*rem < F_i` holds.
The final `rem` is exactly `M(n)`.

### 4) Summation up to `10^18` by counting ranges

We cannot iterate over all `n ≤ 10^18`.

Instead we work interval-by-interval between Fibonacci numbers:

- For `n` in `[F_i, F_{i+1})`, write `n = F_i + m0`.

The greedy process for `M(n)` subtracts `F_{i-2}, F_{i-4}, ...` until it stops.
Each possible stopping stage corresponds to a **contiguous integer range** of `m0`,
and within that range:

`M(n) = m0 - (constant)`

So each block contributes an **arithmetic series**, which we sum in O(1).
There are only ~88 Fibonacci numbers up to `10^18`, and each interval has ≤ ~44 stages,
so the full computation is essentially instant.

## Files

- `main.py` — computes the required value and prints it
  - Includes asserts for statement checks (`M(5)=0`, `M(17)=4`, and `Σ_{n≤100} M(n)=728`)
