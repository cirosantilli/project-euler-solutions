# Project Euler 630 Solution - Crossed Lines

<https://projecteuler.net/problem=630>:

* [630.py](630.py)

This solution computes **S(L₍₂₅₀₀₎)** for the set of *unique* infinite lines formed by all pairs of the first 2500 pseudo‑random points.

## Key idea: count intersections via parallel classes

For a set of unique lines `L`:

- Any **two distinct non-parallel lines** intersect exactly once.
- Any **parallel pair** never intersects.

Let:

- `M` = number of unique lines
- For each slope/parallel class `i`, `cᵢ` = number of lines with that slope

Number of intersecting unordered line pairs is:

`I = C(M,2) − Σ C(cᵢ,2)`

Each intersecting pair contributes **1 crossing to each line**, so:

`S(L) = 2I = M(M−1) − Σ cᵢ(cᵢ−1)`

So we only need:
1) `M` (unique line count)  
2) the sizes of each parallel class

## Canonical line representation with integer arithmetic

A line through two integer points can be represented without floating point:

1. Direction:  
   `dx = x₂ − x₁`, `dy = y₂ − y₁`, reduced by `g = gcd(|dx|,|dy|)` to make it **primitive**.

2. Primitive normal vector (perpendicular):  
   `(A,B) = (dy, −dx)`  
   with a fixed sign convention to make it canonical:
   - `A > 0`, or
   - `A == 0` and `B > 0`

3. Offset (constant on the line):  
   `D = A*x + B*y`

Then the unique line is identified by the integer triple `(A, B, D)`.
Parallel lines share `(A,B)` and differ by `D`.

## Deduplication and counting via sorting (memory-friendly)

There are `2500*2499/2 = 3,123,750` point pairs.  
Different pairs can generate the **same** line if ≥3 points are collinear, so we deduplicate:

- Pack `(A,B,D)` into a single integer (bit packing) to reduce overhead.
- Sort all packed codes.
- Scan once:
  - skip duplicates (`code == prev_code`)
  - count unique lines (`M`)
  - count how many unique lines share the same `(A,B)` (parallel class size `cᵢ`)

Finally compute:

`S = M(M−1) − Σ cᵢ(cᵢ−1)`

## Complexity

- Generating all pair lines: **O(n²)**  
- Sorting: **O(n² log n²)**  
- Scan/grouping: **O(n²)**

With `n = 2500`, this runs fast in CPython thanks to:
- integer-only arithmetic
- `math.gcd` in C
- compact packed representation
