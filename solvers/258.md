# Project Euler 258 Solution - A Lagged Fibonacci Sequence

<https://projecteuler.net/problem=258>:

* [258.py](258.py)

We are given a linear recurrence:

* \(g_k = 1\) for \(0 \le k \le 1999\)
* \(g_k = g_{k-2000} + g_{k-1999}\) for \(k \ge 2000\)

and we want \(g_{10^{18}} \bmod 20092010\).

## Main techniques used

### 1) Turn the recurrence into a polynomial identity

For a linear recurrence, the **characteristic polynomial** captures the update rule.
Plugging \(g_k = r^k\) into

\[g_k = g_{k-2000} + g_{k-1999}\]

gives

\[r^{2000} = r + 1\]

so the characteristic polynomial is:

\[P(x) = x^{2000} - x - 1\]

Working “modulo the recurrence” is the same as working in the quotient ring
\(\mathbb{Z}_{20092010}[x] / (P(x))\), where we can replace:

\[x^{2000} \equiv x + 1\]

### 2) Compute \(x^n \bmod P(x)\) via binary exponentiation

Any power \(x^n\) can be reduced to a polynomial of degree `< 2000`:

\[x^n \equiv \sum_{i=0}^{1999} c_i x^i \pmod{P(x)}\]

We compute this efficiently with **exponentiation by squaring**, exactly like fast modular
exponentiation for integers, but with polynomials.

### 3) Fast polynomial multiplication with a one-pass reduction

Multiplying two degree `< 2000` polynomials yields degrees up to `3998`.
Because the modulus is `x^2000 - x - 1`, every term `t * x^i` with `i >= 2000` folds down once:

\[t x^i = t x^{i-2000} x^{2000} \equiv t x^{i-2000}(x+1) = t x^{i-1999} + t x^{i-2000}\]

Since the maximum intermediate degree is only `3998`, **a single folding pass** is enough.

### 4) Use the special initial conditions

In general, the coefficients \(c_i\) tell you how to express \(g_n\) as a linear combination
of the initial values \(g_0..g_{1999}\).

Here all initial values are `1`, so:

\[g_n \equiv \sum_{i=0}^{1999} c_i \pmod{20092010}\]

That means once we have \(x^n \bmod P(x)\), the answer is just the **sum of coefficients**.

## Implementation notes

* The solution in `main.py` uses **NumPy's** `convolve` to perform the length-2000 convolutions
  in optimized C code.
* A pure-Python fallback multiplication exists for correctness in environments without NumPy,
  but it is typically too slow for the full \(10^{18}\) exponent.
