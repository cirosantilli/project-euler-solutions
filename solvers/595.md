# Project Euler 595 Solution - Incremental Random Sort

<https://projecteuler.net/problem=595>:

* [595.py](595.py)

## Key idea: the state is only the number of blocks

After each “check & attach” step, the deck becomes a sequence of **blocks**, where each block is a maximal run of
consecutive values in increasing order (… , `k, k+1, k+2`, …).

The shuffle step then **randomly permutes these blocks uniformly**, while preserving the internal order of each block.
Because the shuffle is assumed unbiased even when blocks have different sizes, **block sizes don’t matter** — only the
**number of blocks** matters.

So we can define:

- `T(m)`: expected remaining shuffles when we currently have `m` blocks (right after the attach step).

Then `T(1) = 0` and the process is a Markov chain on `m = 1..n`, where `m` never increases.

---

## Counting merges = counting “successions” in a random permutation

Label the current blocks `1..m` in increasing value order.

After shuffling, some adjacent block pairs may become consecutive in the correct order:

- a **succession** is an occurrence of `i` immediately followed by `i+1` in the block permutation.

Each such succession causes one merge at the next attach step.
If a shuffle creates `r` successions, then the number of blocks becomes `m - r`.

So we need the distribution:

- `a(m, r)`: number of permutations of `{1..m}` with exactly `r` successions.

---

## Inclusion–exclusion to compute `a(m, r)`

Let `E_i` be the event “`i` is immediately followed by `i+1`”.

If we require any specific set of `k` events, those constraints *glue* items together into `m-k` super-items, so the
number of permutations satisfying them is simply:

- `(m-k)!`

This depends only on `k`, not on which events were chosen, so inclusion–exclusion gives a compact integer formula:

\[
a(m,r)=\binom{m-1}{r}\sum_{j=0}^{m-1-r} (-1)^j \binom{m-1-r}{j} (m-r-j)!
\]

These counts give transition probabilities:

\[
P(m \to m-r)=\frac{a(m,r)}{m!}
\]

The **same distribution** also describes the initial “attach” step from a uniformly random permutation of `n` cards.

---

## Expected value recurrence

From `m > 1` blocks, we do one shuffle and then move to `m-r` blocks with the probabilities above. Accounting for the
self-loop when `r=0`:

\[
(m! - a(m,0))\,T(m)=m!+\sum_{r=1}^{m-1} a(m,r)\,T(m-r)
\]

This lets us compute `T(2), T(3), …, T(n)` in order.

Finally the requested expectation over a random starting permutation is:

\[
S(n)=\sum_{r=0}^{n-1}\frac{a(n,r)}{n!}\,T(n-r)
\]

All computations in `main.py` are done **exactly** with `fractions.Fraction`, and only the final output is rounded to
8 decimal places.
