# Project Euler 769 Solution - Binary Quadratic Form II

<https://projecteuler.net/problem=769>:

* [769.py](769.py)

This solution avoids iterating over `z ≤ N` directly by transforming the problem into **counting primitive lattice points** inside a quadratic region.

## 1) Algebraic / geometric re-parameterization

We need primitive integer pairs `(x, y)` with:

- `x > 0`, `y > 0`, `gcd(x, y) = 1`
- `x^2 + 5xy + 3y^2 = z^2`, with `z ≤ N`

The equation is a homogeneous quadratic (a conic in projective space) and has a rational point, e.g. `(x, y, z) = (1, 0, 1)`.  
Using the standard “line through a rational point” method, all integer solutions are parameterized by coprime integers `(p, q)` via:

- `x0 = 3p^2 - q^2`
- `y0 = -p(2q + 5p)`
- `z0 = q^2 + 5pq + 3p^2`

A valid representation with `x, y > 0` occurs exactly in specific sign-regions of `(p, q)`; with the convention `q > 0`, it reduces to `x0 < 0` and `y0 < 0`, then `(x, y, z) = (-x0, -y0, |z0|)`.

## 2) Turning it into a counting problem

For each integer `p` (positive and negative branches handled separately), the constraints:

- sign constraints (`q > √3|p|` and (for negative `p`) also `q < 2.5|p|`)
- the bound `|z0| ≤ N`

produce an **interval of admissible `q`**: `q ∈ [L(p), R(p)]`.

So `C(N)` becomes the sum over all relevant `p` of:

- the count of integers `q` in `[L(p), R(p)]` with `gcd(p, q) = 1`
- minus a small set of non-primitive cases.

## 3) Fast coprimality counting via inclusion–exclusion

For fixed `p`, the count of `q` in `[L, R]` with `gcd(p, q) = 1` is computed using inclusion–exclusion over the **distinct prime factors** of `p`:

\[
\#\{q \in [L,R] : \gcd(p,q)=1\}=\sum_{d\mid p} \mu(d)\Big(\lfloor R/d\rfloor-\lfloor (L-1)/d\rfloor\Big),
\]

where the sum is over squarefree divisors `d` and `μ(d) ∈ {±1}`.

To factor every `p` quickly, the program builds a **smallest prime factor (SPF)** table using a linear sieve.

## 4) Primitive filter: only a single extra congruence

Empirically and algebraically here, the only possible nontrivial gcd for `(x, y)` is `13`.  
In the `(p, q)` parameterization, `13 | x` and `13 | y` happens exactly when:

- `p ≠ 0 (mod 13)` and
- `q ≡ 4p (mod 13)`.

So we subtract counts in `[L, R]` that satisfy this single congruence **and** `gcd(p, q) = 1`.  
That is the same inclusion–exclusion sum as above, but with counting in an arithmetic progression modulo `13d`.

## 5) Integer root bounds (no floating-point reliance)

Bounds for `q` come from solving quadratic inequalities and use `math.isqrt` for exact integer square roots.  
A small “safety decrement” step ensures the computed right-endpoint never exceeds the true `z ≤ N` boundary.

---

**Files:**

- `main.py` implements the sieve, counting routines, statement-test asserts, and prints `C(10^14)`.
