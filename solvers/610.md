# Project Euler 610 Solution - Roman Numerals II

<https://projecteuler.net/problem=610>:

* [610.py](610.py)

## Core idea
The process is memoryless except for the Roman numeral we have written so far:

- At each draw we stop with probability **0.02** (the `#`).
- Otherwise we draw one of `I,V,X,L,C,D,M` with probability **0.14** each.
- A drawn letter is **accepted** only if appending it keeps the current string a **valid Roman numeral in minimal form**; otherwise it is **skipped** (state unchanged).

We need the expected value of the numeral when we stop.

## 1) Turn the process into a Markov chain
Let a **state** be “the current minimal Roman numeral we have written so far”.
If we are in state `s` with value `v(s)`, then

- with probability `q=0.02` we stop and receive payoff `v(s)`
- with probability `p=0.14` for each letter we either move to a new state (if the append is valid) or stay in `s` (if invalid)

So each state satisfies a linear expectation equation.

## 2) Finite-state reduction for the non-thousands part
Minimal Roman numerals have a unique representation for every value.
For the part **below 1000** there are only **999** minimal numerals (for `1..999`).

The code generates these via the standard greedy table:

`M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I`

and stores a map `roman -> value` for all `1..999`.

A transition “append one letter” is valid exactly when the resulting string is also one of these minimal numerals.

## 3) Exploit acyclicity: dynamic programming instead of Gaussian elimination
If `r` is a minimal numeral, then any accepted append produces `r + ch`, which is **one character longer**.
So dependencies only go from shorter strings to longer ones.

That makes the expectation equations **triangular by length**:

\[
E(r) = \frac{q\,v(r) + p\sum_{r\to r'} E(r')}{q + p\cdot(\#\text{valid appends from }r)}
\]

We can compute `E(r)` by processing numerals in **descending length** order.

## 4) Handle infinitely many leading `M`’s with linearity
The only infinite part is the initial “thousands” run `M^k`.
While we only have `M`’s, drawing another `M` increases the value by **1000** and keeps us in the same “thousands” mode.

Because this is a simple self-loop, the expected value in that mode is **affine in `k`**.
Solving the resulting one-line equation gives the start-state expectation in terms of the already-computed values for the six possible first non-`M` letters.

## 5) Exact arithmetic
All probabilities are rational:

- `q = 2% = 1/50`
- `p = 14% = 7/50`

The implementation uses `fractions.Fraction` to keep the entire computation exact, and rounds the final fraction to 8 decimals with integer arithmetic.

---

Run:

```bash
python3 main.py
```

It prints the expected value rounded to 8 decimal places.
