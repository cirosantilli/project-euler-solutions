# Project Euler 834 Solution - Add and Divide

<https://projecteuler.net/problem=834>:

* [834.py](834.py)

This repository contains a standalone solution (`main.py`) for Project Euler problem 834.

## Key ideas

### 1) Turn the recurrence into a closed-form divisibility condition
Let the sequence start at `n` and at step `m` add `(n+m)`. The `m`-th term is

- `a_m = n + Σ_{k=1..m} (n+k) = n(m+1) + m(m+1)/2`.

We want indices `m` such that `a_m` is divisible by `d = n+m`.
Multiplying by 2 to avoid fractions:

- `2 a_m = (m+1)(2n+m)`
- divisibility is equivalent to `2d | (m+1)(2n+m)`.

Substituting `d = n+m` and simplifying yields the crucial factorization:

- `(d-n+1)(d+n) = d^2 + d + n - n^2 = d(d+1 - n(n-1)/d)`.

So `d | n(n-1)` must hold, and the remaining requirement is a parity constraint on
`d+1 - n(n-1)/d`.

### 2) Only certain divisors matter (2-adic split)
Write `n(n-1) = 2^a * q` with `q` odd. The parity constraint turns into:

- the factor pair `(d, n(n-1)/d)` must have opposite parity,
- equivalently `v2(d)` is either `0` (odd divisor) or `a` (contains *all* factors of 2).

That means every valid `d` is either:

- `d = p` where `p` is an odd divisor of `q`, or
- `d = 2^a * p` where `p` is an odd divisor of `q`.

We also require `d > n` because `m = d-n` must be positive.

### 3) Reduce odd divisors of `q` to products of divisors of two coprime numbers
Exactly one of `n` and `n-1` is even.
Let the even one be `even = 2^a * A` with `A` odd, and let `B` be the odd neighbor.
Then

- `q = A * B`, and `gcd(A, B) = 1`.

Every odd divisor of `q` is a product `p = a*b` with `a | A` and `b | B`.
So valid divisors `d` correspond to products `p` satisfying thresholds:

- odd `d = p` requires `p > n`
- even `d = 2^a p` requires `p > floor(n / 2^a)`.

### 4) Count and sum qualifying products efficiently
For each `n` we need:

- `count(p > L)` and `sum(p over p > L)` over all `p = a*b`.

Instead of enumerating all `a*b` pairs, we:

1. generate the divisor lists of `A` and `B`,
2. sort one list and build its prefix sums,
3. iterate over the smaller divisor list and use binary search on the larger list:

For a fixed `a`, the qualifying `b` satisfy `b > L//a`.
With prefix sums, the contribution to the product-sum is

- `a * Σ b` over that suffix.

This makes each `T(n)` computation roughly `O(τ(min(A,B)) log τ(max(A,B)))`.

### 5) Fast factorization via SPF sieve + rolling reuse
- A smallest-prime-factor (SPF) sieve up to `N` makes factorization of numbers `≤ N` fast.
- Across consecutive `n`, exactly one of the two odd factors (`A` or `B`) repeats, so the
  solution keeps *rolling* divisor data for the last `A` and last `B` instead of storing a
  huge cache.

## Correctness checks
The script includes `assert` statements for all example values given in the problem:

- `S(10) = {5, 8, 20, 35, 80}`
- `T(10) = 148`
- `T(100) = 21828`
- `U(100) = 612572`

Run `python3 main.py` to execute the self-tests and print the required value.
