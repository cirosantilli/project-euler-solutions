# Project Euler 495 Solution - Writing $n$ as the Product of $k$ Distinct Positive Integers

<https://projecteuler.net/problem=495>:

* [495.py](495.py)

This repository solves **Project Euler 495**:

- **W(n, k)** = number of ways to write `n` as the product of `k` **distinct** positive integers.
- Compute **W(10000!, 30) mod 1,000,000,007**.
- Also validate the statement’s examples with asserts.

## Key ideas

### 1) “Distinct factors” via signed inclusion–exclusion over permutations

Count *ordered* `k`-tuples `(x1, …, xk)` with product `n` and then enforce `xi` all distinct.

A standard trick is to use inclusion–exclusion over permutations of positions:

- For a permutation, all positions in the same cycle must be equal in a fixed tuple.
- The only thing that matters is the **cycle type** (an integer partition of `k`).

This converts the distinctness constraint into a signed sum over cycle types (partitions of `k`),
with a weight:

\[
\text{weight}(\lambda) \;=\; \frac{(-1)^{k-\#\text{cycles}}}{\prod_s \left(s^{b_s} \cdot b_s!\right)}
\]

where `b_s` is how many cycles of length `s` appear in the cycle type.

### 2) Prime-exponent factorization of the “fixed” counts

Let `n = ∏ p^{a_p}`.

For a cycle type with cycle lengths `m1, m2, …, mb`, the product condition becomes:

\[
y_1^{m_1} y_2^{m_2} \cdots y_b^{m_b} = n
\]

This factors over primes, and for each prime exponent `a` we need the coefficient:

\[
[x^a]\prod_{i=1}^{b} \frac{1}{1-x^{m_i}}
\]

That coefficient counts nonnegative solutions to `m1*t1 + ... + mb*tb = a`.

For `10000!`, many primes share the same exponent value, so we compute frequencies:

- `freq[e]` = number of primes `p` with `v_p(10000!) = e`

and then for a cycle type:

\[
\prod_p \text{coeff}(a_p)
\;=\;
\prod_e \left(\text{coeff}(e)\right)^{freq[e]}
\]

### 3) Coefficients by unbounded-knapsack DP (power series multiplication)

To compute:

\[
P(x)=\prod_i \frac{1}{1-x^{m_i}}
\]

we keep a coefficient array `dp[t] = [x^t]P(x)` up to the maximum needed exponent (for `10000!` this is `9995`)
and apply the classic update for each factor:

```
dp[t] += dp[t - m]
```

(modulo `1,000,000,007`).

### 4) Practical speed optimization: precompute the common (1, 2) cycle factors

Cycle lengths `1` and `2` occur extremely often among partitions of `30`.

Instead of reprocessing `(1-x)^{-r1}` and `(1-x^2)^{-r2}` from scratch for every cycle type, we precompute:

\[
(1-x)^{-r_1}(1-x^2)^{-r_2}
\]

for all `0 ≤ r1 ≤ 30` and `0 ≤ r2 ≤ 15`, and start each DP from that base, only processing cycle lengths `≥ 3`.

This cuts a large fraction of the DP work while keeping memory modest (stored as `array('I')`).

## What the program prints

Running `main.py` prints the value of:

- `W(10000!, 30) mod 1,000,000,007`

and also runs asserts for:

- `W(144,4) = 7`
- `W(100!,10) = 287549200`
