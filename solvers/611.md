# Project Euler 611 Solution - Hallway of Square Steps

<https://projecteuler.net/problem=611>:

* [611.py](611.py)

Peter toggles door `n` once for every action `(a,b)` with:

- `a^2` is a positive square step,
- `b^2` is a larger square step (`a<b`),
- `a^2 + b^2 = n` and `n ≤ N`.

So the final state of door `n` depends only on the **parity** of the number of representations:

\[
n = a^2 + b^2,\quad 0<a<b.
\]

A door is open iff that count is odd.

## 1) Sum-of-two-squares factorization and parity

Let

\[
n = 2^c \prod p_i^{a_i} \prod q_j^{b_j},
\]

where `p_i ≡ 1 (mod 4)` and `q_j ≡ 3 (mod 4)` are odd primes.

- `n` is representable as a sum of two squares **iff** every `b_j` is even.
- The number of integer solutions of `x^2+y^2=n` satisfies

\[
r_2(n)=
\begin{cases}
0 & \text{if some } q_j \text{ has odd exponent},\\
4\prod (a_i+1) & \text{otherwise.}
\end{cases}
\]

For **distinct positive** squares `0<a<b`, the count becomes

\[
s(n)=\left\lfloor \frac{1}{2}\prod(a_i+1) \right\rfloor
\]

(handling square / twice-square edge cases is exactly what the floor does).

So `s(n)` is odd precisely when the product

\[
B=\prod(a_i+1)
\]

has a very specific 2-adic behavior:

- **Case A:** `B` is odd and `B ≡ 3 (mod 4)` (equivalently, all `a_i` even, and an odd number of them are `2 mod 4`).
- **Case B:** `v2(B)=1` (exactly one prime `p≡1 (mod4)` has exponent `a_p≡1 (mod4)`, all others even).

These are the two families that are counted.

## 2) Reparameterization into squares

Both cases can be counted by enumerating a square root parameter `u ≤ √N`:

- **Case A:** `n = 2^k * u^2`, with `u` odd and an odd number of `p≡1 (mod4)` appearing to **odd** exponent in `u`.

  Each valid `u` contributes `#k = ⌊log2(N/u^2)⌋+1`.

- **Case B:** `n = 2^k * p * u^2`, where `p≡1 (mod4)` is prime and the exponent of `p` inside `u` is **even**.

  For fixed `u` and `k`, the allowed `p` are counted by
  \[
  \pi_1\!\left(\left\lfloor \frac{N}{2^k u^2}\right\rfloor\right)
  \;-\; \#\{p\mid u,\;p\equiv1\!\!\!\pmod4,\;v_p(u)\ \text{odd}\}.
  \]

So the algorithm needs many queries of `π1(x)` = number of primes `≤x` with `p≡1 (mod 4)`.

## 3) Fast `π1(x)` via a table

To answer `π1(x)` quickly for many `x`, the solver builds tables for all distinct values

\[
v \in \left\{\left\lfloor \frac{N}{i}\right\rfloor : 1\le i\le N\right\}
\]

(about `2√N` values).

It computes simultaneously:

- `π(v)` = number of primes `≤v`
- `S(v) = Σ_{p≤v} χ(p)` where `χ` is the mod-4 character:

  - `χ(2)=0`
  - `χ(p)=+1` if `p≡1 (mod4)`
  - `χ(p)=-1` if `p≡3 (mod4)`

Then

\[
\pi_1(v)=\frac{(\pi(v)-1)+S(v)}{2}.
\]

The table is produced using the same inclusion–exclusion sieve recurrence as the classic fast prime-counting method, but with the multiplicativity of `χ` to update the character sum alongside the prime count.

## 4) Implementation notes

- A smallest-prime-factor sieve up to `√N = 10^6` lets us factor each odd `u` quickly.
- The brute-force routine is only used for the statement’s check values up to `10^6`, and those are asserted.
- The final answer for `N=10^12` is computed and printed (not embedded or asserted).
