# Project Euler 513 Solution - Integral Median

<https://projecteuler.net/problem=513>:

* [513.py](513.py)

This write-up explains the main ideas behind an efficient counting solution (single-threaded, no external libraries).

## 1) Turning the geometric condition into arithmetic

For a triangle with integer sides `a ≤ b ≤ c`, the median to side `c` has length:

\[
m^2=\frac{2a^2+2b^2-c^2}{4}
\]

We need `m` to be an integer. A quick modular check shows `c` must be even, so write `c = 2C`.

## 2) A helpful substitution

Let

- \(x=\frac{b-a}{2}\)
- \(y=\frac{a+b}{2}\)

Then `a = y − x` and `b = y + x`. Substituting into the median formula gives:

\[
C^2+m^2=x^2+y^2
\]

Rearranging:

\[
(C-x)(C+x)=(y-m)(y+m)
\]

So we match two products of “sum and difference” pairs.

## 3) Factor/gcd structure

Define:

- \(p=C-x\)
- \(q=y-m\)

Then:

\[
p(C+x)=q(y+m)
\]

Let \(d=\gcd(p,q)\), and set \(A=p/d,\; B=q/d\) so \(\gcd(A,B)=1\).

A standard gcd argument forces the other factors to be multiples:

- \(C+x = kB\)
- \(y+m = kA\)

for some positive integer `k`. From this, all triangle data can be reconstructed.

## 4) Inequalities become bounds

The ordering `a ≤ b` becomes `x ≥ 0`, which is:

\[
kB \ge dA
\quad\Rightarrow\quad
B \ge \left\lceil \frac{dA}{k} \right\rceil
\]

The triangle inequality and positivity of the median pick the meaningful branch, which ends up requiring:

- `k > d`
- `B < A`

The perimeter/limit condition `c ≤ n` becomes:

\[
dA + kB \le n
\quad\Rightarrow\quad
B \le \left\lfloor\frac{n-dA}{k}\right\rfloor
\]

The constraint `b ≤ c` becomes either automatic or an additional lower bound on `B` when `k` is large. This lower bound simplifies to something close to `A`.

## 5) Parity pruning

Because all “sum and difference” factors in the product identity share the same parity, solutions enforce:

- `k ≡ d (mod 2)`
- if `d` is odd, then `A` and `B` must be odd as well

This cuts the search roughly in half.

## 6) Counting `B` without iterating `B`

For fixed `(A, d, k)` we need to count integers `B` in an interval `[L, U]` such that:

- `1 ≤ B ≤ A−1`
- `gcd(A, B) = 1`
- sometimes also `B` must be odd

Instead of scanning `B`, we count coprimes using the Möbius function:

\[
\#\{B\le X:\gcd(A,B)=1\}=\sum_{t\mid A}\mu(t)\left\lfloor\frac{X}{t}\right\rfloor
\]

For “odd `B` only”, we adapt the count by observing that for odd `t`, odd multiples up to `X` are:

\[
\frac{\lfloor X/t\rfloor+1}{2}
\]

The program precomputes squarefree divisors (those with `μ(t) ≠ 0`) for each `A` to keep this fast.

## 7) Grouping `k` by constant floor-division values

Bounds involve expressions like:

- \(\left\lfloor\frac{n-dA}{k}\right\rfloor\)
- \(\left\lceil\frac{dA}{k}\right\rceil = 1+\left\lfloor\frac{dA-1}{k}\right\rfloor\)

These values stay constant over ranges of `k`. The solver walks `k` in blocks where the relevant quotients don’t change, and for each block:

- computes the fixed `[L, U]` for `B`
- counts valid `B` via Möbius inclusion-exclusion
- multiplies by the number of `k` values in that block matching the parity

This is the core optimization that avoids brute force.

---

**Result:** The implementation runs efficiently for `n = 100000` and prints `F(100000)` without hardcoding it.
