# Project Euler 302 Solution - Strong Achilles Numbers

<https://projecteuler.net/problem=302>:

* [302.py](302.py)

This repo contains a single-file Python solution (no third‑party libraries) that counts how many **strong Achilles numbers** are below a given bound.

A number is:

- **powerful** if every prime factor appears with exponent at least 2,
- a **perfect power** if it can be written as `a^k` with `k > 1`,
- an **Achilles number** if it is powerful but **not** a perfect power,
- **strong Achilles** if both `n` and `φ(n)` are Achilles.

## Key ideas used

### 1) Work with prime exponents (gcd test)
For a number `n = ∏ p_i^{e_i}`:

- `n` is powerful ⇔ all `e_i ≥ 2`
- `n` is a perfect power ⇔ `gcd(e_i) > 1`

So to test “Achilles”, we only need:
- all exponents ≥ 2, and
- gcd of all exponents equals 1.

The same rule applies to `φ(n)` once we know its prime factorization.

### 2) Largest prime factor must be cubed (or higher)
If `p` is the largest prime dividing `n` and `n` contains `p^2`, then `φ(n)` contains `p^1` coming from `p^(2-1)`, and no smaller prime can contribute an extra `p` through its `(q-1)` factor (because `q-1 < p`).

Therefore, in any strong Achilles number the **largest prime factor must have exponent ≥ 3**. This limits the search to primes `p` with `p^3 · 2^2` below the bound.

### 3) Incremental factorization of `φ(n)`
When we multiply `n` by `p^e`, the totient updates by:

`φ(p^e) = p^(e-1) · (p-1)`

So we maintain a dictionary `{prime → exponent}` for `φ(n)` and update it by:
- adding `e-1` to the exponent of `p`,
- adding the factorization of `p-1`.

To make this fast, we precompute a smallest‑prime‑factor (SPF) table by sieve and use it to factorize every `p-1` quickly.

### 4) Pruning with “exponent 1” tracking
`φ(n)` must be powerful, so **no prime may end with exponent 1**.

During the DFS we track a set `ones` of primes that currently have exponent exactly 1 inside `φ(n)`. A crucial monotonicity:

- once we go below a prime `q`, no smaller prime `r` can add a factor of `q` via `(r-1)` because `r-1 < q`.

So the search refuses to descend below `max(ones)` unless that exponent 1 has been eliminated.

### 5) DFS over decreasing primes
The search builds `n` by choosing prime powers in strictly decreasing prime order. Exponents are chosen with a small but important rule:

- if `p` is already present in `φ(n)`, exponent 2 is allowed,
- otherwise exponent 2 would create a `p^1` factor in `φ(n)`, which can’t be repaired later — so new primes start at exponent 3.

This keeps the tree compact while remaining complete.

## Running

```bash
python3 main.py
```

The script includes assertions for the two sample counts from the statement and then prints the answer for the `10^18` bound.
