# Project Euler 773 Solution - Ruff Numbers

<https://projecteuler.net/problem=773>:

* [773.py](773.py)

We need

- `S_k = {2, 5}` plus the first `k` primes ending in `7`
- `N_k = product(S_k) = 10 * M` where `M` is the product of those `k` primes
- `F(k)`: sum of all numbers `< N_k` that
  - are not divisible by any element of `S_k` (equivalently: coprime to `N_k` because the factors are distinct primes)
  - have last digit `7`

The program prints `F(97) mod 1_000_000_007` and includes the given check `F(3) = 76101452`.

## 1) Reduce to an arithmetic progression

All numbers with last digit `7` below `N_k = 10M` are exactly:

`x = 7 + 10t` for `t = 0..M-1`.

Such an `x` is automatically not divisible by `2` or `5`, so the only remaining restriction is:

`gcd(x, M) = 1`  (i.e., no prime factor from the `k` primes ending in `7` divides `x`).

## 2) Möbius inversion over the prime factors of `M`

Use the standard identity:

`[gcd(x, M) = 1] = Σ_{d | M, d | x} μ(d)`

So the desired sum becomes:

`F(k) = Σ_x x * Σ_{d|M, d|x} μ(d) = Σ_{d|M} μ(d) * Σ_{x ≡ 7 (mod 10), x < 10M, d|x} x`.

For a fixed squarefree divisor `d | M`, the constraint `d | (7 + 10t)` selects exactly `M/d` values of `t` (since `d | M`).
Those values of `x` form an arithmetic progression with step `10d`.

## 3) A key “ends in 7” observation collapses a huge sum

For any `d` coprime to `10`, the **smallest** positive multiple of `d` that ends in `7` is:

`d * q_d`, where `q_d` is the unique digit in `{1,3,7,9}` such that:

`d * q_d ≡ 7 (mod 10)`.

So `q_d` depends only on `d mod 10`:

- `d ≡ 1 (mod 10) -> q_d = 7`
- `d ≡ 3 (mod 10) -> q_d = 9`
- `d ≡ 7 (mod 10) -> q_d = 1`
- `d ≡ 9 (mod 10) -> q_d = 3`

Because every prime in `M` is `≡ 7 (mod 10)`, any divisor `d` of `M` satisfies:

`d mod 10 = 7^s mod 10`

where `s` is the number of primes in `d`.
Thus `d mod 10` (and therefore `q_d`) depends only on `s mod 4`, not on *which* primes were chosen.

That means:

`Σ_{d|M} μ(d) q_d`

is just a binomial sum over subset sizes, not an exponential sum over all divisors.

## 4) Final form used in code

Let `k` be the number of primes (here `k=97`), and define `q(s)` by:

`s mod 4 : 0  1  2  3`
`q(s)   : 7  1  3  9`

Then:

- `phi(M) = Π (p-1)`
- `A(k) = Σ_{s=0..k} (-1)^s * C(k,s) * q(s)`

and the target is:

`F(k) ≡ M * ( A(k) + 5 * phi(M) ) (mod 1_000_000_007)`.

The implementation computes:

- the first `k` primes ending in `7` by trial division (fast for `k=97`)
- `M (mod MOD)` and `phi(M) (mod MOD)` by simple products
- `A(k)` in `O(k)` using a rolling binomial coefficient recurrence.
