# Project Euler 252 Solution - Convex Holes

<https://projecteuler.net/problem=252>:

* [252.py](252.py)

This repository solves **Project Euler Problem 252**: find the **maximum-area convex hole** among the first 500 pseudo-random points.

A **convex hole** is a convex polygon whose vertices are from the point set and which contains **no other given point strictly inside** it.  
Points **on the perimeter are allowed**.

---

## Core Ideas

### 1) Unique “lowest vertex” normalization
Any convex polygon has a unique **lexicographically smallest** vertex `(y, then x)`.  
We enumerate each point `s` as a candidate lowest vertex and restrict all other chosen vertices to:

- `y > y_s`, or
- `y == y_s and x > x_s`

This guarantees each polygon is considered exactly once.

---

### 2) Empty triangle test using half-plane bitsets
For each directed edge `(u → v)` we precompute the set of points strictly to the left of it:

\[
L(u,v) = \{ w \mid cross(u,v,w) > 0 \}
\]

We store `L(u,v)` as a **bitset** using a Python integer (bit `w` is 1 if point `w` is in the set).

A triangle `(a,b,c)` in CCW order is empty iff:

\[
L(a,b) \cap L(b,c) \cap L(c,a) = \emptyset
\]

Bitset intersections are extremely fast.

---

### 3) Fast construction of all `L(u,v)` via rotating calipers
For each anchor `u`, we sort all other points by angle around `u`, then use a sliding angular window to compute “points within the next 180°”.

A critical subtlety:
- points **collinear on the same ray** as `u→v` have `cross==0`, but **must not prematurely stop** the sliding window.
- We skip them (do not include in left-set) but continue advancing.

Without this fix, the solution overestimates the final answer.

---

### 4) Internal diagonal (fan chord) visibility
We triangulate every polygon as a **fan from the lowest vertex `s`**.  
This means the polygon interior is partitioned into triangles:

\[
(s, v_1, v_2), (s, v_2, v_3), \dots
\]

Even though boundary points are allowed, **points on internal fan diagonals are not allowed**
(because diagonals lie strictly inside the polygon).

So, when a vertex becomes an internal fan vertex, we require:

- no point lies on the **open segment** `(s, v)`.

We precompute `segment_clear[s][v]` by grouping points by reduced direction vectors and checking nearest neighbors along each ray.

---

### 5) Dynamic programming over empty-triangle chains
For fixed `s`, candidates are sorted by polar angle around `s`, making a DAG.

We build edges `(i → j)` if the triangle `(s, i, j)` is:
- CCW (`cross > 0`)
- empty (bitset test)

Then we run DP over directed edges to form convex chains:

- state: best area ending in `prev → curr`
- transition: `prev → curr → next` must be a left turn, and `segment_clear[s][curr]` must hold if `curr` becomes internal

The area is accumulated as a sum of triangle areas, which equals the polygon area.

---

## Correctness Checks

The problem statement provides:

- For the first 20 generated points, maximum area is **1049694.5**

The solution asserts this.

The computed answer for `N=500` is:

- **104924.0**

---

## Performance

- Bitset triangle emptiness makes checks effectively O(1)
- Sparse empty-triangle graph keeps DP efficient
- Runs comfortably in typical Python time limits

---
