# Project Euler 374 Solution - Maximum Integer Partition Product

<https://projecteuler.net/problem=374>:

* [374.py](374.py)

This repo contains a fast, **pure-Python** solution for Project Euler **Problem 374: “Maximum Integer Partition Product”**.

The task is to compute:

\[
\sum_{n=1}^{10^{14}} f(n)\,m(n) \pmod{982451653},
\]

where `f(n)` is the maximum product over partitions of `n` into **distinct** parts, and `m(n)` is the number of parts in any partition achieving that maximum.

## Key ideas

### 1) Shape of the optimal partition (distinct parts)

To maximize a product given a fixed sum, the parts should be as **equal as possible** (AM–GM intuition). With the **distinct** constraint, “as equal as possible” becomes “almost consecutive”.

A standard smoothing argument applies:

- If two parts differ by at least 2, you can transfer 1 from the larger to the smaller and increase the product.
- Repeating this pushes the partition toward a set of numbers that is consecutive (or consecutive except for a single “gap” needed to fit the exact sum).

For each \( n \ge 2 \), let:

\[
S_k = 2+3+\dots+k = \frac{k(k+1)}2 - 1.
\]

There is a unique \(k\ge 2\) such that:

\[
S_k \le n \le S_{k+1}-1.
\]

In that “block” of \(n\)-values, every optimal partition uses exactly \(k-1\) parts (so \(m(n)=k-1\)) and starts from the base set \(\{2,3,\dots,k\}\), with the remaining sum distributed by incrementing the largest parts by 1. This produces a set that is consecutive except possibly missing one number.

### 2) Turning products into factorial ratios

Within a fixed block \(k\), as \(n\) increases by 1, the optimal set is “almost” a consecutive range, meaning its product can be expressed via factorials and (at most) one division by an integer.

Summing over all \(n\) in a full block simplifies nicely: the “missing-number” divisions turn into a sum of modular inverses — i.e., a **harmonic sum** modulo a prime.

### 3) Modular inverses in linear time

The modulus \(p=982451653\) is prime, so every \(1 \le i < p\) has an inverse modulo \(p\). We compute inverses up to \(k_{\max}\approx \sqrt{2N}\) using the classic recurrence:

\[
\text{inv}[1]=1,\quad
\text{inv}[i] = p - \left\lfloor\frac{p}{i}\right\rfloor \cdot \text{inv}[p\bmod i] \pmod p.
\]

This gives all inverses in **O(k\_max)** time.

### 4) Single pass over \(k\) (about 14 million iterations)

Let:

\[
H_k = \sum_{m=3}^{k} \text{inv}[m]\pmod p.
\]

The sum of all `f(n)` values inside a **full** block \(k\) becomes:

\[
\sum_{\text{block }k} f(n)
= k!\,\left(1 + (k+1)H_k + \frac{2k+3}{2}\right)\pmod p.
\]

Since \(m(n)=k-1\) throughout that block, we add \((k-1)\) times this quantity to the answer.

The last block is handled as a partial sum (only up to \(n=10^{14}\)).

## Complexity

- **Time:** \(O(\sqrt{N})\) iterations, about 14 million for \(N=10^{14}\).
- **Memory:** \(O(\sqrt{N})\) to store modular inverses (≈ 56 MB using `array('I')`).

## Files

- `main.py` — computes the required sum and prints the answer.
- Includes `assert`s for the statement’s check values:
  - \(f(5)=6,\ m(5)=2\)
  - \(f(10)=30,\ m(10)=3\) and \(f(10)m(10)=90\)
  - \(\sum_{n=1}^{100} f(n)m(n) = 1683550844462\)
