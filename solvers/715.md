# Project Euler 715 Solution - Sextuplet Norms

<https://projecteuler.net/problem=715>:

* [715.py](715.py)

This repository contains a single-file Python solution (`main.py`) for Project Euler 715.
It is single-threaded and uses only the Python standard library.

---

## 1) Normalization and multiplicativity

The problem defines a counting function \(f(n)\) over 6-tuples modulo \(n\).
After dividing by \(n^2\varphi(n)\), define:

\[
g(n) = \frac{f(n)}{n^2\varphi(n)}.
\]

A Chinese Remainder Theorem argument implies \(f\) is multiplicative, hence so is \(g\).
One can then express \(g\) on prime powers:

- For \(2^e\):
  \[
  g(2^e)=2^{3e}.
  \]

- For odd primes \(p^e\):
  \[
  g(p^e)=p^{3e}-\chi(p)p^{3e-3},
  \]
  where \(\chi\) is the nontrivial Dirichlet character modulo 4:
  \(\chi(1\bmod 4)=1\), \(\chi(3\bmod 4)=-1\), \(\chi(\text{even})=0\).

In particular for primes,
\[
g(p)=p^3-\chi(p).
\]

The task becomes computing the summatory function:
\[
G(N)=\sum_{n\le N} g(n)\pmod{10^9+7}.
\]

---

## 2) Distinct floor-division values

Many fast prime-sum and Min_25 style methods work over the set:

\[
V=\{\lfloor N/i\rfloor\} \cup \{1,2,\dots,\lfloor\sqrt N\rfloor\}.
\]

This set has about \(2\sqrt N\) elements, and is used as the “domain” for
precomputing prime prefix sums at exactly the values needed by the recursion.

---

## 3) Prime prefix sums via a Lucy–Hedgehog sieve variant

The Min_25 recursion needs quick access to:

\[
\sum_{p\le x} g(p) \;=\; \sum_{p\le x} (p^3-\chi(p)).
\]

This is obtained by maintaining two sieve tables over the values in \(V\):

- \(\sum_{p\le x} p^3\)
- \(\sum_{p\le x} \chi(p)\)

Starting from integer prefix sums over \(2..x\) and “sieving away” composites
with the standard prime-sum recurrence (the same idea used to compute
\(\sum_{p\le x} p\) or \(\pi(x)\), but adapted to these weights).

---

## 4) Min_25-style recursion for the full multiplicative sum

Define a helper:

- `S(n, idx)` = sum of \(g(m)\) for \(m\le n\) whose prime factors are all \(\ge p_{idx}\),
  where \(p_{idx}\) is the `idx`-th prime in the list.

This splits the contribution into:

- \(1\),
- primes in a range (queried from the prime-sum table),
- composites built by picking the smallest prime factor \(p\ge p_{idx}\) and its exponent.

Exponent 1 is handled specially to avoid double-counting primes.
Memoization on `(n, idx)` makes repeated subproblems cheap.

---

## 5) Tests

The problem statement provides the checks:

- `G(10) = 3053`
- `G(10^5) ≡ 157612967 (mod 1,000,000,007)`

These appear as assertions in `main.py`.

The program prints `G(10^12) mod 1,000,000,007`.

---
