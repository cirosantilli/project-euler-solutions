# Project Euler 364 Solution - Comfortable Distance

<https://projecteuler.net/problem=364>:

* [364.py](364.py)

This solution counts the number of possible ways `N` people can occupy `N` seats in a row when each person follows the rules:

1. Prefer an empty seat with **no occupied adjacent seats**.
2. If none exist, prefer an empty seat with **exactly one occupied adjacent seat**.
3. Otherwise, take **any** remaining seat.

We need `T(1_000_000) mod 100_000_007`.

## Main techniques used

### 1) Split the process into three forced “stages”
As long as rule (1) is applicable, every chosen seat must have **0 occupied neighbors**, so chosen seats can never be adjacent.
Rule (1) stops exactly when no empty seat has 0 occupied neighbors — meaning the chosen seats form a **maximal independent set** of the path graph (a row of seats).

After that:

- **Stage 1 (rule 1)**: choose all seats in the maximal independent set (any order).
- **Stage 2 (rule 2)**: choose seats with exactly one occupied neighbor (any order).
- **Stage 3 (rule 3)**: only isolated seats remain (each has two occupied neighbors), so any order works.

For a fixed stage partition with sizes `(k, m, r)` the number of valid arrival orders is simply:

- `k! * m! * r!`

because stages cannot interleave (rules force all stage-1 choices first, then stage-2, then stage-3).

### 2) Characterize maximal independent sets on a line via step sizes 2 and 3
In a maximal independent set on a path:

- chosen seats are never adjacent (`...11...` is impossible)
- you can’t have three consecutive unchosen seats (`...000...` would allow the middle seat to be chosen, contradicting maximality)

So between consecutive chosen seats the distance is only:

- **2**: pattern `1 0 1`
- **3**: pattern `1 0 0 1`

Also, at each end you can have at most one leading/trailing zero.

We encode a maximal independent set by:

- `a ∈ {1,2}`: first chosen seat is at position `a` (so `a=2` means one leading zero)
- `b ∈ {0,1}`: last chosen seat is at position `N-b` (so `b=1` means one trailing zero)
- a sequence of step sizes `2` and `3` between chosen seats

Let:

- `p` = number of `3`-steps (gaps of length 2)
- `q` = number of `2`-steps (gaps of length 1)

Then the total distance covered is:

`3p + 2q = N - a - b`

and the number of chosen seats (stage 1 size) is:

`k = 1 + p + q`

The number of distinct step sequences with these counts is a binomial coefficient:

`C(p+q, p) = C(k-1, p)`.

### 3) Count stage-2 choices and simplify stage-3 size
Each `3`-step gap `1 0 0 1` produces **two choices** for which of its two middle seats is taken in stage 2.
So we get a factor `2^p`.

Let `e` be the number of end zeros (`e = (a==2) + (b==1)`).
Those end-zero seats are *forced* stage-2 picks.

So stage sizes are:

- Stage 1: `k`
- Stage 2: `m = p + e`
- Stage 3: `r = N - k - m = p + q = k - 1`

That last identity (`r = k-1`) is the key simplification: stage 3 always contains one remaining seat per gap between stage-1 seats.

### 4) Final summation
For every valid `(a,b,p,q)` we add:

`C(k-1, p) * 2^p * k! * (p+e)! * (k-1)!  (mod M)`

where `M = 100_000_007`.

We precompute factorials and inverse factorials modulo `M` to evaluate the binomial coefficient efficiently.

## Complexity
- Precomputation: `O(N)` for factorials
- Summation: `O(N)` (about `N/3` iterations for each of 4 boundary cases)
- Memory: `O(N)` for factorial tables

## Output
Running `main.py` prints:

`T(1_000_000) mod 100_000_007`
