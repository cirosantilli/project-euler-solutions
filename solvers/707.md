# Project Euler 707 Solution - Lights Out

<https://projecteuler.net/problem=707>:

* [707.py](707.py)

This repository contains a pure-Python solution (no external libraries) for **Project Euler 707**.

## Key ideas

### 1) Linear algebra over GF(2)
Pressing a cell toggles that cell and its edge-neighbors. Over **GF(2)** (“toggle twice = do nothing”), the game becomes a linear system:

- Let **A** be the `wh × wh` matrix that maps a press-pattern to the toggles it produces.
- A starting state `s` is solvable iff `A·p = s` has a solution.
- Therefore, solvable states are exactly the **image** of `A`, so:

\[
F(w,h) = 2^{\operatorname{rank}(A)}.
\]

So the task reduces to computing `rank(A)` over GF(2).

### 2) Row-by-row recurrence and a 1D operator
Writing presses row-by-row gives a 2nd-order linear recurrence for row vectors `x_r` (presses in row `r`):

\[
x_{r+1} = L_w x_r + x_{r-1},
\]

where `L_w` is the `w×w` tridiagonal matrix with ones on the main diagonal and adjacent diagonals (self + horizontal neighbors). Boundary conditions force `x_0 = x_{h+1} = 0`.

Kernel press-patterns correspond to choices of `x_1` such that:

\[
F_{h+1}(L_w)\,x_1 = 0,
\]

where `F_n` are **Fibonacci polynomials** with:

- `F_0 = 0`, `F_1 = 1`
- `F_{n+1} = x F_n + F_{n-1}`

Hence the nullity of the full `wh×wh` matrix is:

\[
\dim \ker(A) \;=\; \dim \ker(F_{h+1}(L_w)).
\]

### 3) “Unreduced tridiagonal” ⇒ cyclic ⇒ polynomial GCD gives nullity
`L_w` is an unreduced tridiagonal matrix (all subdiagonal entries are nonzero), which makes it **cyclic** (its minimal polynomial equals its characteristic polynomial).

For a cyclic matrix `T` with characteristic polynomial `c(x)`:

\[
\dim \ker(P(T)) = \deg(\gcd(c(x), P(x))).
\]

So:

\[
\dim \ker(A) = \deg\bigl(\gcd(\chi_{L_w}(x),\, F_{h+1}(x))\bigr).
\]

We only need `F_{h+1}(x) mod χ_{L_w}(x)` before taking the GCD.

### 4) Fast Fibonacci-polynomial doubling in characteristic 2
Over GF(2), squaring is extremely cheap:

\[
\left(\sum a_i x^i\right)^2 = \sum a_i x^{2i}.
\]

And the Fibonacci-polynomial doubling identities simplify to:

- `F_{2k} = x · (F_k)^2`
- `F_{2k+1} = (F_k)^2 + (F_{k+1})^2`

So `F_n(x) mod χ` can be computed in `O(log n)` steps using only:
- polynomial squaring (bit-position doubling),
- multiplication by `x` (left shift),
- XOR (addition in GF(2)),
- reduction mod `χ` (XOR-based long division).

### 5) Putting it together
For each height `h`:

1. Compute `r(x) = F_{h+1}(x) mod χ_{L_w}(x)`.
2. Compute `g(x) = gcd(χ_{L_w}(x), r(x))`.
3. Nullity is `deg(g)`, so rank is `w·h - deg(g)`.
4. `F(w,h) = 2^{rank}`; for modulo `1_000_000_007`, reduce the exponent modulo `MOD-1`.

Finally, compute:

\[
S(w,n)=\sum_{k=1}^n F(w,f_k)
\]

using Fibonacci heights `f_k`.

## Files

- `main.py` — implementation + asserts for the test values given in the problem statement.
- `README.md` — this explanation.

## Running

```bash
python3 main.py
```

It prints the required value for `S(199,199) (mod 1_000_000_007)`.
