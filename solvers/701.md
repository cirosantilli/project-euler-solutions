# Project Euler 701 Solution - Random Connected Area

<https://projecteuler.net/problem=701>:

* [701.py](701.py)

This solution computes the expected size of the **largest connected black component**
in a randomly coloured `W × H` grid (each cell black with probability `1/2`).

The target is `E(7,7)` rounded to 8 decimal places.

---

## Key Ideas / Techniques

### 1) Sweep-line (frontier) dynamic programming
Instead of enumerating all `2^(W·H)` grids, we process cells **one at a time**
in row-major order and maintain a *frontier* state describing how currently-open
black components touch the boundary between processed and unprocessed cells.

For `W = 7`, the frontier width is only 7 cells, so the number of possible
connectivity patterns is manageable.

---

### 2) Canonical labelling of connected components
The frontier stores component IDs like:

- `labels`: length `W`, each entry is `0` (white) or a component ID.
- `sizes`: sizes of active components indexed by `ID-1`.

After each update we **canonicalize IDs** by renaming components in order of
first appearance across the frontier.  
This merges equivalent states and greatly reduces DP blow-up.

---

### 3) Closing components when they leave the frontier
When a component no longer appears in the frontier after processing a cell,
it **cannot** connect to any future cells, so it is *closed*.
At that point we can safely:

- update the running maximum component size
- discard that component from active tracking

---

### 4) Tracking the maximum via a distribution
The “current maximum closed component size so far” is not linear, so we maintain
a **distribution** over possible maximum values for each frontier connectivity
state.

The update rule is simple:

- `new_max = max(old_max, closed_max_this_step)`

This is handled by remapping counts in the per-state distribution.

---

### 5) Transition caching
A cell update depends only on:

- the frontier connectivity `(labels, sizes)`
- the current column index
- whether the new cell is black or white

So we cache transitions:

`(labels, sizes, col, color) -> (labels2, sizes2, closed_max)`

This prevents repeated recomputation of unions, merges, and canonicalization.

---

## Correctness Checks
The code includes asserts for the values explicitly given in the problem statement:

- `E(2,2) = 1.875` (checked exactly as a rational)
- `E(4,4) = 5.76487732` (checked at 8-decimal rounding)

---

## Running

```bash
python3 main.py
