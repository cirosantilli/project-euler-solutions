# Project Euler 835 Solution - Supernatural Triangles

<https://projecteuler.net/problem=835>:

* [835.py](835.py)

A *supernatural* Pythagorean triangle is an integer right triangle where **two sides are consecutive integers**.  
Let `S(N)` be the sum of perimeters of all distinct supernatural triangles with perimeter `≤ N`.  
The task is to compute `S(10^(10^10)) (mod 1234567891)`.

This repository contains a single script `main.py` that prints the required value.

## Key ideas

### 1) Classify all supernatural Pythagorean triples

Using standard properties of Pythagorean triples, there are only two infinite families:

**Family B: hypotenuse and a leg are consecutive**

If the larger leg and hypotenuse are consecutive, `c = b + 1` and:

- `a^2 + b^2 = (b+1)^2  =>  a^2 = 2b + 1`
- Let `a = t` where `t` must be **odd**, then:
  - `b = (t^2 - 1) / 2`
  - `c = (t^2 + 1) / 2`
  - Perimeter: `P = a + b + c = t^2 + t = t(t+1)`

So every odd `t ≥ 3` yields a distinct supernatural triangle in this family.

**Family A: the two legs are consecutive**

Let the legs be `a` and `a+1`:

- `a^2 + (a+1)^2 = c^2  =>  (2a+1)^2 - 2c^2 = -1`
- Set `x = 2a+1`, `y = c`. Then `(x, y)` solve the Pell-type equation:
  - `x^2 - 2y^2 = -1`

Each solution produces a triangle with perimeter `P = x + y`.

The two families overlap only at the `3-4-5` triangle (perimeter `12`), which must be counted once.

---

### 2) Sum Family B without iteration (closed forms)

For the problem’s `N = 10^(10^10)`, write `N = 10^(2M)` with `M = 5·10^9`.

For family B we need all odd `t` with `t(t+1) ≤ 10^(2M)`.

Because `10^(2M) = (10^M)^2`, the maximal `t` is exactly:

- `t_max = 10^M - 1` (since `10^M(10^M+1)` is already too large)

Let `t` run over all odds `1, 3, 5, ..., 10^M-1`.  
The number of such odds is `n = 10^M / 2`.

Then we use classic identities:

- `1 + 3 + ... + (2n-1) = n^2`
- `1^2 + 3^2 + ... + (2n-1)^2 = (4n^3 - n) / 3`

The desired sum is `Σ(t^2 + t)` over odd `t ≥ 3`, which is:
- `(Σ t^2 + Σ t) - (1^2 + 1)`

All arithmetic is done **modulo `1234567891`**, using modular inverses (e.g. division by 3).

---

### 3) Sum Family A with fast linear recurrences (matrix exponentiation)

The perimeters from Pell solutions satisfy a simple second-order recurrence:

- `P_0 = 2` (degenerate)
- `P_1 = 12` (the `3-4-5` triangle)
- `P_{n+2} = 6P_{n+1} - P_n`

To compute the prefix sum `S_A(n) = P_1 + ... + P_n` for `n ≈ 10^10` efficiently,
we augment the recurrence state to include the running sum and use **3×3 matrix exponentiation**:

State vector:
- `[P_n, P_{n-1}, S_n]^T`

This yields `S_n` in `O(log n)` time.

---

### 4) How many Pell terms fit under `10^(10^10)`?

We need the largest `n` with `P_n ≤ 10^E`, where `E = 10^10`.

`P_n` grows exponentially with ratio `α = 3 + 2√2`, so we determine `n` by comparing in base-10 logs:

- `log10(P_n) ≈ log10(A) + n·log10(α)`

This avoids constructing `10^E`, which is infeasible.

---

## Correctness checks

The problem statement provides:

- `S(100) = 258`
- `S(10000) = 172004`

`main.py` includes `assert` checks for these values using a small-`N` brute force routine.

---

## Complexity

- Family B: `O(log M)` via modular exponentiation (`pow(10, M-1, MOD)`).
- Family A: `O(log n)` via matrix exponentiation.
- Total runtime is effectively constant (milliseconds/seconds), and memory usage is `O(1)`.

---

## Usage

Run:

```bash
python3 main.py
```

It prints the required value modulo `1234567891`.
