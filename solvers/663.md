# Project Euler 663 Solution - Sums of Subarrays

<https://projecteuler.net/problem=663>:

* [663.py](663.py)

This solution computes:

\$\$S(n,10\,200\,000) - S(n,10\,000\,000) = \sum_{i=10\,000\,001}^{10\,200\,000} M_n(i)\$\$

where each step performs a point update on an array `A_n` and `M_n(i)` is the maximum sum of any contiguous subarray after step `i`.

## Main techniques used

### 1) Tribonacci generation modulo `n` (two-at-a-time)
The update at step `i` needs `t_{2i-2} mod n` (index) and `t_{2i-1} mod n` (value for the increment).

We keep a rolling window `(u0, u1, u2) = (t_k, t_{k+1}, t_{k+2}) mod n` and advance by **two** tribonacci steps per iteration, so each loop yields exactly the pair needed for the current update.

To avoid the slower `%` operator, we use the fact that each tribonacci sum is `< 3n` and reduce with up to two conditional subtractions.

### 2) “Max subarray sum” via segment summaries
For any segment, we store four values:

- `sum`: total sum of the segment
- `pref`: maximum non-empty prefix sum
- `suff`: maximum non-empty suffix sum
- `best`: maximum non-empty subarray sum

Two segments combine in O(1):

- `sum = sumL + sumR`
- `pref = max(prefL, sumL + prefR)`
- `suff = max(suffR, sumR + suffL)`
- `best = max(bestL, bestR, suffL + prefR)`

### 3) Block decomposition to keep memory small
A full segment tree over `n = 10,000,003` elements would be too large in Python.

Instead we:
- Store the full array `A` in a compact `array('q')` (signed 64-bit).
- Split `A` into fixed blocks of size `B = 256`.
- Build a segment tree **over blocks** (≈ 39k blocks), where each leaf is the 4-value summary of a block.

### 4) Only maintain the data structure when needed
We only need `M_n(i)` for the last 200,000 steps:

1. Apply the first 10,000,000 updates directly to `A` (no max-subarray queries).
2. Build the block tree once from the current `A` (one linear pass).
3. For steps 10,000,001 … 10,200,000:
   - apply the point update,
   - recompute the affected block summary by scanning **only 256 elements**,
   - update the block tree on the path to the root,
   - read `M_n(i)` from the tree root in O(1).

## Complexity
Let `m = ceil(n/B)` be the number of blocks.

- First 10,000,000 steps: **O(10,000,000)** point updates.
- Building block tree: **O(n)** scan.
- Last 200,000 steps: each step costs **O(B + log m)** (scan one block + update tree).

Memory is dominated by the 64-bit array `A` (~80 MB) plus a small block tree.
