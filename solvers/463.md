# Project Euler 463 Solution - A Weird Recurrence Relation

<https://projecteuler.net/problem=463>:

* [463.py](463.py)

This repository contains a fast solver for:

- A function `f(n)` defined by a “weird” recurrence
- `S(n) = sum_{i=1..n} f(i)`
- Target: `S(3^37) mod 10^9` (the last 9 digits)

The implementation is in `main.py` and uses only the Python standard language features (no external libraries).

## Techniques used

### 1) Turn the recurrence into a 2×2 linear state machine

The recurrence mixes values like `f(n)`, `f(2n)`, and `f(2n+1)`.  
Define an auxiliary function:

- `g(k) = f(2k+1)`

and a 2D state vector:

- `v(k) = [ f(k), g(k) ]^T`

From the problem definition, you can derive *linear* transitions for appending a binary digit:

- `v(2k)   = M0 · v(k)`
- `v(2k+1) = M1 · v(k)`

with constant matrices:

```
M0 = [ 1  0 ]      M1 = [ 0  1 ]
     [ -1 2 ]           [ -2 3 ]
```

So computing `f(n)` becomes: start from `v(1) = [1, f(3)=3]^T` and walk through the bits of `n` (after the leading `1`), applying `M0` for a `0` bit and `M1` for a `1` bit.

That gives `f(n)` in `O(log n)` time.

### 2) Sum over power-of-two blocks using a matrix power

To compute `S(n)` we avoid iterating all `i`.

Any aligned block of size `2^d` is:

- `[ k·2^d , k·2^d + 2^d - 1 ]`

These are exactly the numbers whose binary representation is the bits of `k` followed by *all* possible `d`-bit suffixes.

For a fixed `k`, each suffix corresponds to multiplying by `M0`/`M1`. Summing over *both* choices at each step replaces “branching” with a single matrix:

- `A = M0 + M1`

Then the block sum becomes a simple linear expression:

```
sum_{x=0..2^d-1} f(k·2^d + x) = [1, 0] · A^d · v(k)
```

So a block sum costs one `A^d` (fast exponentiation) and one `v(k)`.

### 3) Decompose `[1..n]` into O(log n) aligned blocks

The range `[1..n]` can be covered by disjoint, aligned power-of-two blocks (a standard “binary decomposition” of an interval).

For each block we compute the block sum above and add it to the result modulo `10^9`.

Overall runtime is tiny because:

- the number of blocks is `O(log n)` (≈ 60 for `3^37`)
- each block needs only `O(log d)` matrix exponentiation and `O(log k)` bit-walking

### 4) Work entirely modulo 10^9

We only need the last 9 digits, so all arithmetic is performed modulo `10^9`.
The recurrence is linear, so this modular reduction is valid throughout.

## Sanity checks

`main.py` includes asserts for the test values from the statement:

- `f(1)=1`, `f(3)=3`
- `S(8)=22`
- `S(100)=3604`

## Running

```bash
python3 main.py
```

It prints the answer as a 9-digit number (zero-padded if needed).
