# Project Euler 763 Solution - Amoebas in a 3D Grid

<https://projecteuler.net/problem=763>:

* [763.py](763.py)

This repository contains a pure-Python solution for **Project Euler 763** (Amoebas / monster splitting in a 3D grid), computing the **last nine digits of `D(10000)`**.

The code follows a dynamic programming approach that avoids enumerating configurations directly, because the number of reachable point sets grows extremely fast.

---

## Key techniques used

### 1) Reversing the process into a structured counting problem
Instead of simulating forward “splits” (which branch explosively), the analysis commonly used for this problem rewrites the process in terms of *valid merge histories* / *dependency graphs* induced by the splitting rules. This yields a recurrence-based counting framework.

### 2) Canonical encoding of boundary states (bitstring compression)
A crucial step is encoding the evolving “frontier” (often described as a red path with attached blue nodes in community derivations) into a normalized bitstring form.  
After normalization and symmetry reductions, the recurrence can be expressed as:

- `f(n, x, m)` = number of ways to reach a state described by bitstring `x` of length `n` after `m` splits.

### 3) Dependency on only the first differing bit
A major complexity reduction comes from observing that for fixed `(n, m)` the value `f(n, x, m)` depends only on the position of the first bit where `x` deviates from the topmost bit pattern.  

This reduces the huge `2^n` family to two indexed families:

- `u(n, k, m)` = “prefix has exactly `k` ones”
- `v(n, k, m)` = “prefix has exactly `k` zeros”
- where `1 ≤ k ≤ n`.

This collapses the state space from exponential to roughly **O(n²)** per `m`.

### 4) Triangular “impossibility” cutoff
For many `(n, m)` pairs the state is impossible:  
`f(n, ., m) = 0` whenever `m < (n+1)(n+2)/2`.  

This “triangular bound” dramatically limits the number of states that must be computed.

### 5) Bottom-up DP with time-shifted recurrences
Each `u(n, k, m)` and `v(n, k, m)` depends only on values with **strictly smaller `m`**, with shifts such as `m - n - 2`, `m - n - 3`, etc.  
Therefore a single pass over `m = 0..9999` is sufficient.

### 6) Modulo arithmetic and fixed-width storage
Only the last nine digits are required, so all large DP values are reduced modulo `10^9`.  
The implementation stores DP tables in `array('I')` to reduce memory overhead.

---

## Testing
The code includes `assert` checks for all sample values given in the problem statement:

- `D(2) = 3`
- `D(10) = 44499`
- `D(20) = 9204559704` (checked exactly with a small non-mod run)
- last nine digits of `D(100)` are `780166455`

---

## Running
Just run:

```bash
python3 main.py
