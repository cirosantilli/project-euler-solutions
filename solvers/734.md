# Project Euler 734 Solution - A Bit of Prime

<https://projecteuler.net/problem=734>:

* [734.py](734.py)

This solution counts **k-tuples of primes** whose **bitwise OR** is also a prime (all values `≤ n`), modulo `1_000_000_007`.

## Key idea: inclusion–exclusion over bits, then swap the sums

For a fixed prime `y`, let `B(y)` be the set of 1-bits in `y`.

- A prime `x` is allowed in the tuple if `x` is a **submask** of `y` (i.e. `x | y = y`).
- Let `A(m)` be the number of primes `x ≤ n` that are submasks of `m`.

Then the number of k-tuples whose OR is **exactly** `y` can be written by inclusion–exclusion over missing bits:

\[
\#(\mathrm{OR}=y)=\sum_{m \subseteq y} (-1)^{\mathrm{pop}(y)-\mathrm{pop}(m)} A(m)^k
\]

Summing this over all prime `y` is still expensive if done per-`y`.  
So we **swap** the order of summation and collect coefficients per `m`:

\[
T(n,k)=\sum_m A(m)^k \cdot (-1)^{\mathrm{pop}(m)} \cdot S(m)
\]

where

\[
S(m)=\sum_{\substack{y\ \text{prime} \\ y\supseteq m}} (-1)^{\mathrm{pop}(y)}
\]

Now the task is to compute `A(m)` for all masks `m`, and `S(m)` for all masks `m`.

## Technique 1: subset zeta transform for `A(m)`

Let `f[x]=1` if `x` is prime (and `x ≤ n`), else `0`.  
Then

\[
A(m)=\sum_{x\subseteq m} f[x]
\]

This is exactly a **subset sum over bitmasks**, computed for all `m` in `O(B·2^B)` using the classic zeta transform.

## Technique 2: superset zeta transform for `S(m)`

Define `h[y]=(-1)^{popcount(y)}` if `y` is prime (and `y ≤ n`), else `0`.  
Then

\[
S(m)=\sum_{y\supseteq m} h[y]
\]

This is a **superset sum over bitmasks**, also computable in `O(B·2^B)` by iterating bits and adding from `m|bit` into `m`.

## Technique 3: fast modular exponentiation

After both transforms, the final sum is:

- one loop over `m = 0..n`
- with a single `pow(A(m), k, MOD)` per `m`

Python’s built-in `pow(base, exp, mod)` performs fast modular exponentiation.

## Complexity

Let `B = bit_length(n)` and `U = 2^B`.

- Sieve: `O(n log log n)`
- Two zeta transforms: `O(B·U)`
- Final accumulation: `O(n)` modular exponentiations

For `n = 10^6`, `B = 20`, `U = 1,048,576`, which is practical in pure Python.
