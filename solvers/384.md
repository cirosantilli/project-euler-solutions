# Project Euler 384 Solution - Rudin-Shapiro Sequence

<https://projecteuler.net/problem=384>:

* [384.py](384.py)

This repository contains a fast, no-external-libraries solution for **Project Euler 384**.

## Key ideas used

### 1) Bit trick for `a(n)`
`a(n)` counts overlapping occurrences of `11` in the binary expansion of `n`.
That is exactly the number of bit positions where both a bit and the next lower bit are `1`:

- compute `n & (n >> 1)`
- count its `1` bits (`bit_count()`)

So:

- `a(n) = popcount(n & (n >> 1))`
- `b(n) = (-1)^{a(n)}` is `+1` if `a(n)` is even, else `-1`.

### 2) Self-similarity in base 2 (block-of-4 recursion)
The Rudinâ€“Shapiro sign sequence satisfies:

- `b(2n) = b(n)`
- `b(2n+1) = (-1)^n b(n)`

From this you can derive a convenient block-of-4 structure:

- `b(4n)   = b(4n+1) = b(n)`
- `b(4n+2) = (-1)^n b(n)`
- `b(4n+3) = (-1)^{n+1} b(n)`

That implies a recursive description of the summatory sequence `s(n)` on indices `4n..4n+3`
in terms of smaller values such as `s(n)` and simple signs.

### 3) Inverting `s(n)` via recursion on the highest power of two
We need `g(t,c)`: the index where the value `t` appears for the `c`-th time in `s(n)`.
Direct simulation is impossible for `t` up to ~`1.8e9`.

The crucial observation is that the structure induced by the base-2 recurrences lets you
split the `(t,c)` query into smaller subproblems by the highest power of two `h <= t`.
Writing `t = h + d` (where `h` is the MSB power-of-two and `0 <= d < h`), the occurrences
of `t` in `s(n)` can be mapped to occurrences of smaller targets in smaller ranges,
plus a known index offset (like `h*h`, `h*h//2`, `t*t//4`, etc.).

This yields a recursion for `g(t,c)` whose depth is `O(log t)`.

### 4) Final computation
Compute Fibonacci numbers `F(0..45)` (with `F(0)=F(1)=1`), then sum:

`GF(t) = g(F(t), F(t-1))` for `t=2..45`.

## Complexity
- Each `g(t,c)` call: `O(log t)` time, `O(log t)` recursion depth.
- Only 44 calls (for `t=2..45`), so the total runtime is tiny.
- Uses only Python integers (handles the ~`1e18`-scale indices safely).

## Output
Running `python3 main.py` prints the required sum.
