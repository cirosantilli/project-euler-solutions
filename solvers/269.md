# Project Euler 269 Solution - Polynomials with at Least One Integer Root

<https://projecteuler.net/problem=269>:

* [269.py](269.py)

We define `P_n(x)` as the polynomial whose coefficients are the digits of `n` (in order). For example:

`n = 5703  ->  P_n(x) = 5x^3 + 7x^2 + 0x + 3`.

`Z(k)` counts how many `1 <= n <= k` have **at least one integer root**.

This repository solves **`Z(10^16)`**.

## Main ideas

### 1) The only non-negative integer root is `0`

All coefficients are digits (non-negative), and the leading digit is positive. Therefore for any `x > 0`,
`P_n(x) > 0`, so **no positive integer** can be a root.

So the only possible non-negative root is `x = 0`, which happens iff the constant term is `0`, i.e. the
number ends in `0`.

For `n <= 10^16`, the count of such numbers is exactly `10^15`.

### 2) Negative roots are limited to `-1 .. -9`

By the Rational Root Theorem, any integer root must divide the constant term. The constant term is the
last digit (0–9), so the only possible nonzero integer roots are among `±1 .. ±9`.

Combined with the previous observation (no positive roots), we only need to consider **negative roots**
`x = -k` where `1 <= k <= 9`.

### 3) Counting `P_n(-k) = 0` with a “carry” DP

Write the digits from least significant upward as `d_0, d_1, ...`. We want:

`sum(d_i * (-k)^i) = 0`.

Maintain a carry `c_i` such that the partial sum of the first `i` digits equals:

`S_i = c_i * (-k)^i`.

When we add digit `d_i`:

`S_{i+1} = (c_i + d_i) * (-k)^i`.

For this to be divisible by `(-k)^{i+1}`, we need `(c_i + d_i)` divisible by `k`, and then:

`c_{i+1} = -(c_i + d_i) / k`.

This yields a compact state transition on small integers. For a fixed set of roots `{ -k }`, we track a
vector of carries and run a digit DP for lengths up to 16.

### 4) Union over roots via inclusion–exclusion

We count numbers (with last digit nonzero) that satisfy **at least one** of the conditions `P_n(-k) = 0`
for `k = 1..9` using inclusion–exclusion over subsets of `{1..9}`.

This is feasible because there are only `2^9 - 1 = 511` nonempty subsets, and each subset DP has a small
reachable state space for length ≤ 16.

### 5) Using the special bound `10^16`

`10^16 - 1` is a 16-digit number of all 9s, so the set `{ 1 <= n <= 10^16 - 1 }` is exactly all numbers
with **1 to 16 digits**. We can count by length and then add the final number `10^16` (which is already
captured by the “ends with 0” case).

## Correctness check

The problem statement provides:

* `Z(100000) = 14696`

The code includes an `assert` that brute-forces this value.
