# Project Euler 876 Solution - Triplet Tricks

<https://projecteuler.net/problem=876>:

* [876.py](876.py)

We repeatedly apply one of these involutions to a triple `(a,b,c)`:

- `a ← 2(b+c) − a`
- `b ← 2(c+a) − b`
- `c ← 2(a+b) − c`

Let `f(a,b,c)` be the minimum number of steps until **any** entry becomes `0`
(or `0` if it never happens). For fixed `a,b` define:

`F(a,b) = Σ_{c≥1} f(a,b,c)`.

The program computes `Σ_{k=1..18} F(6^k, 10^k)`.

---

## 1) Turning “reach 0” into a Diophantine condition

Introduce the homogeneous quadratic form

`q(x,y) = a x^2 + (c−a−b) x y + b y^2`.

A non‑trivial integer solution of `q(x,y)=0` exists **iff** the form factors over the rationals,
which is equivalent to the discriminant being a perfect square:

`D = (c−a−b)^2 − 4ab` is a square.

Why does this match the original process?

- Each allowed move is an involution and corresponds to a simple change of variables for `q(x,y)`.
- Therefore `D` is invariant along any sequence of moves.
- If at some point one entry becomes `0`, the resulting discriminant is obviously a square.
  By invariance, the starting triple must also have square discriminant.
- Conversely, when `D` is a square, the form splits and we can steer the process to a zero.

So for fixed `a,b`, only finitely many `c` have `f(a,b,c) > 0`, because `D` being a square forces
a factorisation of `4ab`.

---

## 2) Parametrising all valid `c` with divisor pairs

Write `a = x·u` and `b = y·v` where `x|a` and `y|b`.
Then the two values

- `c₊ = (x + y)(u + v)`
- `c₋ = (x − y)(u − v)` (keep only when positive)

always satisfy the square‑discriminant condition, because:

`c₊ − a − b = xv + yu` and `c₋ − a − b = −(xv + yu)`

so

`D = (xv + yu)^2 − 4(xu)(yv) = (xv − yu)^2`.

A key point is that **every** `c` with `D` square can be produced from some divisor pair `(x,y)`
by one of these formulas, so it suffices to enumerate divisors of `a` and `b`.

For `a = 6^k` and `b = 10^k`, the number of divisors is small:
`d(6^k) = (k+1)^2` and `d(10^k) = (k+1)^2`, so we can scan all `(x,y)` pairs.

---

## 3) Computing the minimal step count via Euclid

Each valid `c` comes from at least one pair `(x,y)`.
The minimal number of moves to reach a zero can be read off from how `(x,y)` sits in the
same “add/subtract” tree as the Euclidean algorithm.

Working **backwards** from a successful triple, the effect on the relevant pair is:

- replace the larger of `x,y` by `|x−y|`

which is exactly the *subtractive* Euclidean algorithm.
Therefore:

- for `c₊` the step count is the number of subtraction steps for `(x,y)`,
- for `c₋` it is one less (it corresponds to hitting the target hyperplane one move earlier).

To compute subtraction steps quickly we use the standard Euclidean algorithm and sum quotients.

---

## 4) Putting it together

For each `k`:

1. List all divisors `x|6^k` and `y|10^k`.
2. For each pair `(x,y)`:
   - compute `s = subtraction_steps(x,y)`
   - generate `c₊` and `c₋` (if positive)
   - keep the **minimum** step count seen for each `c`.
3. `F(6^k,10^k)` is the sum over all recorded minima.

Finally sum over `k=1..18`.

**Complexity:**  
For each `k`, we check `(k+1)^4` divisor pairs; with `k≤18` this is about `1.3×10^5` pairs per `k`,
and the Euclidean step computation is `O(log min(x,y))`. This easily fits in a single CPU core.

---

## Running

```bash
python3 main.py
```

The program includes asserts for the example values from the statement and then prints the final result.
