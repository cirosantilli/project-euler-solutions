#!/usr/bin/env python3
# Generated by GPT-5.2 Thinking web UI on 2025-12-24.
"""
Project Euler 175
Fractions involving the number of different ways a number can be expressed as a sum of powers of 2,
each power used at most twice (hyperbinary representations).

We use the known identity:
  f(n) = Stern(n+1)
and the Calkin–Wilf / Stern–Brocot path to recover the smallest n such that:
  f(n) / f(n-1) = p/q

Output required by Euler 175: the "shortened binary expansion" (SBE) of n.
"""

from __future__ import annotations

from functools import lru_cache
from math import gcd
from typing import List, Tuple


def shortened_binary_expansion_for_fraction(p: int, q: int) -> List[int]:
    """
    Return the shortened binary expansion (run-length encoding starting with 1s)
    of the smallest n such that f(n)/f(n-1) = p/q.

    This is computed via an accelerated Euclidean algorithm on (q, p), yielding
    the run-lengths of bits along the corresponding Calkin–Wilf path, merged with
    the leading '1' bit of any positive integer.
    """
    a, b = q, p
    g = gcd(a, b)
    a //= g
    b //= g

    # Steps from leaf to root as (bit, count), where:
    #  bit=1 corresponds to "go right" (a>b), bit=0 corresponds to "go left" (b>a).
    steps: List[Tuple[int, int]] = []
    while a != b:
        if a > b:
            k = (a - 1) // b
            steps.append((1, k))
            a -= k * b
        else:
            k = (b - 1) // a
            steps.append((0, k))
            b -= k * a

    # Reverse to get root->leaf bits (excluding the implicit leading 1 of n),
    # then merge with the leading 1.
    runs = list(reversed(steps))
    sbe: List[int] = []
    cur_bit = 1
    cur_len = 1  # leading '1' in n's binary form

    for bit, count in runs:
        if bit == cur_bit:
            cur_len += count
        else:
            sbe.append(cur_len)
            cur_bit = bit
            cur_len = count
    sbe.append(cur_len)
    return sbe


def sbe_to_int(sbe: List[int]) -> int:
    """Convert a run-length SBE (starting with 1s) back into the integer n."""
    bit = 1
    n = 0
    for length in sbe:
        n <<= length
        if bit == 1:
            n |= (1 << length) - 1
        bit ^= 1
    return n


@lru_cache(None)
def stern(n: int) -> int:
    """Stern's diatomic sequence a(n)."""
    if n == 0:
        return 0
    if n == 1:
        return 1
    if n % 2 == 0:
        return stern(n // 2)
    k = n // 2
    return stern(k) + stern(k + 1)


def hyperbinary_count(n: int) -> int:
    """Number of hyperbinary representations f(n) equals Stern(n+1)."""
    return stern(n + 1)


def solve() -> str:
    p = 123456789
    q = 987654321
    sbe = shortened_binary_expansion_for_fraction(p, q)
    return ",".join(map(str, sbe))


def _assert_examples() -> None:
    # Problem statement example:
    # For p/q = 13/17, the smallest n is 241, binary 11110001, SBE = [4,3,1]
    sbe = shortened_binary_expansion_for_fraction(13, 17)
    assert sbe == [4, 3, 1]
    n = sbe_to_int(sbe)
    assert n == 241
    assert hyperbinary_count(241) == 13
    assert hyperbinary_count(240) == 17


if __name__ == "__main__":
    _assert_examples()
    print(solve())
