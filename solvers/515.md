# Project Euler 515 Solution - Dissonant Numbers

<https://projecteuler.net/problem=515>:

* [515.py](515.py)

## Core observation

Define (for prime `p`):

- `d(p,n,0)` = the modular inverse of `n` mod `p`
- `d(p,n,k) = ∑_{i=1..n} d(p,i,k-1)` for `k ≥ 1`
- `D(a,b,k) = ∑ ( d(p,p-1,k) mod p )` over primes `a ≤ p < a+b`

The naive recursion is far too slow for `k = 10^5`.  
The trick is to **evaluate `d(p,p-1,k) mod p` in closed form**.

---

## 1) Iterated prefix sums → binomial weights

Let `d_k(n) = d(p,n,k)` (with fixed `p`).  
The recurrence

`d_k(n) = ∑_{i=1..n} d_{k-1}(i)`

means `d_k` is the **k-fold prefix sum** of `d_0`.

A standard “hockey-stick” argument gives, for `k ≥ 1`:

`d_k(n) = ∑_{i=1..n} C(n-i+k-1, k-1) * d_0(i)`

So at `n = p-1`:

`d_k(p-1) = ∑_{i=1..p-1} C(p-1-i+k-1, k-1) * inv(i)   (mod p)`.

---

## 2) Flip the index to remove the inverse

Set `j = p - i`. Then `inv(p-j) ≡ inv(-j) ≡ -inv(j) (mod p)`, and

`C(p-1-i+k-1, k-1) = C(k+j-2, k-1)`.

So:

`d_k(p-1) ≡ - ∑_{j=1..p-1} inv(j) * C(k+j-2, k-1)   (mod p)`.

Now use:

`C(k+j-2, k-1) = j(j+1)...(j+k-2) / (k-1)!`

and multiply by `inv(j)` to cancel the `j`:

`inv(j) * C(k+j-2, k-1) = (j+1)(j+2)...(j+k-2) / (k-1)!`.

This is a **rising factorial** of length `k-2`:

`(j+1)_(k-2) / (k-1)!`.

Thus (for `k ≥ 2`):

`d_k(p-1) ≡ - (1/(k-1)!) * ∑_{j=1..p-1} (j+1)_(k-2)   (mod p)`.

---

## 3) Sum of rising factorials telescopes

Rising factorials have a discrete-antiderivative identity:

`(t+1)_(m+1) - t_(m+1) = (m+1) * (t+1)_m`.

Summing from `t=0..N` gives:

`∑_{t=0..N} (t+1)_m = (N+1)_(m+1) / (m+1)`.

We need `∑_{j=1..p-1} (j+1)_m` with `m = k-2`:

`∑_{j=1..p-1} (j+1)_m
 = ∑_{t=0..p-1} (t+1)_m - (1)_m
 = p_(m+1)/(m+1) - m!`.

Crucially, `p_(m+1) = p(p+1)...(p+m)` is **divisible by `p`**, so modulo `p` it vanishes:

`∑_{j=1..p-1} (j+1)_m ≡ -m!   (mod p)`.

Plugging back:

`d_k(p-1) ≡ - (1/(k-1)!) * ( - (k-2)! ) ≡ 1/(k-1)   (mod p)`,

valid whenever `2 ≤ k < p`.

So the hard recursion collapses to:

> **`d(p,p-1,k) mod p = inv(k-1, p)`**  (for `k ≥ 2` and `k < p`)

---

## 4) What the program actually computes

Therefore:

`D(a,b,k) = ∑_{primes p in [a,a+b)} inv(k-1, p)`.

The implementation does two things:

1. **Segmented sieve** to enumerate primes in `[a, a+b)`  
   (only needs small primes up to `sqrt(a+b)`).
2. For each prime `p`, compute `inv(k-1, p)` via Fermat:
   `inv(x,p) = x^(p-2) mod p`.

Total work is tiny here: the interval length is `10^5`, and there are only ~5k primes.

---

## Complexity

Let `B = b` and `A = a+b`.

- Sieve up to `sqrt(A)`: `O(sqrt(A) log log sqrt(A))`
- Segmented marking: about `O(B log log A)` operations
- Inverses: `O(π(B) log p)` using fast modular exponentiation

All easily fits in time in pure Python.
