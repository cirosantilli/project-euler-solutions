# Project Euler 852 Solution - Coins in a Box

<https://projecteuler.net/problem=852>:

* [852.py](852.py)

This repository contains a fast, no-dependencies Python solution for **Project Euler 852**.

## Key ideas

### 1) Separate “this round” from “future rounds”
After each round, the coin’s type is revealed and the coin is discarded **regardless of the player’s actions**.
That means your toss/stop/guess choices cannot change the distribution of the next state `(unfair_left, fair_left)`.

So the optimal expected value from a state `(u, f)` splits cleanly into:

- **Immediate expected gain** for the current coin, assuming the prior probability that it’s unfair is `p = u / (u+f)`.
- **Expected future value** after discarding the coin.

This yields the outer DP recurrence:

`V[u][f] = G(u/(u+f)) + (u/(u+f))*V[u-1][f] + (f/(u+f))*V[u][f-1]`.

Here `G(p)` is the optimal expected net gain for **one** coin (including toss costs and the final guess reward).

### 2) The per-coin problem is a Bayesian optimal stopping DP
For a single coin, after each toss we update the posterior `p = P(unfair)` via Bayes.
At any time we can:

- **Stop** and guess the more likely type (a simple linear expected value in `p`), or
- **Continue**: pay `-1` for another toss, then take the expectation over the two possible outcomes.

This is a classic sequential decision/optimal stopping problem.

### 3) Efficient state representation via counts `(n, h)`
If we have tossed `n` times and seen `h` heads, the likelihood ratio between unfair and fair is:

`(0.75^h * 0.25^(n-h)) / (0.5^n) = 3^h / 2^n`.

So the posterior odds are:

`odds = odds0 * 3^h * 2^{-n}`, where `odds0 = p0/(1-p0)`.

This lets the per-coin DP run over the triangular grid of states `(n, h)`.

### 4) Truncating the infinite horizon safely
The per-coin decision allows “any number of tosses”, which is an infinite-horizon problem.
In practice, because every toss costs `1` point while the final guess reward is bounded, the optimal policy
almost surely stops quickly.

The code computes `G(p)` with a conservative horizon `MAX_FLIPS = 180` by forcing a stop at that depth.
For the required output rounded to 6 decimals, the final result is stable with this choice.

## How to run

```bash
python3 main.py
```

Optionally compute `S(N)` for another `N`:

```bash
python3 main.py 10
```

The program prints the answer rounded to **6 digits after the decimal point**.
