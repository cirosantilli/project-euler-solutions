# Project Euler 899 Solution - DistribuNim I

<https://projecteuler.net/problem=899>:

* [899.py](899.py)

## Core game observation

Write a position as `(a, b)` with `a ≤ b`.  
Let `s = a` be the smaller pile. A legal move must remove exactly `a` stones in total, but cannot empty a pile.

When `a < b`, the move is equivalent to choosing an integer `t` with `1 ≤ t ≤ a` and moving to:

- `(a, b) → (t, b − t)`

(then reorder so the smaller pile is first).  
So the *larger pile strictly decreases*, ensuring the game always terminates.

## Characterising losing (P-)positions

Let `k = bit_length(a)` so `2^(k−1) ≤ a ≤ 2^k − 1`.  
Define `M = 2^k`.

A striking pattern (and the key to the problem) is:

> For `a ≤ b`, the position `(a, b)` is losing **iff**  
> `b ≡ 2^k − 1 (mod 2^k)` — i.e. the lowest `k` bits of `b` are all `1`.

Equivalently, `(a, b)` is losing iff `2^k | (b + 1)` where `k = bit_length(a)`.

### Why this is true (proof sketch)

Induct on the larger pile `b`.

- **No moves between losing positions:**  
  If `b ≡ −1 (mod 2^k)` and you split `b` as `t + (b − t)`, then whichever part becomes the new larger pile cannot keep “enough trailing ones” relative to the new smaller pile’s bit-length. So you can’t land on another position of the same form.

- **Any other position has a move to a losing position:**  
  If `b` does *not* have `k` trailing ones, you can choose a split `t` (with `t ≤ a`) that makes the new larger pile congruent to `−1 (mod 2^k)`. Because powers of two nest (`2^k` is a multiple of `2^{k'}` for smaller `k'`), the same split also satisfies the condition for the new smaller pile after reordering.

This gives a complete description of all P-positions.

## Counting L(n)

Let `L(n)` be the number of **ordered** pairs `(a, b)` with `1 ≤ a, b ≤ n` that are losing.

Because losing status is symmetric in the two piles:

- Count losing pairs with `a ≤ b` (call this `U`)
- Let `D` be the number of losing diagonal positions `(x, x)`  
  (these are exactly `x = 2^k − 1`)

Then:
- `L(n) = 2U − D`

### Computing U efficiently

Group `a` by its bit-length `k`.

- `a` has bit-length `k` precisely when `a ∈ [2^(k−1), 2^k−1]`.
- For such `a`, losing positions require `b ≡ 2^k−1 (mod 2^k)`.
  The count of such `b` in `[1..n]` is:

`C_k = #{ b ≤ n : b ≡ 2^k−1 (mod 2^k) }`

So:
- `U = Σ_k  A_k · C_k`  
  where `A_k` is how many `a ≤ n` have bit-length `k`.

This takes `O(log n)` time and uses only integer arithmetic, which is fast enough for `n = 7^17`.

## Implementation notes

- Uses `bit_length()` to iterate over relevant `k`.
- Pure Python, no external libraries.
- Includes asserts for the given check values from the statement.
