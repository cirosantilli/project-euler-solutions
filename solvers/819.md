# Project Euler 819 Solution - Iterative Sampling

<https://projecteuler.net/problem=819>:

* [819.py](819.py)

This solution computes

- **E(n):** the expected number of steps to go from `(1,2,…,n)` to “all entries equal”
- under the rule: each new tuple is produced by sampling each position independently
  from the multiset of values in the previous tuple.

## Key ideas

### 1) Reinterpretation as random function composition

Starting from `(1,2,…,n)`, think of each step as choosing a **random function**
`f : {1..n} → {1..n}` where each `f(i)` is uniform in `{1..n}` (choices are independent).

If the initial labels are distinct, then after `t` steps each position’s value is just the
index you reach by composing these random functions. The process ends exactly when
the composed function becomes **constant** (all positions map to the same original label).

So the only thing we need to track is:

- **m = size of the image** of the current composed function  
  (equivalently, the number of distinct “ancestral labels” still present).

The absorbing state is `m = 1`.

### 2) Transition probabilities via occupancy (balls-in-bins)

Given the current image has size `m`, applying the next random function maps those `m`
image elements independently and uniformly into `n` possible targets.

Therefore, the next image size is distributed as:

- **# occupied bins when throwing `m` balls into `n` bins uniformly.**

Let `P_m(k)` be the probability that exactly `k` bins are occupied.
We compute `P_m(k)` for increasing `m` using the standard incremental recurrence
for occupancy:

- when adding one ball, the occupied count stays `k` with probability `k/n`,
  or increases from `k-1` to `k` with probability `(n-(k-1))/n`.

This gives an **O(n²)** dynamic program for all `P_m(k)` values.

### 3) Expected hitting time using a monotone Markov chain

The image size can never increase: from `m` it transitions only to `k ≤ m`.
That makes the expected time computation *triangular*.

Let `T[m]` be the expected remaining steps to reach `m=1` starting from `m`.
Then for `m > 1`:

```
T[m] = 1 + Σ_{k<m} P_m(k)·T[k] + P_m(m)·T[m]
```

Rearrange:

```
T[m] = (1 + Σ_{k<m} P_m(k)·T[k]) / (1 - P_m(m))
```

Since the right-hand side only depends on `T[1..m-1]`, we compute `T` in increasing `m`
and finally output `T[n]`.

## Complexity

For `n = 1000`:

- Time: **O(n²)** (about 1 million simple float operations)
- Memory: **O(n)**

## Notes on correctness checks

The problem statement provides exact values for `E(3)` and `E(5)`.
`main.py` includes `assert` checks for these using exact rational arithmetic
(`fractions.Fraction`), and then computes and prints `E(1000)` rounded to 6 decimals.
