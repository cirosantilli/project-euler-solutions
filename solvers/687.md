# Project Euler 687 Solution - Shuffling Cards

<https://projecteuler.net/problem=687>:

* [687.py](687.py)

## Core idea

A shuffle of 52 distinct cards induces a **rank string** of length 52 with 13 symbols, each appearing 4 times.
Because suit permutations only reorder cards *within* a rank, every rank string corresponds to exactly \((4!)^{13}\)
distinct shuffles. Therefore, probabilities can be computed by counting rank strings.

A rank is **perfect** if none of its four occurrences are adjacent in the rank string.

## Inclusion–exclusion via “glued” adjacencies

For a single rank with 4 occurrences, look at the 3 gaps between consecutive occurrences (left-to-right).
If a chosen gap is “glued”, the two occurrences must be adjacent, which reduces the number of blocks for that rank by 1.

For one rank, the inclusion–exclusion weight for choosing `t` glued gaps is:

- sign: \((-1)^t\)
- choices: \(\binom{3}{t}\)
- resulting number of blocks for that rank: \(4-t\)

When several ranks are forced to be perfect, inclusion–exclusion is applied independently to each of those ranks.
After gluing, we count interleavings of rank-block sequences; the number of merged block-strings is a multinomial count:

\[
\frac{(52-B)!}{\prod_i b_i!},
\]
where \(B\) is the total number of glued gaps, and \(b_i\) is the resulting block count for rank \(i\).

## Polynomial compression

All ranks are symmetric. For one “constrained” rank, the contribution can be encoded as a small polynomial in \(x\),
where the exponent tracks how many gaps were glued:

\[
P(x)=\sum_{t=0}^3 (-1)^t \binom{3}{t}\frac{x^t}{(4-t)!}.
\]

To avoid fractions, the implementation scales by \(24=4!\) and uses

\[
Q(x)=24P(x)=1-12x+36x^2-24x^3.
\]

Then \(Q(x)^m\) compactly represents all inclusion–exclusion combinations for a fixed set of \(m\) ranks.

## Getting “exactly k perfect ranks” (binomial inversion)

Let \(n[m]\) be the number of rank strings where a *fixed* set of \(m\) ranks are perfect.
From symmetry, \(n[m]\) is a binomial transform of the counts for “exactly \(k\)” perfect ranks.
A standard **binomial inversion** recovers the distribution \(x[k]\) (for \(k=0..13\)).

## Exact arithmetic and rounding

All combinatorial quantities are computed with Python big integers.
Only at the end, the required probability is converted to `Decimal` and rounded to **10 digits after the decimal point**.

The code also checks the statement’s test value for the expected number of perfect ranks (as an exact reduced fraction).
