# Project Euler 866 Solution - Tidying Up B

<https://projecteuler.net/problem=866>:

* [866.py](866.py)

## Key observation: condition on the last piece placed
Placing the `N` pieces in a random order is the same as choosing a uniformly random permutation of positions `1..N`.

Look at the **last** position `j` to be filled. Before the final move, position `j` is still empty, so the already-placed pieces split into two independent parts:

- the left interval of length `j-1`
- the right interval of length `N-j`

Because the gap at `j` prevents any interaction between the two sides, the product accumulated on the left depends **only** on the relative order of left positions, and similarly for the right. These relative orders are independent and uniformly random.

Therefore, if `E(n)` is the expected product for an interval of length `n`, then conditioning on `j` being last gives:

- final step always contributes the `N`-th hexagonal number `H_N = N(2N-1)`
- earlier contributions factor as `E(j-1) * E(N-j)`

Averaging over all `j` (uniform among `1..N`) yields:

\[
E(N) \;=\; H_N \cdot \frac{1}{N}\sum_{j=1}^{N} E(j-1)E(N-j)
\]

## Cancellation removes division
Since `H_N = N(2N-1)`, the factor `N` cancels the `1/N` term:

\[
E(N) \;=\; (2N-1)\sum_{k=0}^{N-1} E(k)E(N-1-k)
\]

This is a **Catalan-style convolution** recurrence, but with a multiplier `(2N-1)`.

## Dynamic programming
Compute `E(0), E(1), ..., E(100)` iteratively:

- `E(0) = 1`
- for each `n`, compute the convolution sum in `O(n)` time
- total time `O(N^2)` and memory `O(N)`, easily fast for `N=100`

All arithmetic is done **modulo 987654319**, as required.

## Built-in validation
The implementation includes an `assert` for the example provided in the problem statement (`N=4`).
