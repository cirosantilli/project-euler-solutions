# Project Euler 378 Solution - Triangle Triples

<https://projecteuler.net/problem=378>:

* [378.py](378.py)

This repository contains a pure-Python solution to Project Euler problem 378 (no external libraries).

## Key ideas

### 1) Divisor-count of a triangular number via coprime splitting
The triangular number is:

- `T(n) = n(n+1)/2`

Since `gcd(n, n+1) = 1`, we can move the factor `2` to one side so the two factors stay coprime:

- If `n` is even: `T(n) = (n/2) * (n+1)`
  - `dT(n) = d(n/2) * d(n+1)`
- If `n` is odd: `T(n) = n * ((n+1)/2)`
  - `dT(n) = d(n) * d((n+1)/2)`

So the problem reduces to fast computation of the divisor function `d(x)` for `x ≤ n+1`.

### 2) Fast divisor table using a smallest-prime-factor sieve (odd-only)
To compute `d(x)` for all `x ≤ n+1`, the code:

- builds a sieve of smallest prime factors for **odd composites only** (even numbers have SPF = 2)
- computes divisor counts `tau[x] = d(x)` in a single forward pass using a recurrence that reuses:
  - `tau[m]` for `m = x / spf(x)`
  - the exponent of the smallest prime factor in `m`

This avoids per-number factorization and keeps memory reasonable.

### 3) Counting strict decreasing triples with Fenwick trees
Let `a_i = dT(i)`.
We need the count of triples `(i, j, k)` with `i < j < k` and `a_i > a_j > a_k`, i.e. strict decreasing subsequences of length 3.

While scanning `a_1, a_2, …, a_n`, maintain two Fenwick (Binary Indexed) Trees over the value axis:

- `BIT1[v]`: how many values `a_i` seen so far are equal to `v`
- `BIT2[v]`: how many decreasing pairs `(i, j)` have been seen so far where the **middle** value is `v`

For the next value `x = a_k`:

- `pairs_here = # { i < k : a_i > x }`
- `triples_here = # { (i, j) with i < j < k and a_i > a_j > x }`

Fenwick trees provide prefix sums in `O(log V)`, where `V` is the maximum `dT(n)` encountered.

### 4) Only the last 18 digits are required
The final `Tr(n)` can be huge, but Python integers handle it safely.
The code returns `Tr(n) % 10^18` at the end to obtain the last 18 digits.

## How to run

```bash
python3 main.py
```

Optional:

- `python3 main.py test` runs only the built-in asserts.
- `python3 main.py 1000` computes `Tr(1000)` (useful for sanity checks).

## Built-in checks

The problem statement provides:

- `dT(7) = 6`
- `Tr(20) = 14`
- `Tr(100) = 5772`
- `Tr(1000) = 11174776`

These are asserted in `main.py` before the large computation runs.
