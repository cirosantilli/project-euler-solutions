# Project Euler 772 Solution - Balanceable $k$-bounded Partitions

<https://projecteuler.net/problem=772>:

* [772.py](772.py)

## Key observation

Let `L = lcm(1, 2, …, k)`.

The problem asks for the smallest `N` such that **every** partition of `N` with parts `≤ k` can be split into two sub-multisets with equal sum.

The crucial result is:

- **`f(k) = 2L`**

So the task reduces to computing `2 * lcm(1..k) (mod 1_000_000_007)`.

## Why `2 * lcm(1..k)` appears

### Lower bound idea (constructing a non-balanceable partition)

Fix any `d ≤ k` and write `N = q*d + r` with `0 ≤ r < d`.

Consider the `k`-bounded partition:

- `d + d + … + d` (q times) and (if `r > 0`) one additional part `r`.

Every subset sum of this partition is either:

- a multiple of `d`, or
- `r` plus a multiple of `d`.

For this partition to be balanceable, `N/2` must match one of those two residue classes modulo `d`.
This forces `N/2` to be divisible by every `d ≤ k`, i.e.

- `N/2` is a multiple of `lcm(1..k)`  
- therefore `N` is a multiple of `2 * lcm(1..k)`

So no smaller `N` can work.

### Upper bound idea

Setting `N = 2 * lcm(1..k)` satisfies the divisibility condition above for *all* `d ≤ k`, and this turns out to be sufficient: no `k`-bounded partition can “avoid” having a subset sum equal to `N/2`.

(For this coding task, we use the resulting closed form and focus on fast computation.)

## Computing `lcm(1..k) mod M`

With `M = 1_000_000_007`:

\[
\mathrm{lcm}(1..k)=\prod_{p \le k} p^{\lfloor \log_p k \rfloor}
\]

So we need:

1. Generate all primes `p ≤ k`
2. For each prime, multiply by `p` and (for small primes) the extra powers `p^2, p^3, … ≤ k`
3. Take everything modulo `M`

## Prime generation technique

`k = 10^8` is too large for a naive prime test per number.

The implementation uses:

- an **odd-only sieve** to get primes up to `sqrt(k)`
- a **segmented sieve** over `[3..k]` to enumerate all odd primes up to `k` using about ~1MB per segment

This keeps memory usage low while staying fast enough in pure Python.

## Files

- `main.py` — computes and prints `f(10^8) mod 1_000_000_007` (also accepts `k` as a command-line argument)
- `README.md` — this summary
