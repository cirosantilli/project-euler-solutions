# Project Euler 289 Solution - Eulerian Cycles

<https://projecteuler.net/problem=289>:

* [289.py](289.py)

This repo contains a Python solution for **Project Euler Problem 289**.

We count Eulerian cycles on the circle arrangement \(E(m,n)\) that **never self‑cross** (touching at lattice points is allowed). The program outputs:

\[
L(6,10) \bmod 10^{10}.
\]

## Main techniques used

### 1) Reduce each lattice point to 4 “ports”

Each lattice point is incident to 8 arcs, but they come in 4 adjacent *pairs* (north/east/south/west): between two neighboring lattice points there are two distinct circle arcs.

A non‑crossing traversal through a vertex can be described by how it groups these 4 directions into blocks (directions in the same block are connected together around the vertex without crossings).

The number of non‑crossing partitions of 4 items is **Catalan(4) = 14**, so there are only 14 legal local connection patterns to consider.

### 2) Frontier (transfer-matrix) dynamic programming

We sweep the \((n+1)\times(m+1)\) lattice points in row-major order.

At any step, the boundary between processed/unprocessed vertices intersects the graph in a small set of “open” connection stubs. The DP state records which stubs are connected together so far.

This is the same idea as transfer-matrix methods used for planar connectivity problems (e.g. Hamiltonian cycles / loop models):

* `dp[state] = number of partial constructions producing this frontier connectivity`.
* At each lattice point, try all 14 local patterns and update the frontier connectivity accordingly.

### 3) Compact connectivity encoding with relabeling

Connectivity is stored as a sequence of **4-bit labels (nibbles)** packed into a Python integer.

* Equal labels mean “these frontier positions belong to the same connected component”.
* After each update, labels are canonicalized (“first-seen relabeling”) to keep the number of distinct states small.

This turns the frontier DP into a fast dictionary-based computation.

### 4) Enforcing a single Eulerian cycle

If a connected component disappears from the frontier before the very last vertex, that would form a **closed loop** disconnected from the rest — invalid because the final object must be *one* Eulerian cycle.

So the transition logic forbids “closing” a component early; it is only allowed at the final lattice point.

### 5) Memoization of local transitions

For a fixed frontier state, row position `y`, and whether we are on the outer boundary, the list of successor states is the same every time.

We cache these successor lists, which speeds up the run significantly.

## Running

```bash
python3 main.py
```

The program also includes assertions for the sample values from the statement:

* \(L(1,2)=2\)
* \(L(2,2)=37\)
* \(L(3,3)=104290\)
