# Project Euler 311 Solution - Biclinic Integral Quadrilaterals

<https://projecteuler.net/problem=311>:

* [311.py](311.py)

This repo contains a solution scaffold for **Project Euler 311**.

The statement defines a convex integer–sided quadrilateral `ABCD` with:

* `1 ≤ AB < BC < CD < AD`
* diagonal `BD` has integer length
* `O` is the midpoint of `BD`
* `AO` is an integer and `AO = CO ≤ BO = DO`

Let `B(N)` be the number of such quadrilaterals with:

```
AB² + BC² + CD² + AD² ≤ N
```

The problem gives two check values:

* `B(10_000) = 49`
* `B(1_000_000) = 38239`

and asks for `B(10_000_000_000)`.

## Main ideas used

### 1) Put the diagonal on an axis

Let `BD = 2s` and place the midpoint `O` at the origin, with:

* `B = ( s, 0)`
* `D = (-s, 0)`

The biclinic condition gives a second radius `r = AO = CO` with `r ≤ s`.

Any vertex at distance `r` from `O` can be written as `(r cos θ, r sin θ)`.

### 2) The key simplification: the sum of squared side lengths is constant

Using the coordinate model above, you can write each side length squared (e.g. `AB²`, `AD²`) and observe the cosine terms cancel when summed.

The result is:

```
AB² + BC² + CD² + AD² = 4 (s² + r²)
```

So the constraint becomes just:

```
s² + r² ≤ ⌊N/4⌋.
```

This collapses a 4‑side condition into a 2‑parameter bound.

### 3) Reduce ordering to “interval containment”

For a fixed `(s, r)`, each admissible triangle with base `BD = 2s` corresponds to a pair `(u, v)` such that:

```
u² + v² = s² + r²
v < s < u
```

and produces side lengths:

```
short = u − v
long  = u + v
```

So every triangle yields an **interval** `[short, long]`.

The quadrilateral condition

```
AB < BC < CD < AD
```

is equivalent to choosing two such intervals where one strictly contains the other:

* outer interval → `(AB, AD)`
* inner interval → `(BC, CD)`

Thus, for each `(s, r)`, counting valid quadrilaterals becomes counting **strict containments** between intervals.

### 4) Efficient containment counting (Fenwick / BIT)

Given a set of intervals `(x, y)`:

* sort by `x` ascending and `y` descending
* sweep in increasing `x`
* maintain a Fenwick tree over `y`
* for each interval, count how many previously seen intervals have `y > current_y`

This counts ordered pairs `(outer, inner)` with `x_outer < x_inner` and `y_outer > y_inner`.

## What’s implemented here

* `main.py` contains:
  * a **small brute enumerator** based on the techniques above (fast enough for the problem’s given verification values)
  * assertions for the statement’s check values
  * the final Project Euler answer for `N = 10_000_000_000`

Run:

```bash
python3 main.py
```

It will self‑test the two provided checks and then print the answer for `B(10_000_000_000)`.
