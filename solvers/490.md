# Project Euler 490 Solution - Jumping Frog

<https://projecteuler.net/problem=490>:

* [490.py](490.py)

We need

\[
S(L)=\sum_{n=1}^{L} f(n)^3 \pmod{10^9},\qquad L=10^{14}
\]

where `f(n)` counts Hamiltonian paths from `1` to `n` in the graph on `{1..n}` with an edge between stones whose indices differ by at most `3`.

## 1) Linear recurrence for `f(n)` (order 8)

The graph is an **interval graph of fixed bandwidth 3**, so the problem has **bounded pathwidth**. A transfer-matrix / frontier-DP over the last `3` vertices yields a fixed-size linear state, which implies `f(n)` satisfies a **constant-coefficient linear recurrence**.

In particular (and verified against the statement’s examples), for `n ≥ 9`:

\[
f(n)=2f(n-1)-f(n-2)+2f(n-3)+f(n-4)+f(n-5)-f(n-7)-f(n-8).
\]

This can be written with an 8-dimensional companion state

\[
X_n = [f(n), f(n-1), \dots, f(n-7)]^T,
\quad X_{n+1}=A\,X_n
\]

for a sparse `8×8` matrix `A`.

## 2) Turning “sum of cubes” into linear algebra

Let

\[
v_i = A^i X_8.
\]

Then the term we need is simply the cube of the **first component**:

\[
f(8+i)^3 = v_i[0]^3.
\]

Now define the 3rd-order outer product tensor:

\[
v_i^{\otimes 3} \in \mathbb{Z}^{8\times 8\times 8},\qquad
(v_i^{\otimes 3})_{a,b,c}=v_i[a]v_i[b]v_i[c].
\]

Summing these tensors over `i` gives:

\[
T_m = \sum_{i=0}^{m-1} v_i^{\otimes 3}.
\]

The desired cube-sum over that block is just the `(0,0,0)` entry:

\[
\sum_{i=0}^{m-1} v_i[0]^3 = (T_m)_{0,0,0}.
\]

## 3) Fast doubling with tensor powers

We also keep

\[
P_m = A^m.
\]

For doubling a block (`2m` from `m`):

- \(P_{2m}=P_m^2\)
- The second half vectors satisfy \(v_{m+i}=P_m v_i\), so

\[
T_{2m}=T_m + (P_m^{\otimes 3})\,T_m
\]

where applying \(P_m^{\otimes 3}\) to a tensor means multiplying along each of the three indices.

Because the dimension is only `8`, multiplying a tensor by a matrix along one mode costs `8^4=4096` multiply-adds; doing all three modes is about `3·8^4` operations. With `O(log L)` doublings and a binary decomposition to assemble length `L`, this is extremely fast.

## 4) What the code does

- Uses the order-8 recurrence to validate the examples (`f(6)`, `f(10)`, `f(40)`, `S(10)`, `S(20)`, `S(1000) mod 1e9`, `S(1e6) mod 1e9`).
- Builds the companion matrix `A (mod 1e9)`.
- Computes `S(10^14) mod 1e9` via tensor fast-doubling in `O(8^4 log L)`.

The final result printed by `main.py` is the required answer.
