# Project Euler 806 Solution - Nim on Towers of Hanoi

<https://projecteuler.net/problem=806>:

* [806.py](806.py)

## Problem in one line
Along the unique optimal 3-peg Tower of Hanoi solution for `n` disks (positions indexed `0..2^n-1`),
treat each position as a Nim game with heap sizes equal to the number of disks on each peg.
Let `f(n)` be the sum of indices that are **losing** Nim positions (`a xor b xor c = 0`).
Compute `f(100000) mod 1_000_000_007`.

---

## Main techniques

### 1) Symmetry collapses “sum of indices” into “count of indices”
The optimal Hanoi sequence is symmetric:
reversing the sequence corresponds to swapping the first and third pegs.
That transforms index `i` into `j = (2^n - 1 - i)` and transforms counts `(a,b,c)` into `(c,b,a)`.

Because XOR is commutative, `(a xor b xor c)` is unchanged, so losing positions pair up.
There is no fixed point because `2^n-1` is odd.

Hence if `k` is the number of losing positions:

\[
f(n) = \frac{k(2^n-1)}{2}
\]

So we only need **k**, not the positions themselves.

---

### 2) Enumerating all XOR-zero triples `(a,b,c)` with `a+b+c=n`
For a Nim-losing position:

\[
a \oplus b \oplus c = 0
\quad\text{and}\quad
a+b+c=n
\]

For even `n`, solutions can be constructed bitwise:
each set bit in `n` at position `p>=1` arises from a carry, meaning **exactly two** of `a,b,c`
must have bit `(p-1)` set.
There are 3 choices of which two numbers get it.

So the number of candidate triples is:

\[
3^{\mathrm{popcount}(n)}
\]

For `n=100000`, `popcount(n)=6`, so only `3^6=729` triples.

---

### 3) Counting how often each `(a,b,c)` occurs in the optimal Hanoi sequence
We need `occ(a,b,c)`: how many positions in the optimal Hanoi solution have exactly
`a,b,c` disks on the three pegs.

This is encoded by a multivariate generating function:

\[
F_y(x,y,z)=\frac{(1+y)(1+x+z-y)}{1-x^2-y^2-z^2-2xyz}
\]

The coefficient:

\[
[x^a y^b z^c]F_y
\]

equals `occ(a,b,c)`.

---

### 4) Fast coefficient extraction via multinomial expansions
Let:

\[
p = x^2+y^2+z^2+2xyz
\]

Then:

\[
\frac{1}{1-p}=\sum_{m\ge0} p^m
\]

To obtain `x^a y^b z^c`, choose `i` times the term `2xyz` (contributing `i` to each exponent and `2^i`),
and the rest as `x^2,y^2,z^2`.
That yields a multinomial factor:

\[
2^i \cdot \frac{m!}{i!\,A!\,B!\,C!}
\]

where:

- `A=(a-i)/2`, `B=(b-i)/2`, `C=(c-i)/2`
- `m = i + A + B + C = (a+b+c-i)/2`

Parity constraints force `a,b,c` to share parity, and `i` to match that parity.

The numerator `(1+y)(1+x+z-y)` expands to:

\[
1 + x + z + xy + yz - y^2
\]

so we compute the denominator coefficient 6 times with shifted exponents and combine.

---

### 5) Final assembly
1. Sum `occ(a,b,c)` over the 729 XOR-zero triples to get `k`.
2. Compute:

\[
f(n)=k\cdot\frac{2^n-1}{2}\pmod{10^9+7}
\]

---

## Complexity
- Enumerating XOR-zero triples: `O(3^{popcount(n)})` (729 for `n=100000`)
- Coefficient extraction per triple: roughly `O(min(a,b,c)/2)` using a recurrence
- Total runtime is practical in pure Python.

---

## Notes
The solution includes assertions for the statement’s provided test values:
- `f(4)=30`
- `f(10)=67518`

The final `f(100000)` is computed and printed, but not embedded in the code.
