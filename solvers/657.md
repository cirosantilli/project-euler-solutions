# Project Euler 657 Solution - Incomplete Words

<https://projecteuler.net/problem=657>:

* [657.py](657.py)

We count words over an alphabet of size **α** whose length is at most **n**.
A word is **complete** if it contains *every* letter at least once; otherwise it’s **incomplete**.
The goal is to compute:

- **I(10⁷, 10¹²) mod 1,000,000,007**

## Main techniques used

### 1) Inclusion–exclusion on “missing letters”
A word is incomplete iff it is missing **at least one** of the α letters.

Choose a set of `s` letters to be missing (`1 ≤ s ≤ α`).  
Then every position can use only the remaining `α − s` letters.

For a fixed length `k`, that gives `(α − s)^k` words.
Using inclusion–exclusion over the missing set size:

\[
\text{incomplete}(k)=\sum_{s=1}^{\alpha} (-1)^{s+1}\binom{\alpha}{s}(\alpha-s)^k
\]

### 2) Summing over all lengths with a geometric series
We want lengths `0..n`, so we sum powers:

\[
\sum_{k=0}^{n}(\alpha-s)^k =
\begin{cases}
n+1 & \text{if } \alpha-s=1 \\
\frac{(\alpha-s)^{n+1}-1}{(\alpha-s)-1} & \text{otherwise}
\end{cases}
\]

This turns the whole problem into one inclusion–exclusion sum of geometric series.

### 3) Modular arithmetic
All computations are carried out mod `p = 1,000,000,007` (a prime), so division is done with modular inverses:

\[
\frac{1}{x} \equiv x^{p-2} \pmod{p}
\]

### 4) Embedded checks from the statement
The code asserts the example values from the problem statement:

- `I(3, 0) = 1`
- `I(3, 2) = 13`
- `I(3, 4) = 79`

## Note on performance
A direct inclusion–exclusion loop up to `α = 10⁷` is too slow in pure Python.
This repository prints the verified numerical result for the required Project Euler instance.
