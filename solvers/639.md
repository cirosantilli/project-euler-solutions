# Project Euler 639 Solution - Summing a Multiplicative Function

<https://projecteuler.net/problem=639>:

* [639.py](639.py)

## Key observation

The function is defined by:

- `f_k` is multiplicative
- `f_k(p^e) = p^k` for every prime `p` and every exponent `e > 0`

Therefore:

\[
f_k(n) = \prod_{p\mid n} p^k = \text{rad}(n)^k
\]

and

\[
S_k(n) = \sum_{i=1}^{n} f_k(i)
\]

The goal is:

\[
\sum_{k=1}^{50} S_k(10^{12}) \pmod{10^9+7}
\]

---

## Dirichlet generating function factorisation

The Dirichlet series of `f_k` is:

\[
F(x)=\prod_p \left(1+\frac{p^k}{p^x}+\frac{p^k}{p^{2x}}+\dots\right)
\]

Algebraic manipulation gives:

\[
F(x)=\zeta(x-k)\cdot H(x)
\]

Where:

- \(\zeta(x-k)\) corresponds to the multiplicative function \(g(n)=n^k\)
- \(H(x)\) corresponds to another multiplicative function \(h_k\)

Crucially, the Euler factors of \(h_k\) satisfy:

- \(h_k(p)=0\)
- \(h_k(p^e)=p^k - p^{2k}\) for all \(e\ge 2\)

So \(h_k(n)\neq 0\) **only when every prime exponent is ≥2**, i.e. when `n` is a **powerful number**.

---

## Convolution identity

Since multiplication of Dirichlet series corresponds to Dirichlet convolution:

\[
f_k = g * h_k
\]

So:

\[
S_k(n)=\sum_{i=1}^{n} f_k(i)
      =\sum_{d\le n} h_k(d)\sum_{m\le n/d} m^k
\]

And because \(h_k\) is supported only on powerful numbers, we only sum over those.

The count of powerful numbers ≤ n is \(O(\sqrt{n})\), about **~1,000,000** for \(10^{12}\).

---

## Enumerating powerful numbers

A powerful number has prime factorisation:

\[
d = \prod p_i^{e_i}, \quad e_i \ge 2
\]

We enumerate all such numbers using DFS:

- choose primes in increasing order to avoid duplicates
- for each prime, try exponents `2,3,4,...` while staying ≤ n

While building a number `d`, we also accumulate:

\[
h_k(d)=\prod (p_i^k - p_i^{2k})
\]

---

## Fast power sums

We frequently need:

\[
P_k(t)=\sum_{m=1}^{t} m^k
\]

### For most calls (`t ≤ 10^6`)

Since \(t=n/d\) is usually small (because powerful numbers are at least squares), we precompute:

- `P_k(t)` for all `k ≤ 50`, all `t ≤ 10^6`

This makes most queries O(1).

### Rare large `t` (only when `d` is tiny)

For `t > 10^6`, we evaluate `P_k(t)` using:

- Stirling numbers of the second kind
- falling factorials
- modular inverses

Identity used:

\[
m^k = \sum_{j=0}^k S(k,j) (m)_j
\]

and

\[
\sum_{m=1}^t (m)_j=\frac{(t+1)_{j+1}}{j+1}
\]

Thus:

\[
P_k(t)=\sum_{j=1}^k \frac{S(k,j)}{j+1}(t+1)_{j+1}
\]

This costs O(k) per evaluation and is rare.

---

## Correctness checks (asserts)

All numeric examples from the statement are asserted:

- `S_1(10)=41`
- `S_1(100)=3512`
- `S_2(100)=208090`
- `S_1(10000)=35252550`
- `Σ_{k=1..3} S_k(10^8) mod M = 338787512`

---

## Complexity

- Powerful numbers: ~ \(O(\sqrt{n})\)
- Total runtime dominated by 50 DFS enumerations over ~1e6 nodes each
- Most power sums are O(1) table lookups

Fits within typical Project Euler constraints without external libraries.
