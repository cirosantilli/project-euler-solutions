# Project Euler 502 Solution - Counting Castles

<https://projecteuler.net/problem=502>:

* [502.py](502.py)

This solver uses **generating functions**, **parity filtering**, and **fast coefficient extraction** to count valid castles efficiently for enormous widths/heights.

---

## 1. Structural Decomposition → Generating Function

A castle is built from horizontal blocks (height 1, integer length) stacked on a width `w` base block.

Key observation:
- The configuration above any block depends only on what happens inside its horizontal span.
- Row blocks must be separated by ≥1 space.

This leads to a rational generating function recurrence for castles of height ≤h.

Let:

- `C_h(x, y)` = generating function where:
  - `x` marks width,
  - `y` marks number of blocks.

Base:
```
C_1 = y * x/(1-x)
```

Recurrence:
```
C_h = y * ( x + (1+x) C_{h-1} ) / ( 1 - x(1 + C_{h-1}) )
```

---

## 2. Even-Block Constraint via Parity Evaluation

We need castles with an **even number of blocks**.

Standard trick:
- Evaluate at `y = 1` → counts all castles
- Evaluate at `y = -1` → counts castles weighted by (-1)^(#blocks)

Then:

```
E = (C(1) + C(-1)) / 2
```

This isolates even block counts.

---

## 3. Exact Height Constraint

The problem requires **max height exactly h**, not ≤h.

So:

```
F(w,h) = E≤h(w) - E≤(h-1)(w)
```

---

## 4. Coefficient Extraction

We must extract `[x^w] C_h(x, y)` for different regimes:

### A) Moderate `w` (≤ 10000), moderate `h` (≤ 10000)
- Build numerator/denominator polynomials `P_h, Q_h`.
- Compute series coefficient of `P_h / Q_h`.

For large `w`, this uses **Newton series inversion** accelerated by fast polynomial multiplication.

### B) Huge width (`w = 10^12`), small height (`h ≤ 100`)
- Series becomes a linear recurrence of order `h`.
- Use **Kitamasa algorithm** (O(h² log w)) to compute coefficient `x^w`.

### C) Huge height (`h = 10^12`), small width (`w ≤ 100`)
- Work modulo `x^(w+1)`.
- Use **2×2 matrix exponentiation** on truncated polynomials.

---

## 5. Fast Polynomial Multiplication (NTT + CRT)

Since modulus `1e9+7` is not NTT-friendly, we perform NTT under three primes:

- 998244353
- 1004535809
- 469762049

Then reconstruct exact integer coefficients via CRT (product is > max coefficient bound),
finally reduce mod `1e9+7`.

---

## 6. Included Validations

The code asserts all statement examples:

- F(4,2) = 10  
- F(13,10) = 3729050610636  
- F(10,13) = 37959702514  
- F(100,100) mod 1e9+7 = 841913936  

---

## Final Output

The program prints:

```
(F(10^12,100) + F(10000,10000) + F(100,10^12)) mod 1e9+7
```

computed efficiently without brute force.
