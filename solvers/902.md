# Project Euler 902 Solution - Permutation Powers

<https://projecteuler.net/problem=902>:

* [902.py](902.py)

This repository contains a standalone Python solution for Project Euler problem **902 (Permutation Powers)**.

## Core ideas

### 1) Conjugation makes all powers easy
The permutation is defined as

- `pi = tau^{-1} ∘ sigma ∘ tau`

so every power is

- `pi^k = tau^{-1} ∘ sigma^k ∘ tau`.

That means we never need to “apply `pi` repeatedly”. We only need:

1. apply `tau` once,
2. rotate inside a `sigma`-cycle by `k` steps,
3. apply `tau^{-1}` once.

### 2) The structure of `sigma`
`sigma` is a disjoint product of cycles of lengths `1, 2, ..., m`.
(Each cycle is a block between consecutive triangular numbers.)
Because `pi` is a conjugate of `sigma`, `pi` has **the same cycle lengths**.

Let `L = lcm(1..m)`. Then `pi^k` depends only on `k (mod L)`, and since `L | m!`:

- `P(m) = (m!/L) * sum_{k=0..L-1} rank(pi^k)`.

So we only have to sum ranks over **one full period**.

### 3) Lexicographic rank via inversion counts (Lehmer code)
For a permutation `p` of `{1..n}`:

- `rank(p) = 1 + Σ_{i=1..n} I_i(p) * (n-i)!`

where

- `I_i(p) = #{ j > i : p(j) < p(i) }`.

This turns “rank” into a weighted sum of **pairwise comparisons**.

### 4) Summing over a full period without iterating `k`
Fix two positions `i < j`. Over the powers `k`, we need the count of

- `pi^k(j) < pi^k(i)`.

If `i` is in a cycle of length `a` and `j` in a cycle of length `b`, then the pair
`(pi^k(i), pi^k(j))` is periodic with period `lcm(a, b) ≤ 9900` (since `a, b ≤ 100`).

A direct scan of `0..lcm(a,b)-1` for every pair `(i, j)` would still be too slow.
Instead, the code uses a **gcd / residue-class** viewpoint:

- Let `g = gcd(a, b)`.
- As `k` runs, the indices walked inside the two cycles follow a diagonal on a
  torus of size `a × b`.
- That diagonal visits exactly the `a*b/g` pairs `(x, y)` with `x - y ≡ d (mod g)`
  for a certain residue `d` determined by the two starting offsets.

So for each length-pair `(a, b)` and each residue `d (mod g)`, we can count how
many of those visited pairs satisfy `value_b < value_a` using sorting + binary
search inside the `g` residue sublists.

This precomputation makes each `(i, j)` contribution an **O(1)** table lookup.

## Complexity
For `m = 100`:

- `n = m(m+1)/2 = 5050`
- Pair loop is `O(n^2)` (~12.7 million pairs).
- Precomputation over cycle-length pairs is small (`m^2` with cheap inner work).

Everything runs comfortably in pure Python.

## Files
- `main.py` — computes the required value and includes asserts for the sample
  values given in the problem statement.
