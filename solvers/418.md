# Project Euler 418 Solution - Factorisation Triples

<https://projecteuler.net/problem=418>:

* [418.py](418.py)

We want the unique triple `(a, b, c)` with:

- `1 ≤ a ≤ b ≤ c`
- `a · b · c = n`

that **minimises the ratio `c / a`** (equivalently, makes the triple as “balanced” as possible).  
Then `f(n) = a + b + c`. The task is to compute `f(43!)`.

## Main techniques used

### 1) Prime-factor representation of factorials

For a factorial `k!`, we can get its prime factorisation without ever factoring a huge integer:

- List primes `p ≤ k`.
- Compute the exponent of each prime using **Legendre’s formula**:

`v_p(k!) = ⌊k/p⌋ + ⌊k/p²⌋ + ⌊k/p³⌋ + …`

This gives the full factorisation of `k!`.

### 2) Meet-in-the-middle divisor generation

`43!` has hundreds of millions of divisors, so we cannot enumerate them all.

Instead:

- Split the primes into two groups:
  - Group 1: small primes with large exponents (chosen so the number of divisors stays ≤ ~1,000,000)
  - Group 2: the remaining primes (much smaller divisor count)
- Generate **all divisors** of Group 1 and sort them.
- Generate **all divisors** of Group 2 (a small list).
- Any divisor of `43!` is uniquely `d = d1 · d2` with `d1` from Group 1 and `d2` from Group 2.

This structure lets us quickly list only the divisors we care about (see next point).

### 3) Searching only near the cube root

To minimise `c/a`, the best triple must have `a`, `b`, `c` all close to `n^(1/3)`.

So we search within a narrow multiplicative window around the cube root:

- `a` is searched in `[ n^(1/3)/(1+δ), n^(1/3) ]`
- `c` is searched in `[ n^(1/3), n^(1/3)·(1+δ) ]`

We start with a tiny `δ` and double it until at least one valid triple is found.
For `43!`, a valid triple appears at an extremely small `δ`, keeping the candidate sets tiny.

To collect divisors in a range `[L, H]`, for each `d2` we find all `d1` satisfying:

`L/d2 ≤ d1 ≤ H/d2`

Because the Group-1 divisors are sorted, we can do this with binary search.

### 4) Exact ratio comparisons without floating error

To compare ratios `c/a`, we avoid floating point arithmetic:

`c1/a1 < c2/a2`  **iff**  `c1·a2 < c2·a1`

So the code compares products of integers only.

## Testing

The implementation includes assertions for the values given in the problem statement:

- `f(165) = 19`
- `f(100100) = 142`
- `f(20!) = 4034872`

Then it prints the answer for `f(43!)`.
