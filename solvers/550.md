# Project Euler 550 Solution - Divisor Game

<https://projecteuler.net/problem=550>:

* [550.py](550.py)

## 1) Sprague–Grundy reduction

The game is impartial and played under normal play.
For each pile size `m`, define its *nimber* (Sprague–Grundy value) `g(m)`.

A position with `k` piles is losing **iff** the XOR of all pile nimbers is zero:

\[
\text{losing} \iff g(a_1)\oplus g(a_2)\oplus\cdots\oplus g(a_k)=0
\]

So:

\[
f(n,k)= (n-1)^k - \#\{(a_i)\in[2..n]^k:\ \bigoplus g(a_i)=0\}
\]

All arithmetic is done modulo `987654321`.

## 2) Nimber depends only on Ω(n)

Let \(\Omega(m)\) be the number of prime factors of `m` **with multiplicity**.

A move replaces one pile of size `m` by two piles whose sizes are **proper divisors** of `m`.
Every proper divisor `d` satisfies \(\Omega(d)\le \Omega(m)-1\).

Crucially, for a number with \(\Omega(m)=t\), for every `i` with \(1\le i < t\) there exists a proper divisor `d` with \(\Omega(d)=i\)
(choose exponents in the factorisation to sum to `i`).

Using induction over `t`, this implies:

- all numbers with the same `t = Ω(m)` have the same nimber,
- so we can define a sequence `h[t] = g(m)` for any `m` with `Ω(m)=t`,
- and `h[t]` depends only on earlier `h[1..t-1]`:

\[
h(t)=\mathrm{mex}\left(\{\,h(i)\oplus h(j)\ :\ 1\le i,j < t\,\}\right)
\]

For `n = 10^7`, the maximum \(\Omega\) is only 23, so this sequence is tiny.

## 3) Counting by Ω via a linear sieve

We need how many integers `m` in `[2..n]` have each value of `Ω(m)`.
This is computed in \(O(n)\) time using a **linear sieve** that tracks:

- `spf[m]` = smallest prime factor of `m`
- `Ω(m)` in a byte array

This gives counts `cnt[t] = #{ m in [2..n] : Ω(m)=t }`.

## 4) XOR counting with Walsh–Hadamard transform

Let `C[x]` be how many pile sizes in `[2..n]` have nimber `x`.
We need the number of length-`k` sequences whose XOR is 0.

XOR-convolution becomes pointwise multiplication in the Walsh–Hadamard domain:

1. Apply FWHT: `F = H(C)`
2. Raise pointwise: `F[u] = F[u]^k`
3. Invert: `C_k = H^{-1}(F)` and take `C_k[0]`

With the standard (unnormalised) FWHT:

\[
C_k[0] = \frac{1}{N}\sum_u F[u]^k
\]

where `N` is the transform size (a power of 2).  
`987654321` is odd, so `N` is invertible modulo `987654321`.

---

That’s all the moving parts:
**(game theory)** → **Ω-compression** → **sieve counting** → **FWHT for XOR totals**.
