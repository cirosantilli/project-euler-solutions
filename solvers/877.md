# Project Euler 877 Solution - XOR-Equation A

<https://projecteuler.net/problem=877>:

* [877.py](877.py)

This solution treats the problem as arithmetic over **GF(2)** (binary polynomials):

- `x ⊕ y` is addition of polynomials (bitwise XOR).
- `x ⊗ y` is **carryless multiplication**: multiply in base 2 but add partial products with XOR (i.e., polynomial multiplication over GF(2)).

## Key observations

### 1) Rewrite the equation in polynomial form

Let `z` denote the polynomial variable that corresponds to the bit position (so multiplying by `2` is multiplying by `z`, i.e. a left shift).

The equation

\[
(a ⊗ a) ⊕ (2 ⊗ a ⊗ b) ⊕ (b ⊗ b) = 5
\]

becomes, in GF(2)[z],

\[
a^2 + z a b + b^2 = z^2 + 1.
\]

Also note `z^2 + 1 = (z+1)^2` in characteristic 2.

### 2) View the left side as a norm

Introduce an element `r` with the relation

\[
r^2 + z r + 1 = 0 \quad\Longleftrightarrow\quad r(r+z)=1.
\]

In the quadratic extension ring GF(2)[z][r]/(r^2+zr+1), the *norm* of `a + b r` down to GF(2)[z] is

\[
N(a + b r) = a^2 + z a b + b^2.
\]

So we are solving

\[
N(a + b r) = N(z+1).
\]

which implies `(a + b r) / (z+1)` must have norm `1`.

### 3) Norm-1 units are generated by `r`

Because `r(r+z)=1`, `r` is a unit and `r^{-1}=r+z`. The norm-1 units form the set `{ r^k : k ∈ Z }`.

Starting from the smallest nonnegative solution `(a,b) = (0, 3)` (which corresponds to `(z+1)·r`), multiplying by `r` preserves the norm and generates the next solution.

Multiplying a pair `(a,b)` by `r` translates to a very simple recurrence on coefficients:

\[
(a + b r)\,r = b + (a + z b)r.
\]

In integers that means:

- `a' = b`
- `b' = a ⊕ (b << 1)`

so if we define a sequence

- `s0 = 0`, `s1 = 3`
- `s_{n+2} = (s_{n+1} << 1) XOR s_n`

then **all** solutions with `0 ≤ a ≤ b` are exactly the consecutive pairs

\[
(s_0,s_1), (s_1,s_2), (s_2,s_3), \ldots
\]

and the corresponding `b` values are `s1, s2, s3, ...`.

### 4) Computing `X(N)`

Since the `s_k` grow by one new highest bit at each step, only `O(log N)` terms are ≤ `N` (about 60 terms for `10^18`).

So:

1. Generate `s_k` until it exceeds `N`.
2. XOR-accumulate all `s_k` (for `k ≥ 1`) that are ≤ `N`.

The implementation is just integer shifts and XORs, no heavy search.
