# Project Euler 925 Solution - Larger Digit Permutation III

<https://projecteuler.net/problem=925>:

* [925.py](925.py)

This program computes

\[
T(N)=\sum_{n=1}^{N} B(n^2)
\]

for \(N=10^{16}\), and prints the result modulo \(10^9+7\).

`B(x)` is defined as the smallest number larger than `x` obtainable by rearranging its decimal digits, or `0` if no such larger rearrangement exists (i.e., the digits are already in non-increasing order).

## Main ideas

### 1) Split the sum into an easy part and a hard part

Write:

\[
B(n^2) = n^2 + (B(n^2)-n^2)
\]

So:

- \(\sum n^2\) is computed with the closed form \(N(N+1)(2N+1)/6\) modulo \(10^9+7\).
- The remaining work is \(\sum (B(n^2)-n^2)\), which is handled by a digit-based search.

### 2) Next-permutation viewpoint for `B(x)`

`B(x)` is exactly the “next lexicographic permutation” of the digit sequence of `x` (most significant to least significant). If the digit sequence is fully non-increasing, there is no next permutation and `B(x)=0`.

### 3) Suffix pruning over `n` (least significant digits first)

We build `n` from the least significant digit upwards. Suppose we have fixed the last `c` digits, forming a suffix value `v`.

If the last `t` digits of `v^2` (for a suitable `t`) are **not** non-increasing (viewed from most significant to least significant), then the “next permutation pivot” for the full number \(n^2\) must lie inside those last `t` digits. That means:

- `B(n^2) - n^2` depends only on that suffix block
- and is identical for all numbers sharing the same last `c` digits

So instead of exploring all completions of the remaining higher digits, we can add one aggregated contribution and stop exploring that branch.

### 4) Trailing-zero acceleration

If the current suffix `v` ends with `k` zeros, then `v` is divisible by \(10^k\), and every extension shares extra fixed digits in the square:

\[
(v + m\cdot 10^c)^2 \equiv v^2 \pmod{10^{c+k}}
\]

So the algorithm checks `t = c + k` digits of `v^2` at once. This avoids wasting time exploring branches where new chosen digits would not change the observed square suffix.

### 5) Process by fixed length to avoid leading-zero corner cases

The program sums over all decimal lengths `L = 1..16` separately (numbers with exactly `L` digits). For any fixed `L`, every `L`-digit square has at least `2L-1` digits, and the suffix checks never look beyond that, so the digits examined are always genuine digits of \(n^2\) rather than “padding zeros”.

## Complexity notes

The search tree is pruned aggressively because random-looking digit suffixes almost never remain non-increasing as the suffix grows. In practice only a tiny fraction of suffixes survive to deeper levels.

## Files

- `main.py`: implementation and the required asserts for given examples.
- `README.md`: this explanation.
