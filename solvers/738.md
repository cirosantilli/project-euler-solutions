# Project Euler 738 Solution - Counting Ordered Factorisations

<https://projecteuler.net/problem=738>:

* [738.py](738.py)

This repository contains a pure-Python solution for **Project Euler 738** (no third‑party libraries).

## Key ideas

### 1) Convert the double sum into counting tuples

`d(n, k)` counts nondecreasing factor tuples whose product is exactly `n`.

Summing over `1 ≤ n ≤ N` converts this into counting **all** valid tuples whose product is `≤ N`:

- count tuples `(x1 ≤ x2 ≤ … ≤ xk)` with `x1⋯xk ≤ N`.

### 2) Separate the `1`s

Because tuples are nondecreasing, any `1`s must appear **only at the beginning**.

So every tuple is:

- some number of leading `1`s (possibly zero), followed by a **base tuple** of factors `≥ 2`.

For a base tuple of length `ℓ`, and a maximum length `K`, there are `K − ℓ + 1` ways to pad with leading `1`s
(to reach any total length from `ℓ` up to `K`).

In the problem, `K = N`, and `K` is far larger than the maximum possible base length (which is `⌊log2 N⌋`),
so no truncation by length is needed.

This reduces the task to computing, over all base tuples with product `≤ N`:

- `C` = total number of base tuples
- `L` = total sum of their lengths

Then:

- contribution from `n = 1` is `K` (all‑ones tuples)
- contribution from base tuples is `(K+1)·C − L`

All arithmetic is done modulo `1,000,000,007`.

### 3) Recursive counting with monotone factors

Let `F(m, a)` count base tuples (factors `≥ a`, nondecreasing) with product `≤ m`,
and let `G(m, a)` be the sum of their lengths.

A tuple is either:

- length 1: choose one factor in `[a … m]`
- length ≥ 2: pick the first factor `f` in `[a … ⌊√m⌋]`, then recurse into `(m//f, f)`

This naturally enforces nondecreasing order by passing the chosen factor as the next minimum.

### 4) Cube‑root split + fast range summation

For `f > ⌊∛m⌋`, we have `m//f < f²`, meaning the subproblem `(m//f, f)` can only produce length‑1 tuples.
So we:

- recurse only for `f ≤ ⌊∛m⌋`
- handle the remaining `f` in bulk using a summation formula

Bulk summation needs terms like `∑ floor(m/f)` over a range; we compute this using the standard
“distinct quotients” technique (grouping equal `m//f` values), which runs in about `O(√m)` steps per call.

### 5) Memoization

`F(m, a)` and `G(m, a)` are memoized by `(m, a)`, which is essential for performance.

## Files

- `main.py` — computes and prints `D(10^10, 10^10) mod 1_000_000_007` and includes asserts for the sample values.
