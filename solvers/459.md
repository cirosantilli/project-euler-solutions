# Project Euler 459 Solution - Flipping Game

<https://projecteuler.net/problem=459>:

* [459.py](459.py)

This repository contains a **pure-Python** solution (no external libraries) for Project Euler 459.

## Key techniques

### 1) Sprague–Grundy theory
The game is an impartial normal-play game (no legal moves = lose). Therefore every position has a **nimber** (Sprague–Grundy value), and:

- A position is losing iff its nimber is `0`.
- A move is winning iff it moves to a position with nimber `0`.

### 2) Tartan theorem → reduce the 2D game to two 1D games
The rectangle-flipping rules make this a *tartan game*. Pearson’s “tartan theorem” implies that the nimber of a board position factors as a **nim-product** of two 1D coin-turning games:

- one 1D game where legal strip lengths are **perfect squares** (width),
- one 1D game where legal strip lengths are **triangular numbers** (height).

This turns a 2D analysis into two 1D analyses plus nimber arithmetic.

### 3) Prefix-xor recurrence for the 1D coin-turning games
Let `C[k]` be the XOR-prefix of 1D nimbers (so the nimber of a contiguous strip `[a..b]` is `C[b] XOR C[a-1]`).

Pearson shows an efficient recurrence:

- `C[k+1] = mex({ C[k] XOR C[k - L] : L in allowed_lengths })`

From `C`, the nimber of any allowed strip ending at `x` is simply:

- `strip = C[x] XOR C[x - L]`

### 4) Counting via frequency tables
A first move flips a rectangle, whose nimber is:

- `rect = strip_width ⊗ strip_height`

The first player has a winning move iff the rectangle’s nimber equals the nimber of the full board.

So we build two frequency tables:

- `freq_sq[v]` = how many square-length strips have nimber `v`,
- `freq_tr[v]` = how many triangular-length strips have nimber `v`.

Then the number of winning first moves is the number of pairs `(a,b)` with:

- `a ⊗ b = board_nimber`

### 5) Fast nimber multiplication and inversion
Nimber multiplication is done with a recursive **Fermat 2-power splitting** algorithm (a Karatsuba-style recurrence), based on facts for `F_n = 2^(2^n)`.

To “divide” by a nimber we use inverses. For this problem, all strip nimbers are `< 2^16`, so inverses can be computed in the finite field of size `2^16` by exponentiation:

- `a^{-1} = a^(2^16 - 2) = a^65534`

This avoids slow brute-force inversion.

## Files

- `main.py` — computes `W(10^6)` and includes asserts for the sample values:
  - `W(1)=1`, `W(2)=0`, `W(5)=8`, `W(100)=31395`.
