# Project Euler 426 Solution - Box-Ball System

<https://projecteuler.net/problem=426>:

* [426.py](426.py)

This solution avoids simulating turns of the Box–Ball System. Instead, it computes the **soliton sizes** directly from the initial configuration, because those sizes are conserved and (once separated) become the problem’s “final state”.

## Key technique 1: Takahashi–Satsuma soliton identification

For a (capacity-1) BBS configuration written as a doubly-infinite 0/1 word (with infinite zeros at both ends for a finite configuration), Takahashi & Satsuma described a greedy way to extract solitons:

1. Look at runs of equal symbols (…0001111000…).
2. Find the **leftmost** run whose length is **at least** the length of the run immediately before it.
3. Let `k` be the length of the preceding run. Then a `k`-soliton is formed by:
   - the whole preceding run (length `k`), and
   - the first `k` symbols of the selected run.
4. Remove those `2k` symbols, then merge adjacent runs of the same symbol.
5. Repeat until no `1`s remain.

The multiset of extracted `k` values is exactly the multiset of soliton sizes. The “final state” in the Project Euler problem is these sizes in increasing order, and the required output is the sum of their squares.

(See the algorithm statement in Ferrari et al., which reproduces the Takahashi–Satsuma identification procedure.)

## Key technique 2: Run-length encoding + a stack for O(n)

The input is already in run-length form: `(t0, t1, …)` alternates occupied/empty run lengths. Expanding into individual boxes would be far too large.

To make the greedy TS procedure fast, the code maintains a stack of runs:

- Each stack entry is `(symbol, length)`.
- When a new run is appended, we check the TS condition only at the **right edge**:
  - while `last.length >= prev.length`, we have found the next TS soliton (it must be the leftmost “violation” because the processed prefix is kept reduced).
  - extract `k = prev.length`, add `k²` to the answer, remove the previous run and subtract `k` from the last run, then merge if symbols match.
- This behaves like a local “reduction” and runs in amortized linear time.

Because the configuration is finite but conceptually has infinite trailing zeros, we append a trailing zero-run of length at least the total number of balls (plus a small cushion). That’s enough for all remaining solitons to be extracted.

## Practical notes

- Complexity: **O(number of runs)**, i.e. O(10,000,001) operations.
- Memory: O(stack size), typically much smaller than the number of runs.
- The provided `main.py` includes asserts for the two examples from the problem statement.

## Files

- `main.py`: computes and prints the Euler 426 answer.
- `README.md`: this summary.
