# Project Euler 75 Solution - Singular Integer Right Triangles

<https://projecteuler.net/problem=75>:

* [75.py](75.py)

We need the number of wire lengths `L ≤ 1,500,000` that can form **exactly one** integer-sided right triangle `(a,b,c)` with `a² + b² = c²` and `a + b + c = L`.

## Key idea

All integer right triangles come from **Pythagorean triples**. Every *primitive* triple can be generated by Euclid’s formula:

- `a = m² − n²`
- `b = 2mn`
- `c = m² + n²`

with constraints:
- `m > n`
- `gcd(m, n) = 1`
- `m` and `n` have opposite parity

The primitive perimeter is:
- `p0 = a + b + c = 2m(m + n)`

Every non-primitive triple is a multiple of a primitive one, so all perimeters are `k * p0`.

## Algorithm

1. Create an array `counts[L]` for `L = 0..limit`.
2. Enumerate all valid `(m,n)` that generate primitive triples with `p0 ≤ limit`.
3. For each `p0`, increment `counts[p]` for every multiple `p = p0, 2p0, 3p0, ... ≤ limit`.
4. Answer is the number of `L` where `counts[L] == 1`.

## Complexity

This runs quickly because:
- `m` only needs to go up to about `sqrt(limit/2)`.
- The multiples marking is similar to a sieve: total work is manageable for `1.5e6`.

## Validation

Included asserts:
- `solve(50) == 6` (matches the small perimeters shown in the prompt)
