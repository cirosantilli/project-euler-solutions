# Project Euler 824 Solution - Chess Sliders

<https://projecteuler.net/problem=824>:

* [824.py](824.py)

This repository contains a standalone `main.py` (no external libraries) that computes:

- `L(N, K)` = number of ways to place `K` identical **chess sliders** on an `N × N` **cylindrical** board
- sliders **attack** if they are in **adjacent** squares left/right in the same row
- for `N = 10^9`, `K = 10^15`, reduced modulo `(10^7 + 19)^2`.

The problem statement examples are verified with exact small computations.

---

## 1) Reduce the 2D problem to a 1D polynomial

Each row is a cycle of length `N` (wrap-around). In a single row, a valid set of sliders is an **independent set** of the cycle graph `C_N`.

Let `P_N(x)` be the independence polynomial of `C_N`:
- coefficient of `x^r` = ways to place `r` sliders in one row

Rows are independent, so:

\[
L(N,K) = [x^K]\,(P_N(x))^N.
\]

---

## 2) Transfer-matrix / algebraic form for `P_N(x)`

Let `α, β` be the roots of `t^2 - t - x = 0`. Then:

\[
P_N(x) = α^N + β^N,
\qquad αβ=-x \Rightarrow β=-x/α.
\]

This converts the full-board polynomial into an expression involving powers of `x` and `α`.

---

## 3) Binomial expansion gives a short (1,000,001-term) sum

\[
(P_N(x))^N = \sum_{t=0}^{N} \binom{N}{t} (-1)^{Nt} x^{Nt} α^{N(N-2t)}.
\]

To extract `[x^K]`, only terms with `Nt ≤ K` matter, so:

- `t = 0 .. ⌊K/N⌋ = 1,000,000`.

For this instance `N=10^9` is even, so `(-1)^{Nt}=1`.

---

## 4) Lagrange inversion for `[x^d] α^M`

`α` is the series root with `α(0)=1` of:

\[
α^2 - α - x = 0.
\]

Lagrange inversion yields:

- `[x^0] α^M = 1`
- for `d ≥ 1`:

\[
[x^d]\,α^M = \frac{M}{d}\binom{M-d-1}{d-1}.
\]

So each term requires exactly one large binomial coefficient.

---

## 5) Computing binomials modulo `p^2`

The modulus is `p^2`, with `p = 10^7+19` prime.

We compute `C(n,k) mod p^2` by:

1. Using Legendre’s formula to get the exponent of `p` in factorials
2. Removing all `p` factors from `n!`, `k!`, `(n-k)!` and working with the unit part
3. Using Wolstenholme’s theorem (`p ≥ 5`) to simplify block products so only
   harmonic numbers modulo `p` are needed.

---

## 6) Fast inverses modulo `p^2` (Hensel lifting)

We precompute inverses modulo `p`, then lift to modulo `p^2` via:

\[
x_{2} = x\,(2 - a x) \pmod{p^2}.
\]

This makes modular division in the million-term sum efficient.

---

## 7) Complexity

- Precompute arrays of size `p`:
  - factorials mod `p^2`
  - inverses mod `p`
  - harmonic numbers mod `p`
- Run `1,000,001` iterations to accumulate the sum.

This makes the huge values `N=10^9`, `K=10^15` tractable.

---
