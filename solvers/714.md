# Project Euler 714 Solution - Duodigits

<https://projecteuler.net/problem=714>:

* [714.py](714.py)

This solution computes

- `d(n)`: the smallest positive multiple of `n` whose decimal digits use **at most two distinct digits**
- `D(k) = Σ d(n)` for `n = 1..k`

and prints `D(50000)` in scientific notation rounded to **13 significant digits** (12 after the decimal point).

## Main techniques

### 1) Exhaustive duodigit generation (bounded)
All duodigits up to a fixed maximum length are generated:

- repdigits: `1`, `22`, `333`, …
- two-digit duodigits: for each digit pair `{a,b}`, enumerate all non-trivial bit patterns choosing `a` vs `b`

Because any number with fewer digits is smaller than any number with more digits, searching in increasing length (and within each length, increasing numeric order) guarantees we find the true minimum.

In this implementation we generate all duodigits up to **15 digits** and scan that sorted list to find `d(n)` for all `n` not divisible by `10`.

### 2) Special handling for `n` divisible by `10`
If `n` is divisible by `10`, then any multiple must end in digit `0`, so digit `0` **must** appear in the duodigit.

Any number using only digits `{0, d}` can be written as

- `d × X`

where `X` is a number using only digits `{0,1}` (no carries occur when multiplying by a single digit).

So for `n = 10m`:

1. For each `d ∈ {1..9}`, reduce to `X ≡ 0 (mod m / gcd(m,d))`
2. Find the smallest `{0,1}`-digit multiple `X` using BFS on remainders
3. Map `1 → d` to get a `{0,d}`-digit multiple of `m`, then append `0` to multiply by `10`

This avoids needing very long general duodigit searches for multiples of `10`.

### 3) BFS over remainders for smallest `{0,1}` multiple
For each modulus `k ≤ 5000`, the smallest number made of digits `{0,1}` (leading digit `1`) divisible by `k` is found with a classic BFS:

- nodes: remainders `0..k-1`
- edges: append digit `0` or `1`

BFS guarantees the shortest length, and digit order yields the lexicographically smallest among those, which corresponds to the smallest integer.

### 4) Exact rounding without floats
The final sum can exceed typical floating-point precision. The output formatting routine performs **string-based rounding** to exactly 13 significant digits and prints scientific notation like:

`2.957098800000e7`

(Example format from the problem statement.)

## Included checks
The program asserts all example/check values provided in the problem statement:

- `d(12) = 12`
- `d(102) = 1122`
- `d(103) = 515`
- `d(290) = 11011010`
- `d(317) = 211122`
- `D(110) = 11047`
- `D(150) = 53312`
- `D(500) = 29570988`
