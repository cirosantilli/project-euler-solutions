# Project Euler 813 Solution - XOR-Powers

<https://projecteuler.net/problem=813>:

* [813.py](813.py)

This solution treats the **XOR-product** `⊗` as *carryless multiplication*.

## Key ideas

### 1) Carryless multiplication = polynomial multiplication over GF(2)
Write an integer in binary as a polynomial with coefficients in `{0,1}`:

- `1011₂` ↔ `1 + x + x³` (bit `i` becomes the coefficient of `x^i`)

Then the XOR-product `a ⊗ b` is exactly the product of the two polynomials
in the ring **GF(2)[x]** (addition is XOR, no carries), converted back to bits.

So:

- `11` (decimal) = `1011₂` ↔ `f(x) = 1 + x + x³`
- `P(n) = 11^{⊗ n}` corresponds to `f(x)^n` in GF(2)[x]

The requested value modulo `1_000_000_007` is the integer whose set bits are
the degrees where `f(x)^n` has coefficient 1.

### 2) Parity of multinomial coefficients via Lucas (base 2)
Expand:

`(1 + x + x³)^n = Σ multinomial(n; i,j,k) · x^(j + 3k)`

Over GF(2), coefficients are reduced mod 2, so we only care whether the
multinomial coefficient is **odd**.

For prime `p=2`, Lucas’ theorem generalizes to multinomials:
`multinomial(n; i,j,k)` is odd **iff** `i + j + k = n` happens with **no carries**
in binary. Equivalently, the 1-bits of `n` can be independently assigned to exactly
one of `(i, j, k)`.

That means every 1-bit value `v = 2^b` of `n` contributes one of:
- assign to `i` (constant term): degree `+0`
- assign to `j` (the `x` term):  degree `+v`
- assign to `k` (the `x³` term): degree `+3v`

### 3) Build the set of degrees using XOR cancellation
Each assignment produces a monomial `x^d`. Coefficients in GF(2) are parity,
so if the same degree `d` is produced an even number of times it cancels out.

Implementation trick:
- Maintain a `set` of degrees with coefficient 1.
- When a degree appears again, toggle it (symmetric difference).

The exponent in this problem has very small `popcount`, so there are only
`3^(popcount(n))` assignments to consider.

### 4) Convert polynomial back to the required modular integer
If the resulting polynomial has 1-coefficients at degrees `d ∈ D`, the integer is:

`Σ 2^d`

Compute modulo `1_000_000_007` using `pow(2, d, MOD)` for each `d`.

## Complexity
Let `m = popcount(n)`:
- Time: `O(3^m)`
- Space: `O(3^m)` degrees in the toggling set

For this problem, `m` is small, so this is fast.
