# Project Euler 640 Solution - Shut the Box

<https://projecteuler.net/problem=640>:

* [640.py](640.py)

## Core idea
The game can be treated as a **Markov Decision Process (MDP)**:

- **State:** which cards are face-down, encoded as a bitmask of length `N`.
  - Bit `i-1` = 1 means card `i` is down.
  - Start state = `0` (all up).
  - Goal state = `(1<<N)-1` (all down).

- **Random outcome per turn:** a roll/flip produces a pair `(x, y)`.
  - Bob: two fair dice, `x,y ∈ {1..6}` (36 equally likely outcomes).
  - Alice (check case): two fair coins, values `{1,2}` (4 equally likely outcomes).

- **Actions after seeing `(x, y)`:** toggle exactly one card from `{x, y, x+y}` (duplicates removed).

- **Cost:** each turn costs `1`. We want the policy that **minimizes expected total cost** until reaching the goal.

## Bellman equations
For an optimal value function `V[s]` (expected turns remaining from state `s`):

- `V[goal] = 0`
- For `s != goal`:

\[
V[s] = 1 + \sum_{(x,y)} p(x,y) \min_{a \in A(x,y)} V[s \oplus mask(a)]
\]

where `mask(a)` toggles the bit for the chosen card.

## Main technique: policy iteration
Directly solving the “min” equations is awkward, so we use **policy iteration**:

1. **Policy evaluation** (fixed policy `π`):
   - With a fixed choice for every `(state, outcome)`, the equations become linear:

     \[
     V[s] = 1 + \sum_o p(o) V[next(s, π(s,o))]
     \]

   - We solve these with **Gauss–Seidel iterations**, using a mild **successive over-relaxation (SOR)** factor to speed convergence.

2. **Policy improvement**:
   - For each `(state, outcome)` pick the action leading to the smallest `V[next]`.

Repeat until the policy stops changing. Then do a final high-precision evaluation for the stabilized policy.

## Efficiency tricks
- Bitmasks make state transitions cheap: toggling card `i` is just `state ^ (1<<(i-1))`.
- The action set per outcome is tiny (2 or 3 toggles), so improvement is fast.
- The state space is only `2^12 = 4096` for Bob, so full dynamic programming is feasible.

## Built-in check
The problem statement says Alice’s optimal expected turns are `5.673651` (rounded to 6 decimals). The code computes Alice’s game and asserts this check value before computing Bob.
