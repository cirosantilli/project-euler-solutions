# Project Euler 977 Solution - Iterated Functions

<https://projecteuler.net/problem=977>:

* [977.py](977.py)

# Solution Summary

## Key Ideas
- The condition `f^{(x)}(y) = f^{(y)}(x)` implies `f(x) = f^{(x)}(1)` for all `x`, so every valid function is determined by the orbit of `1`.
- Writing `a_k = f^{(k)}(1)` gives the self-referential recurrence `a_{k+1} = a_{a_k}`; the sequence is an orbit with a tail of length `mu` and a cycle of length `lambda`.
- All indices in the same value-class must share a value; the induced class-transition is a single chain into a cycle. This yields simple indegrees (0/1/2) per class.
- For fixed `lambda` and `mu`, class sizes are determined by distributing the remaining `n - (mu + lambda)` steps across the cycle. The product of falling factorials collapses to a closed form using counts `q = rem // lambda` and `r = rem % lambda`.
- Summing over all `lambda` and `mu` leads to an `O(n log n)` algorithm by grouping `rem` into full blocks of size `lambda` and using geometric series identities.

## Complexity
- Time: `O(n log n)`
- Memory: `O(n / lambda)` transient per loop, worst-case `O(n)` for the `lambda = 2` precompute.

## Files
- `main.py` contains the implementation and sample asserts.
