# Project Euler 762 Solution - Amoebas in a 2D Grid

<https://projecteuler.net/problem=762>:

* [762.py](762.py)

This problem is a **non‑stacking pebbling / splitting game** on a layered directed acyclic graph:

- Nodes are grid cells `(x, y)` with `y ∈ {0,1,2,3}` and `x ≥ 0`.
- A division at `(x, y)` removes that amoeba and creates two amoebas at
  `(x+1, y)` and `(x+1, (y+1) mod 4)`, provided those destination cells are empty.
- After `N` divisions there are `N+1` amoebas; we count **distinct final arrangements**.

The key is to count arrangements **without simulating move orders**, by using a canonical “shot vector”
representation.

## 1) Shot vectors (how often each cell divides)

Let `s[x][y]` be the number of times cell `(x, y)` is used as the *source* of a division over the whole game.
Let `p[x][y] ∈ {0,1}` be the final occupancy of `(x, y)`.

A conservation law holds column-by-column:

- Column 0: `p[0] + s[0] = (1,0,0,0)` (only `(0,0)` starts occupied).
- For `x ≥ 1`:
  - Let `A` be the linear map on 4-vectors defined by  
    `A(v)[y] = v[y] + v[y-1 mod 4]`.
  - Then the next-column balance is  
    `p[x] + s[x] = A(s[x-1])`.

So, given `s[x-1]`, choosing the final mask `p[x]` determines the next shot-vector:
` s[x] = A(s[x-1]) - p[x] `, componentwise.

## 2) A crucial bound: total shots per column never exceeds 3

Let `Sx = sum_y s[x][y]` and `Px = sum_y p[x][y]` (amoebas in column `x` at the end).
Summing `p[x] + s[x] = A(s[x-1])` over rows gives:

`Px + Sx = 2 * S(x-1)`.

Because each column has only 4 rows, `0 ≤ Px ≤ 4`.  
If ever `S(x-1) ≥ 4`, then `Sx = 2S(x-1) - Px ≥ 2S(x-1) - 4 ≥ S(x-1)`, so `S` can never drop back to `0`.
But terminating the game forces `s[x] = 0` for all large enough `x`.

Therefore any terminating configuration must satisfy:

- `Sx ≤ 3` for every column `x`.

This collapses the infinite state space to just the 35 vectors `(a0,a1,a2,a3)` with `a0+…+a3 ≤ 3`.

## 3) Finite automaton over columns (states = shot vectors)

For a state `s` we compute `t = A(s)`.  
A column’s final occupancy is a 4-bit mask `p` (0/1 per row), and the next state is `s' = t - p`.

A transition is valid iff:

- Each component of `s'` is in `{0,1,2,3}`,
- `sum(s') ≤ 3`.

Reaching the all-zero state `s = (0,0,0,0)` means the configuration has finished (no more future divisions).

This gives a tiny directed graph (35 states, ~100 transitions) where each transition has a **weight**
equal to `popcount(p)` = number of amoebas placed in that column.

## 4) Weighted DP by amoeba count

After `N` divisions there are `N+1` amoebas total.
So we count paths in the automaton whose total weight is `N+1`.

Weights are in `{0,1,2,3,4}`, so we can do a fast DP with a **ring buffer of 5 layers**:

- `dp[m][state]` = number of ways to be at `state` after placing `m` amoebas so far.
- Add transitions, shifting by their weight.

This runs in `O(N * |E|)` time with tiny constants, easily fast enough for `N = 100000`.

## 5) Correctness checks

The code asserts the test values given in the statement (`C(2)`, `C(10)`, `C(20)`,
and the last nine digits of `C(100)`), and then prints the last nine digits of `C(100000)`.
