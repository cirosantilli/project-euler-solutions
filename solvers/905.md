# Project Euler 905 Solution - Now I Know

<https://projecteuler.net/problem=905>:

* [905.py](905.py)

This repository solves Project Euler **Problem 905: _Now I Know_**.

## Key idea: reduce epistemic reasoning to Euclid-style recursion

Each player sees two numbers and knows:

- all three numbers are positive
- exactly **one** of the three equals the **sum** of the other two

If a player sees `x` and `y`, then their own number can only be:

- `x + y`  (they are the sum-holder)
- `|x - y|` (one of the visible numbers is the sum-holder)

So each player has **at most two candidates** at any time.

The game history before termination consists only of repeated
“I don’t know” statements, so the public information is equivalent to
**how many turns have passed so far**.

A candidate world is eliminated if it would have ended earlier than the
current history allows. This produces an exact recursive structure.

## 3-state normalization

Any valid triple can be written in one of these normalized forms:

- **State 0**: `A = a + b`, triple `(a+b, a, b)`  (A is sum-holder)
- **State 1**: `B = a + b`, triple `(a, a+b, b)`  (B is sum-holder)
- **State 2**: `C = a + b`, triple `(a, b, a+b)`  (C is sum-holder)

Define `k_state(a,b)` = number of full cycles `(A,B,C)` that elapse before
the sum-holder declares on their own turn.

Turn conversion:

- State 0 ends on A’s turn: `F = 3*k + 1`
- State 1 ends on B’s turn: `F = 3*k + 2`
- State 2 ends on C’s turn: `F = 3*k`

Base cases:

- If `a == b`, then:
  - State 0: A sees equal numbers ⇒ immediate at turn 1 ⇒ `k=0`
  - State 1: B sees equal numbers ⇒ immediate at turn 2 ⇒ `k=0`
  - State 2: C sees equal numbers ⇒ immediate at turn 3 ⇒ `k=1`

## Euclidean (subtractive) recurrence

The elimination logic implies that determining `k_state(a,b)` reduces to
replacing the larger of `a,b` with its difference, i.e. the subtractive
Euclidean algorithm, **with state transitions**.

This forms a tiny deterministic state machine with three states.

## Speed-up: batching long runs with division

Naively subtracting one `b` from a huge `a` could be too slow.

But in the state machine, long runs happen in **two-step cycles** that
reduce the larger value by `2*min` each cycle while returning to the same
state. Therefore we can batch these cycles using:

p = (larger - 1) // (2 * smaller)
larger -= 2 * smaller * p
cost += p

bash
Copy code

This makes the algorithm effectively **O(log n)** in the size of the inputs,
similar to the standard Euclidean algorithm.

## Result computation

For the Euler sum:

sum_{a=1..7} sum_{b=1..19} F(a^b, b^a, a^b + b^a)

pgsql
Copy code

the triple always has `C = A + B`, so every call is in **State 2** and is
computed quickly by the accelerated Euclid-state-machine approach.

No external libraries are required.
