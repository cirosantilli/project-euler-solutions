# Project Euler 871 Solution - Drifting Subsets

<https://projecteuler.net/problem=871>:

* [871.py](871.py)

This repository contains a pure-Python solution (no external libraries) for Project Euler problem 871.

## Key ideas

### 1) Turn the definition into a matching problem
For a subset \(A\) to be *drifting* we need
\[
|A \cup f(A)| = 2|A|.
\]
Using \(|A \cup f(A)| = |A| + |f(A)| - |A \cap f(A)|\), this forces both:

- \(|f(A)| = |A|\) (so \(f\) is injective on \(A\))
- \(A \cap f(A) = \varnothing\)

So choosing \(A\) is the same as choosing as many directed edges \(a \to f(a)\) as possible such that no vertex appears in two chosen edges (neither as source nor as target). That is a **maximum matching** problem on a *functional digraph* (every vertex has out-degree 1).

### 2) Use the functional-graph structure: cycles with in-trees
A functional digraph decomposes into connected components, each consisting of:

- one directed cycle
- directed trees feeding into the cycle

The matching can be solved by handling the trees first, then the cycle.

### 3) Tree DP, computed during indegree trimming
All non-cycle nodes can be removed by repeatedly deleting nodes of indegree 0 (Kahn-style trimming). This gives a natural bottom-up order for the in-trees.

For each node \(v\), the tree DP needs only two aggregates coming from its already-processed children:

- `sum_a[v]`: total matching size in child subtrees when no child is matched to \(v\)
- `best[v]` in {0,1}: whether matching *one* child to \(v\) improves the total

Because a node can be matched to **at most one** child, the improvement is never more than 1.

### 4) Reduce the cycle to a small weighted matching
After trimming, remaining nodes are exactly the cycle nodes.

For a cycle vertex \(v\):

- `occ(v)` is the best contribution from its incoming tree when \(v\) is **unavailable** for tree-matching (because the cycle uses it)
- `delta(v)` is either 0 or 1: the extra edge you can gain by matching \(v\) with one tree child

If we select a cycle edge \(v \to w\), we gain `+1` but must give up both `delta(v)` and `delta(w)`, so each cycle edge gets weight:
\[
1 - \delta(v) - \delta(w).
\]
Now we just need a **maximum weight matching on a cycle graph**, which is solved by the classic two-case DP (exclude the wraparound edge, or force-include it and forbid adjacent edges).

## Files

- `main.py` – computes the required sum and prints it; includes asserts for the sample values from the statement.
- `README.md` – this explanation.
