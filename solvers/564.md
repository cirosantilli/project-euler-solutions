# Project Euler 564 Solution - Maximal Polygons

<https://projecteuler.net/problem=564>:

* [564.py](564.py)

This solution computes **S(50)**, where:

- A segment of length `2n-3` is split at integer points into `n` **positive integer** lengths.
- Those lengths become the consecutive sides of a convex `n`-gon whose area is **maximal**.
- `E(n)` is the expected maximal area over all such splits (all splits equally likely).
- `S(n) = E(3) + E(4) + ... + E(n)`.

## Key techniques

### 1) Convert “random splits” into combinatorics on integer partitions

A split of `2n-3` into `n` positive integers is a **composition**, counted by:

- `C(2n-4, n-1)`

Write each length as `1 + x_i`, where `x_i >= 0` and `sum x_i = n-3`.

Because the polygon area depends only on the *multiset* of side lengths (not their order),
we sum over **integer partitions** of `k = n-3` (order-independent), then weight each
multiset by the number of corresponding compositions:

- weight = multinomial coefficient `n! / (m_1! m_2! ...)`

### 2) Geometry: maximal area polygon with fixed side lengths is cyclic

For fixed side lengths, the maximal-area convex polygon is **cyclic** (vertices on a circle).
Let `r = 2R` be the circle diameter.

Each side length `l` is a chord:
- `l = r * sin(θ/2)`

There are two possible central angles for a chord:
- **minor**: `θ = 2 asin(l/r)`
- **major**: `θ = 2π - 2 asin(l/r)`

A maximal convex cyclic polygon has either:

1. **All minor angles** (circumcenter inside):  
   `sum asin(l/r) = π`

2. **Exactly one major angle** (circumcenter outside):  
   this is only needed when case (1) is impossible, and the major edge must be the **unique longest side** `L`:  
   `sum asin(l/r) = 2 asin(L/r)`

### 3) Area computation from `r`

With `u = l/r`, we have `sqrt(r^2 - l^2) = r * sqrt(1-u^2)`.

For the all-minor case:
- `Area = (1/4) * Σ l * sqrt(r^2 - l^2)`

If the longest side is major, its contribution flips sign:
- `Area = (1/4) * ( Σ l * sqrt(r^2 - l^2)  − 2 * L * sqrt(r^2 - L^2) )`

### 4) Numerical solving (bracketed Newton)

For each multiset of side lengths we solve the appropriate closure equation for `r` using a
**bracketed Newton method** (Newton steps clamped into a sign-changing interval).  
This is fast and stable for the small `n` (up to 50) required.

### 5) Accurate summation

Expected values sum many tiny weighted contributions.  
The implementation uses **Kahan summation** to reduce floating-point error.

## Output

Running `main.py` prints `S(50)` with 6 digits after the decimal point.
