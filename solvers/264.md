# Project Euler 264 Solution - Triangle Centres

<https://projecteuler.net/problem=264>:

* [264.py](264.py)

This repository contains a fast, self‑contained solver for **Project Euler 264**.

## Key observations

### 1) Orthocenter as a vector sum
Place the circumcenter at the origin and represent the vertices by position vectors
`a, b, c ∈ Z²`.

For a triangle whose **circumcenter is the origin**, the orthocenter vector is

`h = a + b + c`.

Here `h = (5, 0)`, so we must find integer vectors `a, b, c` on the **same circle**
(`|a| = |b| = |c|`) satisfying `a + b + c = (5, 0)`.

### 2) Reduce a 3‑point condition to an orthogonal 2‑vector condition
Let

* `d = b + c` (so `a = h − d`)
* `P = b − c` (so `b = (d + P)/2`, `c = (d − P)/2`)

Because `|b| = |c|`, the cross term cancels and we get

* `d · P = 0`  (they are perpendicular)

and a short algebraic manipulation gives a **closed form** for the required
length of `P` in terms of `d = (dx, dy)`:

`|P|² = 3|d|² − 40·dx + 100`.

So the problem becomes:

*enumerate integer vectors `d` for which there exists an integer vector `P`
perpendicular to `d` with that exact squared length, and such that `(d ± P)/2`
are lattice points.*

### 3) Parameterize perpendicular lattice vectors using a primitive direction
Write `d = g(p, q)` where `g ∈ Z\{0}` and `gcd(p, q) = 1`.

All integer vectors perpendicular to `(p, q)` are integer multiples of `(q, −p)`,
so we can write

`P = t(q, −p)`

for some integer `t`.

Let `m = p² + q²`. Then `|P|² = t² m`, and the length condition becomes the
single Diophantine equation

`3 g² m − 40 g p + 100 = t² m`.

### 4) Massive pruning via a modular constraint
Rearranging the equation shows

`3 g² m − 40 g p + 100` must be divisible by `m`, which is equivalent to the
simple congruence:

`(40p) g ≡ 100 (mod m)`.

For each primitive `(p, q)` we solve this linear congruence (using a modular
inverse) and only test `g` values in that arithmetic progression.

### 5) Strong bounds on the search space
For any triangle inscribed in a circle of radius `R`, the perimeter is at least
`4R` (degenerate limit), so with perimeter ≤ `P` we have `R ≤ P/4`.

From `|d| = |b + c| ≤ |b| + |c| = 2R` we also get `|d| ≤ P/2`.

Combining these bounds with the divisibility constraint yields a tight global
bound on `m = p² + q²`, making the brute‑force loop over primitive directions
feasible in Python.

### 6) Deduplication
The same triangle can be generated multiple times by choosing a different vertex
as `a`. The implementation stores each triangle as a sorted triple of vertices
in a set to ensure each is counted exactly once.

## Numerical handling

Perimeters involve square roots. The solver uses `math.hypot` for distances and
`math.fsum` for a stable floating‑point sum, then formats the final answer to
four decimals.

## Built‑in checks

The problem statement provides a test case:

* For perimeter ≤ 50 there are **9** triangles and the perimeter sum rounded to
  4 decimals is **291.0089**.

`main.py` includes asserts for both values.
