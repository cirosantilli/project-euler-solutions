# Project Euler 928 Solution - Cribbage

<https://projecteuler.net/problem=928>:

* [928.py](928.py)

This solution counts all **non-empty** hands (subsets of a standard 52-card deck)
whose **Hand score** equals the problem’s **Cribbage score**.

## Core idea: work by rank-multiplicities, not by individual cards

A hand is determined by how many cards of each rank it contains:
`c1..c13` with `0 <= cr <= 4`.  
For each rank count `cr`, the number of suit-choices is `C(4, cr)`, so the total
number of hands matching a multiplicity pattern is the product of those binomials.

All scoring components depend only on these multiplicities.

## Scoring components from multiplicities

- **Hand score**: `sum cr * value(r)` where `value(r)=r` for Ace..9 and `10` for 10/J/Q/K.
- **Pairs**: each rank contributes `2 * C(cr, 2) = cr*(cr-1)`.
- **Runs**: a run is a **maximal consecutive segment of ranks present**.
  If a segment has length `L` and multiplicities `cr > 0`, its run score is:

  `L * (product of cr over the segment)`

  (This matches the examples where duplicates multiply the number of runs.)
- **Fifteens**: count subsets of cards whose values sum to 15.
  For a rank with multiplicity `c` and value `v`, selecting `k` of those cards
  contributes `C(c,k)` ways and adds `k*v` to the total.

  This is tracked via a small subset-sum DP up to 15.

## Meet-in-the-middle + a key simplification for fifteens

The ranks are split at **7 / 8**:

- Left side: ranks `1..7` (values `1..7`)
- Right side: ranks `8..13` (values `8,9,10,10,10,10`)

Because all right-side values are **>= 8**, the only possible right-side subset sums
`<= 15` are **0, 8, 9, 10**.  
That means the coefficient of `x^15` in the full hand is:

`F15 = L15 + L7*R8 + L6*R9 + L5*R10`

where:
- `Lk` is the number of left-side subsets summing to `k`
- `R8 = c8`, `R9 = c9`, `R10 = total number of 10-valued cards on the right`

So we never need the full 16-coefficient polynomial on the right.

## Handling runs across the boundary

Runs can cross the split between ranks 7 and 8.  
To avoid double-counting, each side computes run score for segments **fully inside**
its half, but **keeps one boundary segment “pending”**:

- left keeps the trailing segment ending at rank 7
- right keeps the leading segment starting at rank 8

At combine time, those two pending segments are merged (or used alone) and scored
as the boundary run contribution.

## Final matching condition

For each half we build grouped counts keyed by the small set of parameters needed,
and store a map of:

`A = (hand_value - pair_score - internal_run_score)`

Combining halves adds the boundary-run score and the computed fifteen count, and checks:

`(A_left + A_right - boundary_run) == 2 * F15`

The solution sums the product of the suit-choice weights across all matching pairs,
then subtracts 1 to exclude the empty hand (which would satisfy 0 == 0 but is not allowed).
