# Project Euler 509 Solution - Divisor Nim

<https://projecteuler.net/problem=509>:

* [509.py](509.py)

## Key observation: reduce to a 1‑pile impartial game
With three piles, a move affects exactly one pile and the player who cannot move loses.  
That’s a **disjunctive sum** of three identical impartial games, so **Sprague–Grundy** applies:

- Each pile size `n` has a Grundy number `g(n)`.
- A triple `(a,b,c)` is losing iff `g(a) XOR g(b) XOR g(c) = 0`.
- Therefore `S(n) = n³ − L(n)`, where `L(n)` is the number of losing triples.

So the whole task is:
1) understand `g(n)` for the 1‑pile game, then  
2) count how often each Grundy value occurs in `1..n`.

## Grundy number for one pile: `g(n) = v2(n)`
Let `v2(n)` be the exponent of 2 in `n` (the number of times 2 divides `n`).

### 1) Odd `n` have Grundy 0
If `n` is odd, **every proper divisor `d` is odd**, so `n − d` is even.  
That means every reachable position has `v2(n−d) ≥ 1`, so **0 is not reachable** and the mex is 0:
`g(n)=0`.

### 2) Even `n = 2^k * m` (with `m` odd) have Grundy `k`
We show:
- Every value `< k` is reachable.
- Value `k` is not reachable.

**Reachability of all `< k`:**  
For any `t < k`, choose the proper divisor `d = n / 2^(k−t) = 2^t * m`.  
Then:

`n − d = 2^k m − 2^t m = 2^t m (2^(k−t) − 1)`

and `(2^(k−t) − 1)` is odd, so `v2(n−d)=t`. Hence every `t<k` is reachable.

**Impossibility of reaching `k`:**
- If a divisor `d` is **not** divisible by `2^k`, then subtracting it changes the lowest `k` bits, so `v2(n−d) < k`.
- If `d` **is** divisible by `2^k`, write `d = 2^k d'` with `d'|m` (and `d'` odd).  
  Then `n−d = 2^k(m−d')`, and `m−d'` is even (odd−odd), so `v2(n−d) ≥ k+1`, not `k`.

So mex of `{0,1,...,k−1}` is `k`, giving `g(n)=k=v2(n)`.

## Counting losing triples using a frequency table
Let `f[k] = #{1 ≤ x ≤ n : v2(x) = k}`.

This has a simple closed form:

`f[k] = floor(n / 2^k) − floor(n / 2^(k+1))`

To count losing triples, we need:

`v2(a) XOR v2(b) XOR v2(c) = 0`

Equivalently, for every pair `(i,j)` the third value is forced to be `k = i XOR j`:

`L(n) = Σ_i Σ_j f[i] * f[j] * f[i XOR j]`

Since `v2(x)` is at most `⌊log2 n⌋` (≈ 47 for the input), we only need an array of size 64 and the double sum is tiny.

Finally:

`S(n) = n³ − L(n)` and the problem asks for `S(n) mod 1234567890`.

## What the code does
- Builds `f[k]` via bit shifts (fast exact floors).
- Computes `L(n)` with the `Σ_i Σ_j` formula (optionally modulo `M`).
- Returns `(n³ − L(n)) mod M`.
- Includes the statement’s test asserts:
  - `S(10) = 692`
  - `S(100) = 735494`
