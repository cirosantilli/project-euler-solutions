# Project Euler 598 Solution - Split Divisibilities

<https://projecteuler.net/problem=598>:

* [598.py](598.py)

## Goal
For a positive integer `n`, let `C(n)` be the number of factor pairs `(a,b)` with `a·b = n`, `a ≤ b`, such that `a` and `b` have the **same number of divisors**.

Problem 598 asks for:

- `C(100!)`, given that `C(48)=1` and `C(10!)=3`.

The program in `main.py` prints the required value.

## Core ideas used

### 1) Work with the divisor-count formula
If

- `n = ∏ p^e`
- `a = ∏ p^x` (so `b = n/a = ∏ p^(e-x)`)

then the divisor counts are:

- `d(a) = ∏ (x+1)`
- `d(b) = ∏ (e-x+1)`

So we need to count exponent choices `x` such that:

`∏ (x+1) = ∏ (e-x+1)`.

Instead of comparing huge products directly, the code compares the **prime-exponent differences** of the ratio

`r = d(a) / d(b) = ∏ (x+1)/(e-x+1)`

and counts assignments where `r = 1`.

### 2) Represent each split by a “difference vector”
For one prime power `p^e` in `n`, choosing `x` contributes the factor pair

- `u = x+1`
- `v = e-x+1`

to `(d(a), d(b))`. The contribution to the ratio is `u/v`.

Factor `u` and `v`, and store the exponent difference for each tracked prime.
Multiplying ratios corresponds to **adding** these difference vectors.

### 3) Key simplification specific to `100!`
In `100!`, only the prime powers for:

- `2^97` (where `u,v` can be up to `98`)
- `3^48` (where `u,v` can be up to `49`)

can introduce large primes (like `29,31,37,41,43,47`) into the ratio, because only they allow `u` or `v` to be large enough.

All other primes have exponent `≤ 24`, so `u,v ≤ 25`, which never contains primes `≥ 29`.

That means:

- Differences for primes `{29,31,37,41,43,47}` must be cancelled **entirely** by the choices for the `2`-split and the `3`-split.

So the code:

1. Enumerates all `(u2,u3)` choices for the `2` and `3` splits.
2. Keeps only those where the large-prime difference vector is **zero**.

### 4) DP over the remaining primes
For the remaining primes with exponents in `100!`, we build a distribution (a dynamic programming map) over difference vectors for primes `≤ 23`.

To make this faster, the code splits the work:

- A DP over `{5,7,11,13,17,19,23}` produces a map keyed by:
  - differences for primes `5..23` (outer key)
  - plus a small `(d2,d3)` component (inner key)
- The primes with small exponents (`e=1,2,3`) only affect primes `2` and `3`, so they are aggregated into a tiny 2D distribution `S(d2,d3)`.

At query time, for each valid `(u2,u3)` we look up the needed outer key and combine inner `(d2,d3)` counts with `S`.

### 5) Convert “divisors counted” to “pairs counted”
The DP counts divisors `a` satisfying `d(a)=d(n/a)`. These come in complementary pairs `(a, n/a)`.

- If `n` is not a square: `C(n) = |S| / 2`
- If `n` is a square: `C(n) = (|S| + 1) / 2` (the middle divisor `a=b=√n` is unpaired)

Since `100!` is not a square, the program returns `|S|//2`.

## Sanity checks
`main.py` includes asserts for the statement’s test values:

- `C(48) = 1`
- `C(10!) = 3`

## Output
Running `python3 main.py` prints:

- `543194779059`
