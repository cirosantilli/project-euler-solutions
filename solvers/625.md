# Project Euler 625 Solution - Gcd Sum

<https://projecteuler.net/problem=625>:

* [625.py](625.py)

We want:

\[
G(N)=\sum_{j=1}^{N}\sum_{i=1}^{j}\gcd(i,j)
\]

and we need \(G(10^{11}) \bmod 998244353\).

## Key identities

1. **GCD-sum for a fixed \(j\)**  
   Let \(g(j)=\sum_{i=1}^{j}\gcd(i,j)\).  
   The standard divisor-counting argument gives:

\[
g(j)=\sum_{d\mid j} d\;\varphi\!\left(\frac{j}{d}\right)
\]

2. **Swap the order of summation**  
   Writing \(j=d\cdot m\) and summing over all \(j\le N\):

\[
G(N)=\sum_{m=1}^{N}\varphi(m)\;\underbrace{\sum_{d\le \lfloor N/m\rfloor} d}_{T(\lfloor N/m\rfloor)}
\]

where \(T(x)=x(x+1)/2\) is the triangular-number function.

So:

\[
G(N)=\sum_{m=1}^{N}\varphi(m)\;T\!\left(\left\lfloor\frac{N}{m}\right\rfloor\right)
\]

## Main techniques used

### 1) Summatory totient with memoized recursion

Define:

\[
\Phi(n)=\sum_{k=1}^{n}\varphi(k)
\]

Using the identity \(\sum_{d=1}^{n}\varphi(d)\left\lfloor n/d\right\rfloor = \sum_{k=1}^{n}k = T(n)\),
you can derive a recursive form:

\[
\Phi(n)=T(n)-\sum_{i=2}^{n}\Phi\!\left(\left\lfloor\frac{n}{i}\right\rfloor\right)
\]

This sum is split at \(s=\lfloor\sqrt{n}\rfloor\):

- for \(i\le s\), the quotient \(\lfloor n/i\rfloor\) is large and we recurse,
- for \(i>s\), the quotient is small (at most \(\lfloor n/s\rfloor\)) and we use precomputed prefix sums.

A memo table ensures each large \(\Phi(\cdot)\) is computed once.

### 2) Dirichlet hyperbola method for \(G(N)\)

Let \(s=\lfloor\sqrt{N}\rfloor\). A symmetric “hyperbola split” yields:

\[
G(N)=\sum_{k\le s} k\,\Phi\!\left(\left\lfloor\frac{N}{k}\right\rfloor\right)
\;+\;\sum_{k\le s} \varphi(k)\,T\!\left(\left\lfloor\frac{N}{k}\right\rfloor\right)
\;-\;T(s)\,\Phi(s)
\]

The term \(\sum k\,\Phi(\lfloor N/k\rfloor)\) is computed with **quotient grouping**:
when \(\lfloor N/k\rfloor\) stays constant over a range of \(k\), we replace the loop with an arithmetic-series sum.

### 3) Precomputation with a linear sieve

We precompute \(\varphi(k)\) for \(k\le B\) (here \(B=10^7\)) using an Euler/linear sieve,
then turn it into a prefix sum array \(\Phi(k)\) modulo \(998244353\).  
Only the small \(\varphi(k)\) values up to \(\sqrt{N}\) are kept separately for the second hyperbola term.

## Complexity sketch

- Sieve: \(O(B)\)
- Memoized \(\Phi(n)\): sublinear in \(N\) due to the \(\sqrt{n}\)-split and caching
- Final \(G(N)\): \(O(\sqrt{N})\) arithmetic steps plus calls into the cached \(\Phi(\cdot)\)

Everything is performed **modulo 998244353**.
