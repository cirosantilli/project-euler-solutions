# Project Euler 556 Solution - Squarefree Gaussian Integers

<https://projecteuler.net/problem=556>:

* [556.py](556.py)

This solution computes:

- `f(n)`: the number of **proper** squarefree Gaussian integers `z = a + bi` with `a > 0`, `b ≥ 0`, and `a² + b² ≤ n`,
- and outputs `f(10¹⁴)`.

The implementation is in `main.py` and uses only the Python standard library.

## Key techniques used

### 1) Möbius inversion in **ℤ[i]** (Gaussian integers)

An element is squarefree in **ℤ[i]** if no **proper Gaussian prime** appears with exponent ≥ 2.

As in the integer case, the squarefree indicator can be expressed using a Möbius function over **ℤ[i]**:

\[
\mathbf{1}_{\text{squarefree}}(z)=\sum_{d^2 \mid z}\mu_{\mathbb{Z}[i]}(d)
\]

Summing over all `z` in the disk `a²+b² ≤ n` turns the problem into:

\[
S(n)=\sum_d \mu_{\mathbb{Z}[i]}(d)\,A\!\left(\frac{n}{N(d)^2}\right)
\]

where `N(d)` is the Gaussian norm and `A(t)` counts lattice points `(a,b)` with `a²+b² ≤ t`.

### 2) Collapse the Gaussian Möbius sum by **norm**

`A(n / N(d)²)` depends only on `N(d)`, not on the argument of `d`. So we group all Gaussian integers `d` having the same norm `m`:

\[
F(m) = \sum_{N(d)=m}\mu_{\mathbb{Z}[i]}(d)
\qquad\Rightarrow\qquad
S(n)=\sum_{m\le \sqrt n}F(m)\,A\!\left(\frac{n}{m^2}\right)
\]

`F(m)` becomes a **multiplicative integer function** with simple local rules depending on `p mod 4`:

- `p = 2`: exponent `0/1` allowed (coefficients `1, -1`)
- `p ≡ 1 (mod 4)`: exponent `0/1/2` allowed (coefficients `1, -2, +1`)
- `p ≡ 3 (mod 4)`: exponent `0/2` allowed (coefficients `1, -1`)

This lets us compute `F(m)` for all `m ≤ 10⁷` via a smallest-prime-factor sieve.

### 3) Fast exact lattice-point counts inside circles

We need `A(t) = #{(a,b) ∈ ℤ² \ {(0,0)} : a² + b² ≤ t}`.

- For **small** `t` (≤ `10⁷`), we precompute `A(t)` using the classic multiplicative formula for
  `r₂(k) = #{(a,b): a² + b² = k}` and take a prefix sum.

- For the few **large** `t` values that occur (only for small `m`), we compute `A(t)` exactly with a
  monotone “two-pointer” circle-walk in `O(√t)` time (no floating point).

### 4) Grouping by constant `⌊n / m²⌋`

Instead of iterating all `m`, we jump over ranges where `n // m²` is constant:

- Let `x = n // m²`.
- The largest `m₂` with the same `x` is `m₂ = ⌊√(n/x)⌋`.

This reduces the summation to about `O(n^{1/3})` groups.

### 5) Convert from “all associates” to “proper”

Every nonzero Gaussian integer has exactly 4 associates under multiplication by the units `{±1, ±i}`.
Each associate class has exactly one “proper” representative (`a > 0`, `b ≥ 0`), so:

\[
f(n) = \frac{S(n)}{4}
\]

## Correctness checks

`main.py` includes asserts for the example values from the problem statement:

- `f(10) = 7`
- `f(10²) = 54`
- `f(10⁴) = 5218`
- `f(10⁸) = 52126906`
