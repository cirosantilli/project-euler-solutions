# Project Euler 798 Solution - Card Stacking Game

<https://projecteuler.net/problem=798>:

* [798.py](798.py)

## 1) Split the game by suit (Sprague–Grundy)

A move always uses two cards of the **same suit**, so the full game is the disjoint sum of `s` identical impartial subgames (one per suit).  
By the Sprague–Grundy theorem, the overall position is losing iff the XOR of the per-suit Grundy values is `0`.

So we first study **one suit** with cards `1..n`, and count how many initial visible subsets yield each Grundy value:

- `f[g]` = number of initial visible sets (subsets of `{1..n}`) with single-suit Grundy value `g`.

Then the answer for `s` suits is the number of `s`-tuples whose XOR is `0`, i.e. the coefficient of `0` in the `s`-fold XOR-convolution of `f`.

---

## 2) Count the single-suit Grundy distribution

For a single suit, let `f(n,g)` be the count at size `n`. One can show (via a case split on whether the card `n` is initially visible, and how moves interact with the top ranks) that for `g ≥ 3`:

- `f(n,g) = f(n-1,g) + f(n-2,g-2)`.

The small Grundy values admit closed forms:

- `f(n,0) = 2^(n-2) + 2`  (for `n ≥ 2`)
- `f(n,1) = 2^(n-2) + (n-2)`  (for `n ≥ 2`)
- `f(n,2) = 2^(n-3) + (n-3)`  (for `n ≥ 3`)

Unrolling the recurrence yields weighted sums with binomial coefficients. The implementation computes these efficiently with a **diagonal DP** for

`F(X,k) = Σ_{r=0..X} C(r+k, k) · 2^(X-r)`

along diagonals where `X` decreases by `2` as `k` increases by `1`. A closed form for the linear (non-power-of-two) part reduces to a small number of binomial coefficients, so each new `f[g]` is produced in **O(1)** once factorials/inverses are available.

---

## 3) XOR convolution via Walsh–Hadamard transform

Let `L` be the next power of two ≥ `n`, and pad `f` to length `L`. The XOR-convolution is diagonalized by the Walsh–Hadamard transform (WHT):

- `WHT(f ⊛ g) = WHT(f) · WHT(g)` (pointwise).

Therefore the `s`-fold XOR-convolution has transform `WHT(f)^s` (pointwise power). The count of tuples with XOR `0` is obtained from the inverse transform:

`C(n,s) = (1/L) · Σ_t WHT(f)[t]^s (mod MOD)`,

using `MOD = 1_000_000_007` and modular inverses.

---

## 4) What the code does

1. Build factorials and inverse factorials modulo `MOD` (needed for `nCk`).
2. Construct the padded single-suit distribution `f` in `O(n)` using the diagonal DP + binomial identities.
3. Apply an in-place XOR WHT to `f`.
4. Compute `Σ_t f_hat[t]^s` modulo `MOD`, multiply by `inv(L)`.

The file `main.py` also includes asserts for the sample values given in the problem statement.
