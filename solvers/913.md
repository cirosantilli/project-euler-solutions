# Project Euler 913 Solution - Row-major vs Column-major

<https://projecteuler.net/problem=913>:

* [913.py](913.py)

## Key idea: swaps = N − cycles

Swapping any two entries is the same as applying a **transposition**. For a permutation of `N` items, the minimum number of transpositions required to realize it is:

- `N − (#cycles)`

because each cycle of length `L` can be fixed in `L−1` swaps.

So the task is reduced to counting **cycles** in the permutation that maps the row-major placement to the column-major placement.

---

## The permutation becomes modular multiplication

Index the `n × m` positions by `i = 0..nm−1` (row-major index). The element `i` ends up at

```
(i mod n) * m + floor(i / n)
```

A classic (and very useful) fact for this mapping is:

- For `i = 0..(nm−2)`, the mapping is equivalent to

```
 i  ->  (i * m) mod (nm − 1)
```

- The last index `nm−1` is a fixed point.

This works because `gcd(m, nm−1) = 1`, so multiplication by `m` is a permutation modulo `nm−1`.

---

## Counting cycles with number theory

Let `M = nm − 1` and consider the permutation on residues `0..M−1`:

```
T(x) = (x * m) mod M
```

Elements partition by `d = gcd(x, M)`. For a fixed divisor `Q` of `M`, the set

- `{ x : gcd(x, M) = M/Q }`

has size `φ(Q)`, and all of those elements have the same cycle length, equal to the **multiplicative order** of `m (mod Q)`.

That yields:

```
#cycles (including x = 0) =  Σ_{Q | M}  φ(Q) / ord_Q(m)
```

Then the full `n × m` permutation has one extra fixed point (`nm−1`), so:

```
S(n, m) = nm − 1 − Σ_{Q | (nm−1)}  φ(Q) / ord_Q(m)
```

---

## Efficient computation of orders

For each divisor `Q` we need `ord_Q(m)`. Using prime factorization:

- For `Q = ∏ p_i^{a_i}` (coprime factors),

```
ord_Q(m) = lcm( ord_{p_i^{a_i}}(m) )
```

For a prime power `p^a`, the order divides the Carmichael function `λ(p^a)`:

- `λ(p^a) = (p−1)p^{a−1}` for odd primes
- special handling for `2^a`

Compute the order by starting from `λ(p^a)` and repeatedly dividing by prime factors when the modular power test still returns `1`.

---

## Why the `n^4, m^4` case stays tractable

In the required sum we evaluate `S(n^4, m^4)` for `2 ≤ n ≤ m ≤ 100`.

Let `t = nm` (so `t ≤ 10000`). Then:

- `n^4 m^4 = (nm)^4 = t^4`
- `M = t^4 − 1 = (t−1)(t+1)(t^2+1)`

All three factors are at most about `10^8`, so `M` can be factored quickly by trial division of those parts, avoiding heavy large-integer factorization.

---

## Implementation notes

- Trial-division factorization is cached.
- `λ(p^a)` and its prime divisors are cached per `(p, a)`.
- The divisor sum is computed by DFS over prime exponents, maintaining:
  - `φ(Q)` multiplicatively
  - `ord_Q(m)` via incremental `lcm`

The code also includes the problem’s given checks as `assert`s.
