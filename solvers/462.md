# Project Euler 462 Solution - Permutation of 3-smooth Numbers

<https://projecteuler.net/problem=462>:

* [462.py](462.py)

## Core idea: turn the divisor constraint into a poset
Every 3‑smooth number can be written uniquely as:

- \(x = 2^a 3^b\) for integers \(a,b \ge 0\)

For a fixed \(N\), the set \(S(N)\) is exactly the set of exponent pairs \((a,b)\) such that
\(2^a 3^b \le N\).

The rule “each element comes after all of its proper divisors” becomes:

- \((a_1,b_1)\) must come before \((a_2,b_2)\) whenever \(a_1 \le a_2\) and \(b_1 \le b_2\)
  (and the pairs are different)

So we’re counting **linear extensions** of a 2D dominance-order poset.

## Ferrers/Young diagram shape
Fix \(b\). The maximum allowed \(a\) is:

\[
a_{\max}(b) = \left\lfloor \log_2\left(\frac{N}{3^b}\right) \right\rfloor
\]

So each \(b\) gives a row of length \(a_{\max}(b) + 1\). As \(b\) increases, \(N/3^b\) decreases,
so these row lengths are **non‑increasing**: a Ferrers (Young) diagram.

That’s the key structural simplification: **counting valid permutations = counting standard Young tableaux** of that shape.

## Hook-length formula
For a Ferrers diagram with \(n\) cells, the number of standard Young tableaux is:

\[
F = \frac{n!}{\prod_{\text{cells }c} h(c)}
\]

where \(h(c)\) is the cell’s **hook length** (cells to the right + cells below + 1).

Because the diagram for \(N = 10^{18}\) has only about ~1100 cells, we can compute:

- \(n!\) as a big integer
- the hook product as a big integer
- divide exactly (the result is guaranteed to be an integer)

No floating point is needed for the main computation.

## Fast construction details
- Row length for a given \(b\) is `bit_length(N // 3**b)`, i.e. \(\lfloor \log_2(\cdot)\rfloor + 1\).
- Column heights are computed efficiently from the non‑increasing row lengths.
- Hook lengths follow:
  \[
  h(i,j) = (\text{row\_len} - j) + (\text{col\_height}(j) - i) - 1
  \]

## Output formatting
Project Euler requests scientific notation with **10 digits after the decimal point**.
The solution formats the exact integer and performs **half‑up rounding** using string slicing.

---

Files:
- `main.py` — full implementation + asserts for the statement’s test values
- `README.md` — this summary
