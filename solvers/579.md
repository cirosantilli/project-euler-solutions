# Project Euler 579 Solution - Lattice Points in Lattice Cubes

<https://projecteuler.net/problem=579>:

* [579.py](579.py)

This solution counts all **lattice cubes** whose vertices lie in `[0,n]^3` and computes:

- **C(n)**: number of such cubes
- **S(n)**: sum of all lattice points contained in each such cube  
  (counting points **inside or on the boundary**)

The required output is:

> `S(5000) mod 10^9`

---

## 1. Quaternion parametrization of cube orientations

A cube in 3D can be described by an orthogonal triple of equal-length integer vectors  
`u, v, w` originating from one vertex.

All such orthogonal triples can be generated using the **Euler-Rodrigues quaternion formula**.

Given an integer quaternion:

\[
q = a + bi + cj + dk
\]

the corresponding Euler matrix has columns:

\[
u = q i \bar q,\quad
v = q j \bar q,\quad
w = q k \bar q
\]

Each of these is an integer vector, mutually orthogonal, and all have length:

\[
|u| = |v| = |w| = a^2+b^2+c^2+d^2
\]

So `m = a^2+b^2+c^2+d^2` is the **primitive cube side length**.

---

## 2. Avoiding duplicates with *primary quaternions*

Each cube corresponds to **24 equivalent quaternions** due to cube symmetries (right unit multiplication).
To enumerate each cube exactly once, we restrict to a canonical representative: **primary quaternions**.

From Kiss–Kutas (arXiv:1108.3113):

A quaternion is *primary* if:

1. It belongs to `S1` meaning its **real part parity differs from the other three**
2. It satisfies:

\[
a+b+c+d \equiv 1 \pmod{4}
\]

This ensures each cube orientation is generated **exactly once**, without needing hash sets.

---

## 3. Counting cube placements in `[0,n]^3`

For a cube with edge vectors `u,v,w`, define spans:

\[
s_x = |u_x|+|v_x|+|w_x|
\quad
s_y = |u_y|+|v_y|+|w_y|
\quad
s_z = |u_z|+|v_z|+|w_z|
\]

Scaling by integer `t` multiplies spans by `t`.
The number of translations fitting in the box is:

\[
(n+1-t s_x)(n+1-t s_y)(n+1-t s_z)
\]

This is a cubic polynomial in `t`.

---

## 4. Lattice-point count using Ehrhart theory

A cube is a special **lattice parallelepiped**.

For a parallelepiped spanned by vectors `u,v,w`, the number of lattice points in it is:

\[
L(1)=1 + \sum \gcd(u_i) + \sum \gcd(u_i \times u_j) + |\det(u,v,w)|
\]

Scaling by `t` gives an Ehrhart polynomial of degree 3:

\[
L(t)=1 + A_1 t + A_2 t^2 + A_3 t^3
\]

For our cubes:

- `A3 = m^3` because `det = side^3`
- `A2 = m*A1` because `u×v = ±m w`

So:

\[
L(t)=1 + A_1 t + (mA_1)t^2 + m^3 t^3
\]

---

## 5. Fast summation over scales using power sums

For each orientation we must sum over `t = 1..T`:

- cube placements (degree 3)
- placements × lattice points (degree 6)

We precompute:

\[
\sum_{t=1}^T t^k,\quad k=0..6
\]

Then each orientation contributes in **O(1)** time via polynomial coefficients,
so the whole computation is fast enough for `n=5000`.

---

## Output

The program prints:

\[
S(5000)\bmod 10^9 = 3805524
\]

and includes asserts for all sample values from the problem statement.
