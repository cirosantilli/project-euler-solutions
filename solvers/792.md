# Project Euler 792 Solution - Too Many Twos

<https://projecteuler.net/problem=792>:

* [792.py](792.py)

This solution computes

- `S(n) = Σ_{k=1..n} (-2)^k * C(2k,k)`
- `u(n) = v2(3*S(n) + 4)` where `v2(x)` is the exponent of the largest power of 2 dividing `x`
- `U(N) = Σ_{n=1..N} u(n^3)` for `N = 10_000`

No third‑party libraries are used.

## Main ideas

### 1) Switch from a prefix sum to a tail sum (2-adic view)

The generating function for central binomial coefficients implies that the infinite series

`3 * Σ_{k≥1} (-2)^k * C(2k,k) + 4`

converges to `0` in the 2-adic metric. Interpreting the partial sum `S(n)` inside the 2-adics gives

`3*S(n) + 4 = -3 * Σ_{k>n} R(k)` with `R(k) = (-2)^k * C(2k,k)`.

Because `-3` is odd, it does not affect the 2-adic valuation, so

`u(n) = v2( Σ_{k>n} R(k) )`.

That replaces a very long prefix sum with a tail sum whose terms quickly become highly divisible by powers of 2.

### 2) Use a simple ratio to generate terms

The terms satisfy an exact recurrence:

`R(k+1) / R(k) = -4 * (2k + 1) / (k + 1)`.

This avoids computing `C(2k,k)` directly, even for huge `k` (here `k` can be around `10^12`).

### 3) Track powers of two separately from odd parts

Write each term as

`R(k) = 2^{e_k} * a_k` where `a_k` is odd.

The exponent is easy:

`e_k = v2(R(k)) = k + popcount(k)`

because `v2(C(2k,k))` equals the number of 1-bits in `k`.

When advancing from `k` to `k+1`, we factor all powers of two out of the denominator `(k+1)` and only invert the **odd** part modulo `2^P`. Odd numbers are always invertible modulo a power of 2.

A Newton iteration computes `a^{-1} mod 2^P` efficiently.

### 4) Stop after a short prefix of the tail

After summing terms `k = n+1 .. n+m`, the remaining tail starts at `k = n+m+1`.
Since `v2(R(k)) ≥ k`, the remainder is a multiple of `2^{n+m+1}`.

Therefore, if the partial tail sum has valuation **strictly less** than `n+m+1`, then adding the remainder cannot change that valuation, and we have found `u(n)` exactly.

In practice `m` stays small.

## Complexity

For each `u(n)` we generate only a few dozen tail terms and do constant‑time big‑integer operations modulo `2^P`. With `N = 10_000` this runs comfortably fast in plain Python.

## Checks from the statement

The script asserts the provided examples:

- `S(4) = 980` and `u(4) = 7`
- `u(20) = 24`
- `U(5) = 241`

Run:

```bash
python3 main.py
```

It prints `U(10_000)`. You can also supply a different `N`:

```bash
python3 main.py 100
```
