# Project Euler 683 Solution - The Chase II

<https://projecteuler.net/problem=683>:

* [683.py](683.py)

This implementation computes the expected prize `G(500)` for **The Chase II** without
external libraries.

## Key ideas

### 1) Reduce to a 1D Markov chain
Each round involves two independent dice moving around a circle of `k` players:

- left with probability `1/3`,
- right with probability `1/3`,
- stay with probability `1/3`.

Because the players are arranged symmetrically, the round depends only on the **relative
difference** between the two dice positions (modulo `k`). The round ends when the
difference first hits `0`.

The relative step distribution becomes:

- `Δ = 0` with probability `1/3`,
- `Δ = ±1` with probability `2/9`,
- `Δ = ±2` with probability `1/9`.

So a round is an absorbing Markov chain on states `{0,1,...,k-1}` with `0` absorbing.

### 2) Compute `E[T]` and `E[T²]` via linear equations
Let `T` be the number of turns until absorption (difference becomes `0`).

For each transient state `i`:

- `E[T]` satisfies a linear system coming from `T = 1 + T(next)`.
- `E[T²]` follows from `(1 + T(next))² = 1 + 2T(next) + T(next)²`.

After clearing denominators, both moment systems share the same left-hand matrix, and
only the right-hand side changes.

The expected payment in one round with `k` players is the average of `E[T²]` over a
uniform initial difference (including the `0` case, which contributes `0`).

### 3) Exploit the matrix structure
The transient-state system has a **pentadiagonal** structure (neighbors at distance 1
and 2), plus two wrap-around corner entries caused by modulo-`k` arithmetic.

To solve efficiently:

- factor the non-cyclic pentadiagonal matrix in **O(k)** time,
- incorporate the two corner terms with a **rank‑2 Sherman–Morrison–Woodbury** update,
  so each round is solved in linear time overall.

### 4) Sum over rounds
The full game consists of `n-1` rounds. By symmetry, the expected payment in a round
depends only on the current number of players `k`, so:

`G(n) = Σ_{k=2..n}  E[payment in a k-player round]`.

The program computes these expectations for `k = 2..500` and prints `G(500)` in
scientific notation with **9 significant digits**, as requested.

## Files

- `main.py` — computes and prints `G(500)`; includes asserts for the statement’s examples.
- `README.md` — this explanation.
