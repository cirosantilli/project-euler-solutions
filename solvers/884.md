# Project Euler 884 Solution - Removing Cubes

<https://projecteuler.net/problem=884>:

* [884.py](884.py)

This repository contains a single-file solution (`main.py`) that computes

\[
S(N) = \sum_{1 \le n < N} D(n),\quad N = 10^{17}
\]

where `D(n)` is the number of steps in the greedy process that repeatedly
subtracts the largest perfect cube not exceeding the current remainder.

## Key ideas

### 1) Work with a prefix sum

Define a prefix function

\[
F(N) = \sum_{0 \le n < N} D(n).
\]

Because `D(0) = 0`, the required value is simply `S(N) = F(N)`.

### 2) Split numbers by their largest cube

For any integer `k ≥ 1`, all numbers in the interval

\[
[k^3, (k+1)^3)
\]

have the same first greedy subtraction: subtract `k^3` once.
Writing `n = k^3 + m` with `0 ≤ m < (k+1)^3 - k^3`, we get

\[
D(n) = 1 + D(m).
\]

Let

\[
\Delta_k = (k+1)^3 - k^3 = 3k^2 + 3k + 1.
\]

Summing over a full cube interval yields

\[
\sum_{n=k^3}^{(k+1)^3-1} D(n)
= \Delta_k + F(\Delta_k).
\]

### 3) A recurrence for `F(N)`

Let `K = ⌊\sqrt[3]{N-1}⌋` and `L = N - K^3` (so `0 < L ≤ \Delta_K`).
Numbers `< N` consist of:

- complete cube intervals for `k = 1 .. K-1`, and
- a partial final block `[K^3, N)` of length `L`.

This gives the compact recurrence:

\[
F(N) = (N-1) + \sum_{k=1}^{K-1} F(\Delta_k) + F(L).
\]

The important practical point is that `L` is **much smaller** than `N`:
`L ≤ 3K^2 + 3K + 1`, so recursion depth is tiny.

### 4) Precompute only what’s needed

When evaluating `F(\Delta_k)` for extremely large `k`, the cube root
`⌊\sqrt[3]{\Delta_k-1}⌋` is only about `O(k^{2/3})`, so it stays under ~10k
for the full `N = 10^{17}` target.

The code therefore keeps a prefix array of

\[
P(t) = \sum_{k=1}^{t} F(\Delta_k)
\]

only up to that small bound, and maintains the *total* `\sum_{k=1}^{K-1} F(\Delta_k)`
with a running accumulator.

### 5) Exact integer cube roots

An integer cube-root helper is used (`icbrt`) so that all boundary computations
(such as `K = ⌊\sqrt[3]{N-1}⌋`) are exact.

## Complexity sketch

- Outer loop: `O(\sqrt[3]{N})` cube intervals (≈ 4.6×10^5 for `10^17`).
- Each `F(·)` evaluation recurses only a few levels because arguments shrink
  from `x` to at most about `3·\sqrt[3]{x}^2`.

This is fast enough in pure Python without external libraries.
