# Project Euler 845 Solution - Prime Digit Sum

<https://projecteuler.net/problem=845>:

* [845.py](845.py)

We want `D(n)`: the *n-th* positive integer whose **sum of decimal digits is prime**, and specifically `D(10^16)`.

## Main techniques used

### 1) Digit-sum dynamic programming (counting)
Instead of scanning integers one by one, we count how many digit strings have a given digit sum.

- Let `counts[L][s]` be the number of length-`L` digit strings (allowing leading zeros) whose digits sum to `s`.
- Transition:
  - Choose the last digit `d` (0â€“9), then the previous `L-1` digits must sum to `s-d`.
  - `counts[L][s] = sum_{d=0..9} counts[L-1][s-d]`.

This gives the full distribution of digit sums for any remaining suffix length.

### 2) Counting valid *L*-digit positive integers
To count *positive integers with exactly `L` digits*, the first digit is restricted to `1..9`.
For each first digit, we add all suffixes whose total digit sum is prime.

This lets us quickly find which digit-length contains the `n`-th valid number.

### 3) Constructing the k-th valid number (lexicographic / digit-by-digit)
Within a fixed length `L`, numeric order matches lexicographic order of digits.

We build the answer left-to-right:

- At each position, try digits in increasing order.
- For a candidate digit `d`, count how many ways the remaining suffix can be filled so that the final digit sum is prime.
- If that count is smaller than `k`, skip those numbers (`k -= count`) and try the next digit.
- Otherwise, fix `d` and continue to the next position.

Because digit sums are bounded (`<= 9*L`), the per-step counting is tiny and the whole construction is fast.

## Notes

- No external libraries are used.
- The program includes `assert`s for the sample values from the problem statement and prints the required result.
