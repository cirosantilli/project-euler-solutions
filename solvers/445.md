# Project Euler 445 Solution - Retractions A

<https://projecteuler.net/problem=445>:

* [445.py](445.py)

This repo contains a standalone solution (`main.py`) for Project Euler problem **445**.

## Key ideas

### 1) Turn the functional condition into arithmetic constraints
For
\[
 f(x) \equiv ax+b \pmod n,
\]

\[
 f(f(x)) \equiv a(ax+b)+b \equiv a^2x + ab + b \pmod n.
\]

Requiring `f(f(x)) ≡ f(x)` for **all** `x` gives two independent conditions:

- \(a^2 \equiv a \pmod n\)  (so \(n \mid a(a-1)\))
- \(ab \equiv 0 \pmod n\)

For a fixed `a`, the number of `b` satisfying `ab ≡ 0 (mod n)` is `gcd(a,n)`.

So
\[
R(n)=\sum_{a^2\equiv a\ (\mathrm{mod}\ n),\ 0<a<n} \gcd(a,n).
\]

### 2) Idempotents modulo `n` are CRT choices (0/1 on each prime power)
If
\(
 n=\prod p_i^{e_i},
\)
then solutions to \(a^2\equiv a\pmod n\) correspond to choosing
`a ≡ 0` or `a ≡ 1` modulo each \(p_i^{e_i}\).
That yields exactly one residue class per subset of primes.

For such an `a`,
\(
\gcd(a,n)=\prod_{p_i^{e_i}\mid a} p_i^{e_i}.
\)
Therefore `R(n)` is the sum of all **unitary divisors** of `n` except `n` itself:

\[
R(n)=\sigma^*(n)-n,\quad \text{where}\quad \sigma^*(n)=\prod_{p^e\parallel n}(1+p^e).
\]

### 3) Reduce the problem to summing `σ*` over binomial coefficients
We need
\(
\sum_{k=1}^{N-1} R\bigl(\binom Nk\bigr)\bmod M
\)
with \(M=10^9+7\).
Using `R(n)=σ*(n)-n` and
\(
\sum_{k=1}^{N-1} \binom Nk = 2^N-2
\),
we compute:

\[
\sum_{k=1}^{N-1} \sigma^*\!\left(\binom Nk\right)\;-
(2^N-2)
\pmod M.
\]

### 4) Walk through `C(N,k)` multiplicatively and update prime exponents
Use the recurrence:

\[
\binom Nk = \binom N{k-1}\cdot \frac{N-k+1}{k}.
\]

For each step we factor `(N-k+1)` and `k`, update the prime exponents of the current binomial coefficient, and update

\[
\sigma^* = \prod (1+p^{e_p}).
\]

To make factoring fast, `main.py` builds a smallest-prime-factor (SPF) table up to `N`.

### 5) Fast modular division with a precomputed inverse table (chunked batch inversion)
Updating `σ*` requires removing an old factor `(1+p^e)` and inserting a new one.
That needs modular inverses of many values of the form `(1+p^e) (mod M)`.

Instead of calling `pow(x, M-2, M)` millions of times, the code:

- precomputes all required `(1+p^e)` values for `e=1..v_p(N!)`
- computes their inverses **in large chunks** using *batch inversion* (one `pow()` per chunk)

A rare corner case is when `(1+p^e) ≡ 0 (mod M)`; then `σ* ≡ 0 (mod M)` and we track a `zero_count` rather than dividing by zero.

### 6) Use symmetry to halve the work
Since \(\binom Nk = \binom N{N-k}\), we have
\(
\sigma^*(\binom Nk)=\sigma^*(\binom N{N-k}).
\)
So we only iterate up to `k = floor(N/2)` and double contributions (except the middle term when `N` is even).

## Files

- `main.py` — computes the required value for `N=10_000_000` and prints it.
  - Includes the assertion from the problem statement:
    `S(100000) ≡ 628701600 (mod 1e9+7)`.
