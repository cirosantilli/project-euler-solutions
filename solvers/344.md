# Project Euler 344 Solution - Silver Dollar Game

<https://projecteuler.net/problem=344>:

* [344.py](344.py)

This solution computes **W(1,000,000, 100) mod 1000036000099** for Project Euler 344 (Silver Dollar Game), without external libraries.

## 1) Rewriting positions as “gaps”

Sort the coins from left to right. Instead of absolute positions, describe the board by the non‑negative **gaps**:

- `g0` = empty squares before the leftmost coin  
- `g1` = empty squares between coin 0 and coin 1  
- …  
- `g_{m}` = empty squares after the rightmost coin (the “tail”)

where `m = c+1` is the number of coins, and the gaps sum to `n - m`.

Moves only slide coins left, so the game is determined by these gaps.

## 2) de Bruijn/Nim reduction for **even** `c`

In Euler 344 we have `c = 100` (even), so `m = c+1` is odd. In this case, de Bruijn’s analysis reduces the game to Nim-like “heaps” made from the **even-indexed gaps**:

```
a0 = g0, a1 = g2, a2 = g4, ... , a_p = g_{2p}    where p = c/2
```

The **odd-indexed gaps** are “free slack” that only affect how many configurations exist, not whether a configuration is losing/winning.

For even `c`, losing positions split into **two** kinds:

- **Type L2:** the silver coin is the **2nd** coin from the left  
  Losing iff `a0 xor a1 xor ... xor a_p = 0`.

- **Type Lother:** the silver coin is any of the other `c-1` non-leftmost coins  
  Losing iff `(a1 xor a2 xor ... xor a_p) = a0 + 1`.

A crucial bijection makes Type `Lother` countable via the same XOR‑0 machinery:
replace `a0` by `b0 = a0 + 1`, then the condition becomes

```
b0 xor a1 xor ... xor a_p = 0  with the constraint b0 >= 1
```

So its sum-distribution is `F_{p+1}[s+1] - F_p[s+1]`.

## 3) Counting: stars-and-bars + XOR‑constrained tuples

Let `S = n - m` be the total number of empty squares to distribute among all gaps.

For a fixed vector of even gaps `A` with sum `sumA`, the number of ways to choose the odd gaps (there are `p+1` of them) is:

```
C((S - sumA) + p, p)
```

(stars and bars).

So we need the distribution:

```
F_q[s] = #{q-tuples of nonnegative ints with XOR == 0 and sum == s}
```

for `q = p+1` and `q = p`.

## 4) Fast computation of F_q[s] by bit recursion

Write each entry as `x = 2u + v` with `v ∈ {0,1}`.

For XOR to be 0, the number of odd entries (`v=1`) must be even. This implies:
- only **even** sums occur, and
- after dividing by 2, the higher bits satisfy the same XOR==0 condition.

This yields a halving recursion on the maximum sum, producing a small convolution:

For `s = 2t`:

```
F_q[2t] = Σ_{j=0..min(q/2, t)} C(q, 2j) * G[t-j]
```

where `G` is the same distribution at half scale. This runs in about `O(q * S)` operations.

## 5) Composite modulus via CRT

The modulus is:

```
1000036000099 = 1000003 × 1000033
```

We:
1. compute the XOR‑sum distributions modulo the composite (safe: only +/*),
2. reduce them modulo each prime,
3. perform the remaining binomial-weighted sums modulo each prime (needs modular inverses),
4. combine the two residues with the Chinese Remainder Theorem.

## 6) Built-in correctness checks

The code includes the problem statement’s given values:

- `W(10, 2) = 324`
- `W(100, 10) = 1514704946113500`

as `assert`s.
