# Project Euler 643 Solution - $2$-Friendly

<https://projecteuler.net/problem=643>:

* [643.py](643.py)

We need the number of pairs `(p, q)` with `1 ≤ p < q ≤ n` such that

- `gcd(p, q)` is a **power of 2** with exponent `≥ 1`.

The answer is required modulo `1_000_000_007`.

---

## 1) Reducing the gcd condition

If `gcd(p, q) = 2^t` with `t ≥ 1`, then we can write

- `p = 2^t · a`
- `q = 2^t · b`

and it follows that `gcd(a, b) = 1`. Also, since `p < q`, we have `a < b`, and the bounds become:

- `1 ≤ a < b ≤ ⌊n / 2^t⌋`.

So for each `t`, the number of valid pairs is exactly the number of **coprime pairs** `(a, b)` with `a < b` up to `m = ⌊n / 2^t⌋`.

---

## 2) Coprime pairs and the totient summatory function

For a fixed `m`, the number of pairs `1 ≤ a < b ≤ m` with `gcd(a, b) = 1` is

- `C(m) = Σ_{b=2..m} φ(b)`

because for each `b`, there are `φ(b)` integers `a < b` that are coprime to `b`.

Let

- `S(m) = Σ_{k=1..m} φ(k)` (the **summatory totient**).

Then

- `C(m) = S(m) - 1` (since `φ(1) = 1`).

Therefore,

- `f(n) = Σ_{t≥1} ( S( ⌊n / 2^t⌋ ) - 1 )`.

Only `O(log n)` terms appear because `⌊n / 2^t⌋` becomes zero.

---

## 3) Fast computation of `S(n)` (Du Jiao sieve idea)

A key identity is:

- `Σ_{d|k} φ(d) = k`

Summing `k = 1..n` and swapping sums gives:

- `Σ_{d=1..n} φ(d) · ⌊n/d⌋ = n(n+1)/2`

Observe that `⌊n/d⌋` counts how many multiples of `d` are ≤ `n`, so we can rewrite it as:

- `Σ_{m=1..n} S( ⌊n/m⌋ ) = n(n+1)/2`

Hence:

- `S(n) = n(n+1)/2 − Σ_{m=2..n} S( ⌊n/m⌋ )`

The values `⌊n/m⌋` take only `O(√n)` distinct values, so we group `m` into ranges where the quotient is constant:

- for `m ∈ [l, r]`, `⌊n/m⌋ = v`, where `v = ⌊n/l⌋` and `r = ⌊n/v⌋`.

This yields an `O(√n)` computation per *new* `n`, and we memoize `S(n)` for large `n` to avoid recomputation.

---

## 4) Precomputation for small values

For all `k ≤ LIMIT` we compute `φ(k)` by a **linear sieve** in `O(LIMIT)` time, then build the prefix sums modulo `MOD`.

Any `S(n)` with `n ≤ LIMIT` is answered in `O(1)` via this table; larger `n` uses the recursive formula above.

---

## Techniques used

- Number-theoretic reduction (`gcd = 2^t` → coprime pairs after scaling)
- Euler’s totient function and summatory totient
- Linear sieve for `φ(1..LIMIT)`
- Du Jiao sieve-style recursion for `S(n)`
- Floor-division grouping (`⌊n/i⌋` constant over intervals)
- Memoization

The implementation in `main.py` includes the problem’s provided test asserts:
`f(10^2)=1031` and `f(10^6)=321418433` (mod `1_000_000_007`).
