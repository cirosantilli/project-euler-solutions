# Project Euler 505 Solution - Bidirectional Recurrence

<https://projecteuler.net/problem=505>:

* [505.py](505.py)

This solution computes `A(10^12)` **exactly** without hard-coding and without external libraries.

## Definitions

Let `M = 2^60` and `C = M - 1`.

Sequence `x(k)`:
- `x(0)=0`, `x(1)=1`
- `x(2k)   = (3x(k) + 2x(floor(k/2))) mod M`
- `x(2k+1) = (2x(k) + 3x(floor(k/2))) mod M`

Tree `y_n(k)`:
- if `k >= n`: `y_n(k) = x(k)`
- else: `y_n(k) = C - max(y_n(2k), y_n(2k+1))`

Target:
- `A(n) = y_n(1)`

Samples (asserted in code):
- `A(4) = 8`
- `A(10) = 2^60 - 34`
- `A(1000) = 101881`

---

## Key Technique 1: Convert to alternating minimax (“s-transform”)

Define:

- if `depth(k)` is even: `s_n(k) = y_n(k)`
- if `depth(k)` is odd : `s_n(k) = C - y_n(k)`

Then the internal recursion becomes:

- even depth: `s_n(k) = min(s_n(2k), s_n(2k+1))`
- odd depth : `s_n(k) = max(s_n(2k), s_n(2k+1))`

So `A(n)=s_n(1)` is the value of a standard **minimax game** on a binary tree.

---

## Key Technique 2: Leaf depths are only `d` and `d+1`

Let `d = floor(log2(n))`.

In the original truncated tree (root at 1), leaves occur exactly at:
- depth `d` (for indices `k` with `n <= k < 2^(d+1)`)
- depth `d+1` (for indices `k` with `2^(d+1) <= k < 2n`)

Thus the game can be terminated at depth `d` using a derived rule:

At depth `d`, for node index `k`:
- If `k >= n`, it is an original leaf: payoff uses `x(k)` (with flip parity of depth `d`).
- If `k < n`, it is not a leaf; its children at depth `d+1` are leaves: payoff comes from `x(2k)` and `x(2k+1)` (with flip parity of depth `d+1`) combined by the depth-`d` operator.

This avoids building a uniform depth tree explicitly and removes boundary checks at the real leaves.

---

## Key Technique 3: Compute `x` incrementally along the game tree

Maintain state `(a,b) = (x(k), x(floor(k/2)))`.

Then:
- child `2k` has `a0 = (3a + 2b) mod M`, next state `(a0, a)`
- child `2k+1` has `a1 = (2a + 3b) mod M`, next state `(a1, a)`

So each descent step costs only a few integer operations.

---

## Key Technique 4: Principal Variation Search (PVS)

A naive minimax expansion is impossible at depth ~40.

We use **exact alpha–beta pruning**, specifically **Principal Variation Search**:

- first child searched with full window `[alpha, beta]`
- second child searched with a null window (`[alpha, alpha+1]` for MAX, `[beta-1, beta]` for MIN)
- only if it “fails high/low” do we re-search with the full window

This dramatically reduces explored nodes while remaining exact.

---

## Run

```bash
python3 main.py
