# Project Euler 251 Solution - Cardano Triplets

<https://projecteuler.net/problem=251>:

* [251.py](251.py)

This repository contains a fast, pure-Python solution (standard library only) for counting **Cardano triplets** `(a, b, c)` with `a + b + c â‰¤ N`, where:

\[
\sqrt[3]{a + b\sqrt{c}} + \sqrt[3]{a - b\sqrt{c}} = 1
\]

The code avoids floating-point root evaluation and instead uses integer arithmetic throughout.

## Main ideas

### 1) Convert the radical equation into an integer identity

Let:

- \(u = \sqrt[3]{a + b\sqrt{c}}\)
- \(v = \sqrt[3]{a - b\sqrt{c}}\)

Then \(u + v = 1\). Cubing and using \(u^3 + v^3 = 2a\) yields an expression involving \(uv\), and since:

\[
uv = \sqrt[3]{(a + b\sqrt{c})(a - b\sqrt{c})} = \sqrt[3]{a^2 - b^2c},
\]

you can eliminate cube roots entirely and obtain the integer condition:

\[
27\,b^2c = (a+1)^2(8a-1).
\]

This is used both for validation of the sample triplet and as the starting point for parametrisation.

### 2) Reduce to a structured factor form

From the divisibility in the previous identity, \(a\) must satisfy \(a \equiv 2 \pmod 3\). Write:

\[
a = 3k - 1 \quad (k \ge 1).
\]

Substituting simplifies the right-hand side and gives:

\[
b^2c = k^2(8k - 3).
\]

So for each \(k\), we are looking for ways to write \(k^2(8k-3)\) as a square times another integer, under the sum limit.

### 3) A gcd split removes duplicates and exposes a Diophantine constraint

Let \(p = \gcd(k, b)\), and write:

- \(k = pq\)
- \(b = pr\)
- \(\gcd(q, r) = 1\)

Plugging into \(b^2c = k^2(8k-3)\) forces \(q^2\) to divide \(c\) and \(r^2\) to divide \(8pq - 3\). So we can write:

- \(c = s q^2\)
- \(8pq = s r^2 + 3\)

This representation is unique when \(\gcd(q,r)=1\), so counting these parameter tuples counts triplets without overcounting.

### 4) Solve the congruence with modular inverses

For fixed coprime `(q, r)` with `r` odd, the condition:

\[
8pq \equiv 3 \pmod{r^2}
\]

has a solution because \(\gcd(8q, r^2)=1\). The smallest positive solution \(p_0\) is found via a modular inverse, and then all solutions form an arithmetic progression:

- \(p = p_0 + r^2 t\)
- \(s = s_0 + 8q t\)

### 5) Count solutions per `(q, r)` using an arithmetic progression inequality

The sum constraint becomes:

\[
a+b+c = p(3q+r) + s q^2 - 1 \le N.
\]

After substituting the progression for \(p\) and \(s\), this turns into:

\[
\text{base} + t\cdot \text{step} \le N+1,
\]

so the number of valid \(t\) is a single integer division. This avoids generating divisors or factoring large numbers.

## How to run

```bash
python3 main.py
```

Optional: provide a different limit `N`:

```bash
python3 main.py 1000000
```

The program includes asserts for the test values explicitly stated in the problem statement.
