# Project Euler 678 Solution - Fermat-like Equations

<https://projecteuler.net/problem=678>:

* [678.py](678.py)

We count tuples `(a,b,c,e,f)` of positive integers such that:

- `0 < a < b`
- `e >= 2`, `f >= 3`
- `c^f <= N`
- `a^e + b^e = c^f`

The function is `F(N) = #tuples`, and the target is `F(10^18)`.

---

## Main techniques

### 1) Enumerate perfect powers with multiplicity
We enumerate all values `n = c^f <= N` for `f >= 3`, `c >= 2`.

A number can appear multiple ways (e.g. `64 = 2^6 = 4^3`), and **each distinct `(c,f)` is a distinct tuple**.
So we store:

- `mult[n]` = number of `(c,f)` representations with `f>=3`
- a representative `(c,f)` per `n` for factor-based formulas

---

### 2) `e = 2`: sum of two squares
For each perfect power `n`, we count the number of solutions to `a^2 + b^2 = n`.

Using the classical theorem:

- If any prime `p â‰¡ 3 (mod 4)` has an **odd** exponent in `n`, there are no representations.
- Otherwise the number of ordered integer solutions is

\[
r_2(n) = 4 \prod_{p \equiv 1\ (mod\ 4)} (E_p+1),
\]

where `E_p` is the exponent of `p` in `n`.

We convert `r2(n)` to the count of solutions with `0 < a < b` by removing axis/diagonal solutions and dividing by 8.

---

### 3) `e = 3`: sum of two cubes via divisor reconstruction
For `a^3 + b^3 = n` we use

\[
a^3+b^3 = (a+b)(a^2-ab+b^2).
\]

Let `s = a+b`. Then `s | n`, and with `q = n/s` we have:

\[
q = s^2 - 3ab.
\]

This yields a quadratic for `(a,b)` whose discriminant must be a perfect square; that lets us reconstruct `(a,b)` by scanning divisors `s` up to `2*n^{1/3}`.

If `n` is a perfect cube then `a^3+b^3=d^3` would violate FLT for positive integers, so cubes are skipped.

---

### 4) `e = 4`: two subcases

**(a) RHS has some exponent `f >= 5`.**  
There are very few such values `n`, so we can test `n` as `a^4 + b^4` by iterating `a` and looking up whether `n-a^4` is a 4th power.

**(b) RHS is a cube but not a higher perfect power.**  
This rare case is found by searching for `a^4+b^4` that are perfect cubes.

A direct double loop over `a,b <= N^{1/4}` is too big, so we use **modular filtering** with a modulus

\[
M = 5 \cdot 7 \cdot 13 \cdot 19 = 8645.
\]

Only a small fraction of sums of two 4th powers are cubic residues mod `M`, so we pre-group `b` values by `b^4 mod M` and only test residue-compatible pairs. Remaining candidates are verified with an integer cube-root check.

---

### 5) `e >= 5`: brute force
For `e >= 5`, the base limit `N^{1/e}` becomes small very quickly (e.g. about 3981 for `e=5`), so brute forcing pairs `(a,b)` and checking membership in `mult` is feasible.

---

## Notes
- Only Python standard library is used.
- The sample values from the statement are asserted in `main.py`.
