# Project Euler 825 Solution - Chasing Game

<https://projecteuler.net/problem=825>:

* [825.py](825.py)

This repo contains a **pure-Python** solution (no third‑party libraries) for Project Euler 825.

`main.py` prints `T(10^14)` rounded to **8 digits after the decimal point**, and includes `assert`s
for the example values given in the problem statement.

## Core techniques

### 1) Markov chain with a single “distance” state
At the start of a player’s turn, let `d` be the forward distance (along the circular track) from the
current player to the other car.

- Track length is `2n`, so `d ∈ {1, …, 2n−1}`.
- If the current player rolls `r ∈ {1,2,3}` and `r ≥ d`, they catch and win immediately.
- Otherwise turns swap, and the opponent sees a new distance `d' = 2n − (d − r)`.

If `f(d)` is “probability the **current mover** eventually wins”, then for `d ≥ 4`:

```
f(d) = 1 − ( f(2n−d+1) + f(2n−d+2) + f(2n−d+3) ) / 3
```

The quantity asked for in the problem can be expressed from `f(n)`.

### 2) Convert the reflection relation into a constant-coefficient recurrence
Composing the above reflection relation with itself yields a **4th‑order linear recurrence** in the
interior region.

Its characteristic polynomial factors into a double root at `1` and two more roots
`-2 ± √3`. Therefore interior solutions are a combination of:

- a linear term (`A + B d`) from the double root at `1`, and
- two geometric terms (`q^d` and `q^(2n−d)`) where `q = -2 + √3`.

So for `d ≥ 2` we can write:

```
f(d) = A + B d + C q^d + E q^(2n − d)
```

The constants are determined by four **exact boundary equations** coming from the game rules
near `d=2,3` (where immediate capture is possible) and near `d=2n−2,2n−1`.
This becomes a small **4×4 linear system**, solved with straightforward Gaussian elimination.

### 3) Fast summation using a shifted harmonic term
`T(N) = Σ S(n)` is huge when `N = 10^14`, so the code avoids summing term-by-term.

From the root structure above, the non-harmonic part of `S(n)` decays geometrically (powers of `q`).
One can separate:

- a dominant shifted harmonic term `1/(n−1+c)` with `c = (3 − √3)/6`, and
- a rapidly converging correction constant
  `K = Σ_{n=2..∞} ( S(n) − 1/(n−1+c) )`.

Then:

```
T(N) = ( Σ_{n=2..N} 1/(n−1+c) ) + K
```

`K` is computed accurately by summing only up to a modest cutoff (the remainder is tiny).

### 4) Evaluate the shifted harmonic sum via digamma
The shifted harmonic sum is computed as:

```
Σ_{n=2..N} 1/(n−1+c) = ψ(N+c) − ψ(1+c)
```

where `ψ` is the **digamma** function.

The implementation computes `ψ(x)` for `x>0` using:

- recurrence `ψ(x) = ψ(x+1) − 1/x` to move to a safe large `x`, and
- an asymptotic Bernoulli expansion for large `x`.

This is easily accurate enough for 8 decimal places at `N = 10^14`.

## Running

```bash
python3 main.py
```

Optionally override `N`:

```bash
python3 main.py 1000000
```
