# Project Euler 483 Solution - Repeated Permutation

<https://projecteuler.net/problem=483>:

* [483.py](483.py)

This repository contains a pure-Python solution (no external libraries) for Project Euler 483.

## Key ideas

### 1) Cycle-type counting for permutations
Every permutation can be written as a product of disjoint cycles. If it has `a_i` cycles of length `i`, then:

- The permutation’s order is the least common multiple of the cycle lengths:  
  `order = lcm({ i : a_i > 0 })`.
- The number of permutations with this cycle structure is:  
  `n! / ∏ (a_i! · i^{a_i})`.

After dividing by `n!`, the expected value becomes a weighted sum over all cycle-count vectors `(a_i)` with
`∑ i·a_i = n`:

`g(n) = Σ lcm({i : a_i>0})^2 / ∏ (a_i! · i^{a_i})`.

So we only need to enumerate cycle *types* (partitions with multiplicities), not permutations.

### 2) DP over cycle lengths, multiplicities via a factorial recurrence
We do dynamic programming over cycle lengths `i`, choosing how many `i`-cycles to use.

For multiplicity `a ≥ 1`, the weight factor contributed by those cycles is:

`1 / (a! · i^a)`.

Instead of precomputing factorials, we build the terms iteratively:

- for `a = 1`: multiply by `1 / i`
- for each next `a`: divide by `(a · i)`

This yields `v / (a! · i^a)` with only a few floating operations per `a`.

### 3) Keeping the LCM state small by extracting prime-power contributions
A naive DP would keep the full current LCM in the state, which explodes in size.

We process cycle lengths **from `n` down to `1`**. When we move below a prime power `p^k`,
it is **impossible** for any remaining (smaller) cycle length to contribute exponent `k` of `p` to the LCM.
So that part of the final LCM is already decided.

Crucial detail: we *don’t* remove `p^k` all at once, because smaller lengths can still contain smaller powers
of `p` and would incorrectly change future LCM computations if we erased `p` entirely.

Instead, when crossing `p^k`, we do:

- If the tracked LCM is divisible by `p^k`, multiply the running contribution by `p^2`
  (locking in one factor `p` in the final `LCM^2`),
- Divide the tracked LCM by `p` (reducing the exponent by exactly 1).

Repeating this as `k` decreases strips prime exponents one-by-one, merging many states while preserving correctness.

### 4) Output formatting
The required output is scientific notation with **10 significant digits** and the exponent written without `+`
or leading zeros (matching the examples).

## Complexity (high level)
- The DP is over `i = n…1` and `used = 0…n` with a sparse dictionary of LCM states per `used`.
- Prime-power extraction dramatically reduces the number of distinct LCM states that must be tracked.
- This avoids brute force over permutations and keeps runtime practical in Python.
