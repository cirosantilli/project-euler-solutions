# Project Euler 680 Solution - Yarra Gnisrever

<https://projecteuler.net/problem=680>:

* [680.py](680.py)

This solution computes **R(N, K)** for the sequence of Fibonacci-driven reversal operations, and prints  
`R(10^18, 10^6) mod 10^9`.

## Key ideas

### 1) View the array as a permutation (a rope)
The array starts as `A[i] = i`, so it is the identity permutation of `0..N-1`.

Each operation reverses a contiguous **range of positions**. If you store the whole array, reversing is expensive
and impossible for `N = 10^18`.

Instead, store the current array as a *rope* (a sequence) built from **segments**:
each segment represents an arithmetic progression with step `+1` or `-1`, e.g.

- increasing segment: `start, start+1, ..., start+L-1`
- decreasing segment: `start, start-1, ..., start-(L-1)`

Reversing a subrange only cuts at its endpoints, reverses the middle, and joins back.

### 2) Implicit treap (balanced rope) with lazy reversal
The rope is stored in an **implicit treap**:

- In-order traversal gives the elements in position order.
- Each node holds one arithmetic-progression segment.
- `split(root, k)` splits by *position count* (first `k` elements vs the rest).
- `merge(a, b)` concatenates two treaps.

Range reversal `[l, r]` is implemented as:

1. `split(root, l)` → `(left, rest)`
2. `split(rest, r-l+1)` → `(mid, right)`
3. lazily reverse `mid`
4. `merge(left, mid)` then `merge(..., right)`

Lazy reversal:
- swaps children,
- flips the node segment direction,
- adjusts precomputed aggregates in **O(1)**.

### 3) Maintain the target sum by subtree aggregates
We need:

\[
R(N,K) = \sum_{i=0}^{N-1} i \cdot A[i]
\]

The treap stores per-subtree aggregates:

- `sum_val` = \(\sum A[i]\)
- `sum_pos` = \(\sum i \cdot A[i]\) (with positions measured from the subtree start)

These let us recompute the global answer from the root in `O(1)` after all operations.

### 4) Fast arithmetic-progression formulas (no modular inverses)
For a segment `value_k = start + dir*k`:

- \(\sum value_k\)
- \(\sum k \cdot value_k\)

are computed from triangular and square-sum formulas.
For the final problem we only need everything **mod 10^9**, and since `10^9` is not prime,
the implementation avoids modular inverses by dividing by `2` and `3` *before* taking the modulo.

### 5) Fibonacci endpoints in O(K)
Endpoints are:

- `s_j = F_{2j-1} mod N`
- `t_j = F_{2j} mod N`

We generate Fibonacci values iteratively and advance by 2 steps per operation.

## Complexity

- Each reversal is `O(log M)` splits/merges, where `M` is the number of segments (≤ ~2K+1).
- Total time: **O(K log K)**
- Memory: **O(K)** segments.

This makes `K = 10^6` feasible even when `N = 10^18`.
