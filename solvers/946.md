# Project Euler 946 Solution - Continued Fraction Fraction

<https://projecteuler.net/problem=946>:

* [946.py](946.py)

This solution computes the sum of the first \(10^8\) coefficients of the continued fraction of

\[
\beta = \frac{2\alpha+3}{3\alpha+2}
\]

where \(\alpha\) has continued fraction digits made from prime-length runs of `1` separated by `2`.

## Techniques used

### 1) Homographic (linear fractional) continued-fraction “spigot”
A Möbius transform of the form

\[
y = \frac{A x + B}{C x + D}
\]

can be combined with continued fractions by maintaining the integer matrix \(\begin{pmatrix}A & B\\ C & D\end{pmatrix}\).

We read the continued-fraction digits of \(x\) (here: \(\alpha\)) one at a time. After each input digit is consumed, we repeatedly **extract** output digits of \(y\) (here: \(\beta\)) whenever they are forced.

For regular continued fractions, the remaining tail satisfies \(x \ge 1\). That allows a safe extraction check by comparing the integer parts at the endpoints \(x=1\) and \(x=\infty\). If the floors match, the next continued-fraction coefficient of \(y\) is determined.

### 2) Stable-state finite transducer
After each consumed input digit, we “flush” all extractable output digits. That means the computation is always at a **stable** point between inputs.

Empirically (and in this problem), the homography update keeps the matrix entries small and only a small number of stable states are reachable. So the process behaves like a finite-state transducer driven by input symbols `{1, 2}`:
- transition(state, 1) → (new_state, emitted_digits)
- transition(state, 2) → (new_state, emitted_digits)

### 3) Binary lifting to skip long runs of `1`
The continued fraction of \(\alpha\) contains very long runs of `1` (their lengths are consecutive primes). Iterating one digit at a time would be too slow.

Because the `1`-transition is a deterministic state transition that emits a known count/sum of output digits, we precompute doubling tables:

- applying `1` exactly \(2^k\) times from any state
- total number of emitted \(\beta\)-digits during that block
- total sum of those emitted digits

Then we can process a run of length `p` in \(O(\log p)\) time.

### 4) “Finish near the end” digit-by-digit
A single consumed input digit can (rarely) emit two output digits. To avoid edge cases when we are very close to the \(10^8\)-th digit, we stop the fast-skipping slightly early and finish the last couple thousand outputs with the straightforward digit-by-digit spigot.

## Correctness check from the statement
The code asserts the statement’s sample:
- first 10 coefficients of \(\beta\) are `[0;1,5,6,16,9,1,10,16,11]`
- their sum is `75`

The final answer is computed and printed (not hard-coded).
