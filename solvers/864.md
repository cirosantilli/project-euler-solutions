# Project Euler 864 Solution - Square + 1 = Squarefree

<https://projecteuler.net/problem=864>:

* [864.py](864.py)

This repo contains a pure-Python (standard library only) solution.
The program computes and prints the required value; it does **not** embed or assert the final numeric answer.

## Core ideas

### Mobius inversion over square divisors
An integer `m` is squarefree iff no square `d^2 > 1` divides it. The indicator can be written as:

\[
1_{\text{squarefree}}(m) = \sum_{d^2 \mid m} \mu(d)
\]

Apply to `m = x^2 + 1` and swap sums:

\[
C(n) = \sum_{x=1}^n \sum_{d^2 \mid x^2+1} \mu(d)
    = \sum_{d \ge 1} \mu(d)\,A_d(n)
\]

where `A_d(n)` counts `x <= n` such that `x^2 == -1 (mod d^2)`.

Only **squarefree** `d` whose odd prime factors satisfy `p == 1 (mod 4)` contribute.
(For `p == 3 (mod 4)`, `-1` is not a residue; for `2`, `4` never divides `x^2+1`.)

### Counting `A_d(n)` using CRT
For each prime `p == 1 (mod 4)`, there are exactly **two** solutions to `x^2 == -1 (mod p^2)`.
For a squarefree product `d = p1*p2*...*pk`, CRT combines the choices, giving `2^k` solutions modulo `d^2`.
Counting solutions up to `n` is arithmetic over each residue class.

### Fast square root of `-1 (mod p)`
For `p == 1 (mod 4)`, pick a quadratic non-residue `g (mod p)`.
Euler's criterion gives `g^((p-1)/2) == -1 (mod p)`, hence:

\[
r = g^{(p-1)/4} \pmod p\quad\Rightarrow\quad r^2 \equiv -1 \pmod p.
\]

The code finds such a `g` by trying `2,3,4,...` (usually quickly), then Hensel-lifts
the root from `mod p` to `mod p^2`.

### Truncation at `D` and an exact tail correction
The implementation computes the Mobius/CRT sum only for `d <= D`.

For a given `x`, write:

\[
x^2+1 = k y^2\quad\text{with }k\text{ squarefree}.
\]

Then `d^2 | x^2+1` iff `d | y`, so the truncated sum misses exactly:

\[
\sum_{d\mid y,\ d>D} \mu(d).
\]

When `y > D`, the representation corresponds to the negative Pell equation:

\[
x^2 - k y^2 = -1.
\]

Also, `y > D` implies:

\[
k \le \left\lfloor \frac{n^2+1}{D^2}\right\rfloor,
\]

so only finitely many `k` must be considered.

## Speed upgrade: bounded continued fractions for negative Pell
A naive negative-Pell solver computes the full continued-fraction period of `sqrt(k)` for every `k`.
But we only need solutions with `x <= n`.

Convergent numerators `p_i` grow strictly, so as soon as `p_i > n`, the minimal possible
solution (if it exists) is already too large to contribute, and we can stop early.
This typically saves a large fraction of Pell work in pure Python.

## Running

```bash
python3 main.py
```

Optionally choose a different truncation bound:

```bash
python3 main.py 50000000
```

## Statement checks
The program includes assertions for the given examples:

- `C(10) = 9`
- `C(1000) = 895`
