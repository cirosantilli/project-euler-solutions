# Project Euler 939 Solution - Partisan Nim

<https://projecteuler.net/problem=939>:

* [939.py](939.py)

This solution avoids brute-force game solving by reducing the game to simple integer statistics of integer partitions.

## 1) Game-theoretic reduction (Combinatorial Game Theory)

Each pile is a **partizan** component:

- On **your own side**, you may remove the whole pile.
- On the **opponent’s side**, you may remove a single stone.

Using standard CGT decomposition, a pile of size `n` on a given side can be expressed (up to equivalence) as:

- an integer multiple of Conway’s infinitesimal **up** (`↑`), plus
- possibly one **star** (`*`) depending on whether `n` is odd.

For a partition (multiset of pile sizes) on one side, only two aggregate values matter:

- `v = sum(pile_size - 1) = total_stones - number_of_piles`
- `r = parity( number_of_odd_piles )` (0 for even, 1 for odd)

For a full setting (A-side partition, B-side partition), define:

- `M = v_A - v_B`
- `S = r_A XOR r_B`

Then **A wins regardless of who starts** iff:

- if `S = 0`, then `M ≥ 1`
- if `S = 1`, then `M ≥ 2`

So the original game question becomes a **counting problem** over partitions.

## 2) Counting partitions by `(n, k, odd-parity)`

We need counts of partitions of a number `n` into `k` parts, tracking the parity of the number of odd parts.

Let `f[n][k][r]` be that count. There is a classic recurrence:

- Split partitions by whether they contain a `1`:

  - Remove a part `1`: transforms `(n, k)` → `(n-1, k-1)` and **toggles** odd-parity.
  - Subtract `1` from each part (only if all parts ≥ 2): transforms `(n, k)` → `(n-k, k)` and
    flips odd-parity iff `k` is odd.

This gives:

`f[n,k,r] = f[n-1,k-1,r^1] + f[n-k,k,r^(k&1)]`

The solution computes these values in **O(N²)** time.

## 3) Flattened storage and the `v = n - k` statistic

The win condition uses `v = n - k`, so for each `n` we accumulate counts directly into arrays indexed by `(n, v, r)`.
A triangular flattening stores all `0 ≤ v ≤ n ≤ N` compactly.

## 4) Efficient pairing under the `a + b ≤ N` constraint

A setting has total stones `a + b ≤ N`.

The implementation iterates `m = 0..N`, where `m` is the maximum allowed stones on B’s side, and pairs it with `a = N - m`.
It maintains cumulative counts of all B-partitions with `b ≤ m`, and uses prefix sums over `v_B` to answer constraints of the form:

- `v_B ≤ v_A - 1` or `v_B ≤ v_A - 2`

in O(1) per `(v_A, r_A)`.

Overall complexity is **O(N²)** time and **O(N²)** space for the partition-statistics table (stored compactly), and O(N) extra working space.
