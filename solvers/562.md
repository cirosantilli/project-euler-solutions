# Project Euler 562 Solution - Maximal Perimeter

<https://projecteuler.net/problem=562>:

* [562.py](562.py)

This note explains the main ideas used in `main.py` (no external libraries).

## Fixed area from lattice conditions

The triangle’s vertices are lattice points, and the triangle must contain **no other** lattice points (neither inside nor on edges).  
Pick’s theorem says:

- `Area = I + B/2 - 1`

Here `I = 0` and `B = 3`, so every valid triangle has:

- `Area = 1/2`

## Unimodular vectors

Let:

- `u = B - A`
- `v = C - A`

Then:

- `Area = |det(u, v)| / 2`

So `Area = 1/2` forces:

- `|det(u, v)| = 1`

This implies the three edges are *primitive* (contain no other lattice points) automatically.

## Why we focus on a near-diameter base

With a fixed area, the maximizing perimeter occurs when one side is extremely long (close to `2r`).  
So the search is driven by finding a very long *primitive* segment `AB` inside the disk.

## Boundary points and “deficit” filter

For each integer `y`, define the rightmost lattice point in the disk:

- `p(y) = (x(y), y)` where `x(y)^2 + y^2 <= r^2` and `x(y)` is maximal.

A near-diameter chord can be formed by choosing endpoints:

- `B = p(i)` and `A = -p(j)`

so the base direction is:

- `u = B - A = p(i) + p(j)`

To keep the candidate set small, we only keep boundary points with small:

- `deficit(y) = r^2 - x(y)^2 - y^2`

The code uses `deficit <= 8000`, which is enough for the target input and includes all points for small radii.

Among the filtered points, we select the *longest primitive* base vector `u`, meaning:

- `gcd(u.x, u.y) = 1`

## Constructing the third vertex with extended gcd

From `det(u, v) = 1`, we need a vector `v`.

If extended gcd provides `s, t` with:

- `u.x * s + u.y * t = 1`

then:

- `v0 = (-t, s)` satisfies `det(u, v0) = 1`

All solutions are:

- `v = ±v0 + k*u` for integer `k`

The program determines which `k` values keep `C = A + v` inside the circle, and among feasible options chooses the one with the largest perimeter.

## Exact rounding for the final output

With `Area = 1/2`, the circumradius is:

- `R = a*b*c / 2`

Using squared side lengths `s1, s2, s3`:

- `R^2 = (s1*s2*s3) / 4`
- `T(r)^2 = R^2 / r^2 = (s1*s2*s3) / (4*r^2)`

`T(r)^2` is rational. The program rounds `T(r)` to the nearest integer using **only integer arithmetic**, avoiding floating-point edge cases.

## Built-in checks

The code asserts the statement’s sample values:

- the exact `T(5)^2` fraction (via the side-length product),
- approximations for `T(10)` and `T(100)`.
