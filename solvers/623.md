# Project Euler 623 Solution - Lambda Count

<https://projecteuler.net/problem=623>:

* [623.py](623.py)

This repository solves Project Euler **Problem 623**: counting distinct **closed**
lambda-terms up to a given symbol budget, modulo **1,000,000,007**.

---

## Key Ideas

### 1) Alpha-equivalence → de Bruijn indices
Alpha-equivalent lambda terms differ only in variable names.  
Switching to **de Bruijn indices** eliminates renaming ambiguity and makes each
alpha-equivalence class have exactly one representation.

---

### 2) Context-sensitive counting with `k` bound variables
Let `T[k][n]` represent the number of lambda terms of **exact symbol size** `n`
that are valid in a context where **k bound variables are available**.

Grammar (size weights):
- variable: `1`
- application `(M N)`: `2 + size(M) + size(N)`
- abstraction `(λx.M)`: `5 + size(M)`

This yields the generating-function identity:

\[
T_k = k z + z^5 T_{k+1} + z^2 T_k^2
\]

Closed terms correspond to `k = 0`.

---

### 3) Remove the shifted quadratic using `U_k = z^2 T_k`
Define:

\[
U_k = z^2 T_k
\]

Then:

\[
U_k = U_k^2 + k z^3 + z^5 U_{k+1}
\]

So `U_k` is the “Catalan solution” of a quadratic series.

---

### 4) Square root via Newton **inverse square root**
We need:

\[
U_k = \frac{1 - \sqrt{1 - 4X_k}}{2}
\]

Instead of computing a square root with polynomial inversion, we compute
the **inverse square root** using Newton’s iteration:

\[
g \leftarrow g \cdot \frac{3 - R g^2}{2}
\]

where \(g \approx R^{-1/2}\), and finally:

\[
\sqrt{R} = R \cdot g
\]

This avoids expensive polynomial division.

---

### 5) Very fast polynomial multiplication (Kronecker substitution)
All polynomial multiplications are done modulo `1e9+7` using a trick:

- Pack coefficients into a giant integer in base \(2^{80}\)
- Multiply integers using Python’s highly-optimized big-int arithmetic
- Extract coefficients by bit shifting (safe because base is chosen so
  **no carries occur**)

This is often faster than an FFT in pure Python.

---

### 6) Depth-aware truncation
A term at depth `k` must pass through `k` abstractions to affect `U_0`,
and each abstraction adds `5` symbols.

So for target max degree `D`, only degrees up to:

\[
D_k = D - 5k
\]

are needed in `U_k`.  
This shrinks the work dramatically for large `k`.

---

## Output
The program prints:

\[
\Lambda(2000) \bmod 1\,000\,000\,007
\]

and includes asserts validating the statement’s test values:

- Λ(6) = 1  
- Λ(9) = 2  
- Λ(15) = 20  
- Λ(35) = 3166438

---

## Result
**Λ(2000) mod 1,000,000,007 = 3679796**
