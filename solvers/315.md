# Project Euler 315 Solution - Digital Root Clocks

<https://projecteuler.net/problem=315>:

* [315.py](315.py)

This repo contains a fast Python solution for **Project Euler 315**.

## Key ideas

### 1) 7‑segment digits as bitmasks
Each digit `0..9` is encoded as a 7‑bit mask (one bit per segment). A whole number is encoded by packing digit masks into bytes (8 bits per digit) and concatenating them **right‑aligned** (least significant digit in the lowest byte).

Benefits:
- **Segments lit** = `bit_count(mask)`
- **Segments that change** between displays = `bit_count(mask_a ^ mask_b)`

### 2) Sam vs Max transitions
- **Sam** blanks the entire display between every intermediate value, so each shown number costs:
  
  `2 * bit_count(segments(number))`  (turn on + turn off)

- **Max** only toggles segments that differ between consecutive values:
  
  `bit_count(segments(prev) ^ segments(next))`

  plus the initial “turn on from blank” and the final “turn off to blank”.

### 3) Precomputing the digital‑sum tail (≤ 72)
All primes in the target interval are **8 digits**, so their first digit sum is at most `8*9 = 72`. After the first step, the sequence stays within small numbers.

We precompute for every `v ∈ [0,72]`:
- `sam_small[v]`: Sam’s total transitions to show the full chain starting from blank.
- `max_small_displayed[v]`: Max’s transitions to finish the chain **assuming `v` is already correctly displayed**.

Then for each prime `p` we only need:
- `seg_p = segments(p)`
- `sd = digit_sum(p)`
- A constant number of `bit_count()` operations and table lookups.

### 4) Fast prime generation (odd‑only sieve)
Primes up to `2×10^7` are generated using an **odd‑only sieve** backed by a `bytearray` and fast slice assignment to cross off multiples.

This keeps memory low and marking operations in optimized C code.

## Correctness checks
The code includes `assert` tests for the values explicitly given in the problem statement (segment counts and the worked example for `137`).
