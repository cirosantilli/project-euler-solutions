# Project Euler 548 Solution - Gozinta Chains

<https://projecteuler.net/problem=548>:

* [548.py](548.py)

We need the sum of all `n ≤ 10^16` such that `g(n) = n`, where `g(n)` is the number of **gozinta chains**:

`{1, a, b, …, n}` with each element properly dividing the next.

## Main ideas used

### 1) Chains ⇔ ordered factorizations
Given a chain `1=a0 < a1 < … < ak=n`, define ratios:

`r_i = a_i / a_{i-1}`  (each `r_i > 1`), and `r_1 r_2 … r_k = n`.

So counting chains is the same as counting **ordered factorizations** of `n` into integers `> 1`.
This yields the useful recurrence:

`g(1)=1` and for `n>1`:

`g(n) = Σ g(d)` over all proper divisors `d` of `n`.

### 2) `g(n)` depends only on the prime signature
If `n = ∏ p_i^{a_i}`, divisors correspond to exponent vectors `(e_i)` with `0 ≤ e_i ≤ a_i`.
Therefore, the number of divisor-chains from `1` to `n` depends only on the multiset of exponents
`(a_i)` (the **prime signature**), not on the prime values themselves.

So we compute:

`g(signature)` and then test whether the resulting integer has the same signature.

### 3) Counting chains via inclusion–exclusion over “empty steps”
A chain is equivalent to splitting the exponent vector into `m` **nonempty** increment steps
(a step must increase at least one prime exponent).

For a fixed number of steps `m`, we count all step-splits (stars-and-bars per prime),
then subtract splits with at least one empty step using inclusion–exclusion.
This gives an `O(S^2 * k)` method for a signature with
`S = sum(exponents)` and `k = number of primes`.

In this problem, we can cap `S`:

For fixed `S`, the smallest `g` happens at a prime power: `g(p^S)=2^(S-1)`.
If `g(n)=n ≤ 10^16`, then `2^(S-1) ≤ 10^16`, hence `S ≤ 54`.

### 4) Search over signatures, not integers
We enumerate **all exponent signatures** with:

- `sum(exponents) ≤ 54`, and
- the minimal number for that signature (assign smallest primes in order) is `≤ 10^16`.

This pruning leaves only ~17k signatures to examine.

For each signature:

1. compute `g(signature)` (stop early if it exceeds `10^16`)
2. factor `g(signature)` and compare its signature to the current signature
3. if they match, `g(signature)` is a solution

### 5) Fast factorization (no external libraries)
To compare signatures, we factor numbers up to `10^16` using:

- deterministic Miller–Rabin primality test for 64-bit integers
- Pollard Rho for finding nontrivial factors
- a small-prime trial division prefix for speed

## Sanity checks included
The code asserts the sample values from the prompt:

- `g(12)=8`
- `g(48)=48`
- `g(120)=132`
