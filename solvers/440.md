# Project Euler 440 Solution - GCD and Tiling

<https://projecteuler.net/problem=440>:

* [440.py](440.py)

This repository contains a standalone (no third‑party libraries) solver for **Project Euler 440: “GCD and Tiling”**.

The goal is to compute:

\[
S(L)=\sum_{1\le a,b,c\le L}\gcd(T(c^a),T(c^b))
\quad\text{and output}\quad
S(2000)\bmod 987898789.
\]

## 1) Turning tilings into a Lucas sequence

The tilings satisfy:

- A leading **1×1** tile has **10** digit choices, leaving a board of length *n−1*.
- A leading **1×2** domino has **1** choice, leaving *n−2*.

So:

- \(T(0)=1\)
- \(T(1)=10\)
- \(T(n)=10T(n-1)+T(n-2)\)

Define the Lucas **U-sequence** with parameters \((P,Q)=(10,-1)\):

- \(U_0=0,\;U_1=1\)
- \(U_n = P U_{n-1} - Q U_{n-2} = 10U_{n-1}+U_{n-2}\)

Then:

\[
T(n)=U_{n+1}.
\]

## 2) Using a “strong divisibility” GCD property

For Lucas U-sequences with \(Q=\pm1\), a key property holds:

\[
\gcd(U_m,U_n)=U_{\gcd(m,n)}.
\]

Therefore:

\[
\gcd(T(x),T(y))=\gcd(U_{x+1},U_{y+1})=U_{\gcd(x+1,y+1)}.
\]

In our problem \(x=c^a,\;y=c^b\), so we need \(\gcd(c^a+1,c^b+1)\).

## 3) Simplifying \(\gcd(c^a+1,c^b+1)\) with parity

Let \(g=\gcd(a,b)\) and \(a'=a/g,\;b'=b/g\). A standard identity gives:

- If **both** \(a'\) and \(b'\) are **odd**:
  \[
  \gcd(c^a+1,c^b+1)=c^g+1.
  \]
- Otherwise the gcd collapses to a tiny value:
  \[
  \gcd(c^a+1,c^b+1)=\gcd(c^g+1,2)=
  \begin{cases}
  1 & c\text{ even}\\
  2 & c\text{ odd}
  \end{cases}
  \]

So almost all pairs \((a,b)\) contribute only \(U_1=1\) or \(U_2=10\); the “interesting” part is when the reduced exponents are both odd.

## 4) Counting the “odd coprime” pairs with Möbius inversion

For a fixed \(g\), write \(a=gx,\;b=gy\). Then:

- \(1\le x,y\le \lfloor L/g\rfloor\)
- \(\gcd(x,y)=1\)
- \(x,y\) must be **odd**

Let:

\[
f(n)=\#\{(x,y):1\le x,y\le n,\;x,y\ \text{odd},\;\gcd(x,y)=1\}.
\]

By Möbius inversion:

\[
f(n)=\sum_{\substack{d\le n\\ d\ \text{odd}}}\mu(d)\left(\left\lfloor\frac{\lfloor n/d\rfloor+1}{2}\right\rfloor\right)^2
\]

(where the inner term counts **odd** multiples of \(d\)).

Then:

\[
N_g = f\!\left(\left\lfloor \frac{L}{g}\right\rfloor\right)
\]

is the number of \((a,b)\) with \(\gcd(a,b)=g\) and \((a/g),(b/g)\) both odd.

## 5) Fast evaluation of huge-index Lucas terms

We need \(U_{c^g+1}\bmod M\) for many \(c,g\), where \(c^g\) is astronomically large.

Instead of working with indices directly, we use the companion matrix:

\[
A=\begin{pmatrix}P&1\\1&0\end{pmatrix}
\quad\Rightarrow\quad
A^n=
\begin{pmatrix}
U_{n+1} & U_n\\
U_n & U_{n-1}
\end{pmatrix}.
\]

So \(U_{n+1}\) is just the **top-left** entry of \(A^n\).

We represent \(A^n\) compactly as the pair \((U_n, U_{n+1})\).
Matrix multiplication becomes an **index-addition** operation on these pairs, and squaring uses a Lucas “doubling” formula. For fixed \(c\), the sequence of indices is:

\[
c^1,\;c^2,\;c^3,\;\dots
\]

and we update by:

\[
A^{c^{k+1}} = \left(A^{c^k}\right)^c.
\]

Raising to the small exponent \(c\le 2000\) uses fast exponentiation with the cheap doubling/squaring step.

## 6) Putting it together

For each \(c\):

- Start with the state for \(A^{c}\).
- For each \(g=1..L\), add \(N_g \cdot U_{c^g+1}\).
- Add the remaining \((a,b)\) pairs (those *not* counted by any \(N_g\)) as a constant \(U_1\) or \(U_2\) depending on parity of \(c\).

Overall complexity is about:

- \(O(L^2)\) for the Möbius-based counting (here \(L=2000\)),
- plus \(O(L^2\log L)\) small-number modular operations for the Lucas powering.

## Correctness checks

The code includes asserts for the given statement values:

- \(S(2)=10444\)
- \(S(3)=1292115238446807016106539989\)
- \(S(4)\bmod 987898789 = 670616280\)

Running `python3 main.py` prints the final answer for \(S(2000)\bmod 987898789\).
