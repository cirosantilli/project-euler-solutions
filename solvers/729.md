# Project Euler 729 Solution - Range of Periodic Sequence

<https://projecteuler.net/problem=729>:

* [729.py](729.py)

## Key ideas

### 1) Work backwards with inverse branches
The map is:

- `f(x) = x - 1/x`

Given a value `y = f(x)`, the preimages satisfy:

- `x^2 - yx - 1 = 0`

So each step has exactly two real inverse branches:

- `inv₊(y) = (y + √(y²+4)) / 2`
- `inv₋(y) = (y - √(y²+4)) / 2`

A periodic orbit of length `n` corresponds to choosing one inverse branch at each of the `n` steps and finding a fixed point of the resulting composed inverse function.

`math.hypot(y, 2)` is used for `√(y²+4)` for numerical robustness.

### 2) Encode branch choices as binary necklaces
Each period-`n` orbit determines a binary word of length `n` (which branch was taken at each step). Rotating the starting point rotates the word but describes the same orbit.

To avoid generating all `2^n` words, we enumerate **aperiodic binary necklaces** of length `n` (equivalently, binary Lyndon words). Each such necklace represents one orbit of exact period `n`, and the orbit contributes `n` sequences (one for each starting point), so we multiply the orbit’s range by `n`.

The enumeration uses the classic Fredricksen–Kessler–Maiorana recursion specialized to the binary alphabet.

### 3) Find the orbit by fixed-point iteration
For a given necklace word, we build the composed inverse `G` and compute its unique fixed point by simple fixed-point iteration:

- `x ← G(x)`

In practice it converges very quickly for these small periods.

### 4) Compute the range using inverse traversal
After obtaining a point on the orbit, we generate all orbit values by repeatedly applying the same inverse branches (this walks the cycle in reverse order). The range is:

- `max(orbit) - min(orbit)`

This is numerically stable and avoids extra sensitivity from forward iteration.

### 5) Accurate summation
There are many contributions, so we sum in chunks using `math.fsum` to reduce floating-point accumulation error.
