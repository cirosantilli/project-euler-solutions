# Project Euler 651 Solution - Patterned Cylinders

<https://projecteuler.net/problem=651>:

* [651.py](651.py)

This solution models the stickers as an `a × b` grid:

- `b` stickers wrap around the cylinder’s circumference (columns, modulo `b`).
- The colouring repeats every `a` stickers along the axis (rows, modulo `a`).

So a periodic pattern is a colouring of the torus `Z_a × Z_b`.

## Symmetry group

The problem identifies patterns up to:

- translations along the axis,
- rotations about the cylinder axis,
- reflections in any plane,
- and combinations of these.

On the `a × b` grid, these symmetries act independently on rows and columns:

- rows: dihedral group `D_a` (shifts and reversals),
- columns: dihedral group `D_b` (shifts and reversals).

So the full group is `G = D_a × D_b` with `|G| = 4ab`.

## Burnside / Pólya counting

By **Burnside’s lemma**, the number of distinct patterns is:

\[
f(m,a,b)=\frac{1}{|G|}\sum_{g\in G}\text{Fix}_{=m}(g)
\]

For a group element `g`, the induced permutation on the `ab` stickers decomposes into `c(g)` cycles.
A colouring fixed by `g` must be constant on each cycle.

### Exactly `m` colours

With `c` cycles, the number of fixed colourings that use **exactly `m` labelled colours** is the
number of surjections from `c` cycle-positions onto `m` colours:

\[
\text{Fix}_{=m}(g) = \sum_{k=0}^{m}(-1)^k \binom{m}{k}(m-k)^{c(g)}
\]

This is standard inclusion–exclusion over “missing colours”.

## Fast cycle counting via cycle products

An element of `G` is a pair `(σ, τ)` with `σ ∈ D_a`, `τ ∈ D_b`.

If `σ` has cycles of lengths `r_i` and `τ` has cycles of lengths `s_j`, then on pairs `(i,j)`:

\[
c(σ,τ)=\sum_{i,j}\gcd(r_i,s_j)
\]

So we only need the cycle-length **type** of each dihedral element.

## Dihedral element types

- **Rotation by `k`** on `n` points:
  - `g = gcd(n,k)` cycles, each of length `n/g`.
  - Grouping by cycle length `L`, the multiplicity is `φ(L)` (Euler’s totient).

- **Reflections**:
  - `n` odd: one fixed point + `(n-1)/2` transpositions.
  - `n` even: two reflection types (2 fixed points, or none).

Thus each `D_n` contributes `d(n)` rotation types (one per divisor) plus 1–2 reflection types,
so the Burnside sum is computed over only about `O(d(a)d(b))` type pairs.

## What makes it fast

- Enumerate divisors and `φ(d)` from the prime factorization of `a` and `b`.
- Aggregate Burnside contributions by the resulting grid cycle count `c(g)` to reuse computations.
- `m ≤ 40`, so inclusion–exclusion per type pair is small and uses Python’s fast modular `pow`.
