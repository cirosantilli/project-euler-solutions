# Project Euler 328 Solution - Lowest-cost Search

<https://projecteuler.net/problem=328>:

* [328.py](328.py)

We want an optimal “guess the number” strategy for numbers `1..n` where each guess `k` costs `k`, and we minimize the **worst-case** total cost. Let `C(n)` be that optimal worst-case cost. The task is to compute:

\[
\sum_{n=1}^{200000} C(n)
\]

(With test values from the statement: `C(1)=0, C(2)=1, C(3)=2, C(8)=12, C(100)=400`, and \(\sum_{n=1}^{100} C(n)=17575\).) citeturn2view0

## Main techniques used

### 1) Minimax recurrence (decision tree DP)
For any interval `[lo..hi]`, if the first guess is `k`, then:

- You pay `k` now
- Worst-case continues on the larger-cost side:
  - left interval `[lo..k-1]`
  - right interval `[k+1..hi]`

So the worst-case cost for choosing `k` is:

\[
k + \max(\text{cost}(lo,k-1),\ \text{cost}(k+1,hi))
\]

and the optimal strategy takes the minimum over `k`.

### 2) “Complete-tree” cost for the upper subproblem
A key structural observation (exploited by many fast solutions) is that when the optimal first guess is **close to `n`** (which it typically is), the **right** subproblem `[k+1..n]` is solved by a *complete / balanced* search tree.

That complete-tree cost can be computed very fast via recursion that always picks the “median-like” pivot of a complete binary tree. The result on an interval `[a..a+L]` is **affine in the start value `a`**:

\[
\text{complete\_cost}(a,a+L) = m[L]\cdot a + c[L]
\]

so we memoize the coefficients `(m[L], c[L])` by length `L` and evaluate each right-subproblem in O(1).

### 3) Incremental optimization: the best first guess moves slowly
As `n` increases by 1, the optimal first guess (equivalently, the distance `dist = n-k`) changes only near powers of two.

So instead of trying every `k`, we keep the previous best `dist` and only test a small handful of candidates:

- `dist`
- `dist + 4`
- `dist + 8`
- `dist + 16`
- ...

This makes each `C(n)` computation essentially O(1), and the whole run for `n=200000` very fast.

## What the program does

- Builds `C(n)` for all `n` up to `200000` using the incremental candidate search.
- Uses memoized complete-tree coefficients to evaluate the right side quickly.
- Asserts all numeric examples given in the problem statement. citeturn2view0
- Prints the final answer (which should be `260511850222`). citeturn10view0
