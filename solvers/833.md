# Project Euler 833 Solution - Square Triangle Products

<https://projecteuler.net/problem=833>:

* [833.py](833.py)

We seek:

\[
S(N)=\sum c \quad \text{over all } (a,b,c)\text{ with }0<a<b,\;0<c\le N,\; c^2=T_aT_b
\]

where \(T_k=\frac{k(k+1)}2\) is the \(k\)-th triangular number.

---

## Key Techniques Used

### 1) Reformulation via Squarefree Cores
The condition:

\[
c^2=\frac{a(a+1)}2\cdot \frac{b(b+1)}2
\]

is equivalent to requiring that \(a(a+1)\) and \(b(b+1)\) share the same *squarefree core*.
This is naturally governed by Pell/Lucas-type recurrences.

---

### 2) Pell → Chebyshev → Lucas Parametrisation
A classical identity (appearing in OEIS A322699) defines a two-parameter family of indices:

\[
A(n,k)\text{ such that } \sqrt{A(n,k)+1}+\sqrt{A(n,k)}=(\sqrt{n+1}+\sqrt n)^k
\]

From this one can derive:

\[
T_{A(n,k)} = T_n\cdot U_k(4n+2)^2
\]

where \(U_k\) is a Lucas sequence:

- \(U_0=0\)
- \(U_1=1\)
- \(U_k=(4n+2)U_{k-1}-U_{k-2}\)

Then for any pair \(i<j\):

\[
\sqrt{T_{A(n,i)}T_{A(n,j)}} = T_n \cdot U_i \cdot U_j
\]

So every solution triple corresponds to a Lucas-product value.

---

### 3) Unique Enumeration Using Coprime Indices
Lucas sequences satisfy:

\[
\gcd(U_i,U_j)=U_{\gcd(i,j)}
\]

Thus any shared square factor corresponds exactly to a common divisor index.
This gives a clean uniqueness rule:

✅ **Count only pairs \((i,j)\) with \(\gcd(i,j)=1\)**  
and every solution triple is counted exactly once.

---

### 4) Polynomial Families and Fast Summation
For fixed coprime \((i,j)\):

\[
c(n)=T_n\cdot U_i(4n+2)\cdot U_j(4n+2)
\]

is an **integer polynomial in \(n\)** (degree \(i+j\)).

We must sum:

\[
\sum_{n=1}^{M(i,j)} c(n)
\]

where \(M(i,j)\) is the largest \(n\) such that \(c(n)\le N\).

To do this efficiently without iterating up to \(10^{11}\) terms:

#### Newton-Series / Finite-Difference Summation
Any integer polynomial satisfies:

\[
f(n)=\sum_{m=0}^d \Delta^m f(0)\binom{n}{m}
\]

and:

\[
\sum_{n=0}^M \binom{n}{m} = \binom{M+1}{m+1}
\]

So we compute:

- values \(f(0),...,f(d)\)
- forward differences \(\Delta^m f(0)\)
- combine with binomials \(\binom{M+1}{m+1}\)

All done with **exact integer arithmetic**, then reduced mod \(136101521\).

✅ No modular inverses needed (safe for composite moduli).

---

## Complexity
- Number of relevant pairs \((i,j)\) is small (≈ a few hundred for \(10^{35}\))
- Each pair needs:
  - logarithmic search for \(M(i,j)\)
  - \(O((i+j)^2)\) difference work with small degrees

Runs extremely fast in plain Python.

---

## Output
The program prints:

\[
S(10^{35}) \bmod 136101521
\]

and asserts the three sample values from the problem statement.
