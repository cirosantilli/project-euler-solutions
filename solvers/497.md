# Project Euler 497 Solution - Drunken Tower of Hanoi

<https://projecteuler.net/problem=497>:

* [497.py](497.py)

This solution computes the last nine digits of:

\[
\sum_{1 \le n \le 10000} E(n,10^n,3^n,6^n,9^n),
\]

where \(E(n,k,a,b,c)\) is the expected number of squares Bob walks in an **optimally played** game (minimum disk pickups).

## Main techniques

### 1) Expected hitting time on a reflecting 1D random walk

Bob’s motion is a simple symmetric random walk on the tiles \(\{1,\dots,k\}\) with **reflecting** boundaries:
- from an interior square he moves left/right with probability \(1/2\),
- from square 1 he must move to 2,
- from square \(k\) he must move to \(k-1\).

Let \(T(i\to j)\) be the expected number of steps to **first hit** \(j\) starting from \(i\).
Solving the standard second‑order difference equation gives a closed form:

- if \(i<j\):  \(T(i\to j)=(j-i)(j+i-2)\)
- if \(i>j\):  \(T(i\to j)=(i-j)(2k-i-j)\)
- if \(i=j\):  \(T(i\to j)=0\)

So every “walk from one rod to another” has an exact integer expected cost.

### 2) Minimal-pickup play forces the classic Hanoi recursion

“Optimal” is defined as **minimizing disk pickups**. That means Bob must use a minimal Tower of Hanoi solution:
- move \(n-1\) disks to the auxiliary rod,
- move the largest disk,
- move \(n-1\) disks onto the target.

The expected walking distance is additive, so the total expectation is a sum of the required rod-to-rod hitting times along this fixed recursive plan.

### 3) Count rod-to-rod travel segments (avoid enumerating \(2^n\) moves)

The naive move list has \(2^n-1\) disk moves and is impossible to enumerate for \(n=10000\).

Instead, the code counts how many times each **directed** rod transition occurs in the concatenated action sequence.
With 3 rods, there are only 6 directed transitions:
A→B, A→C, B→A, B→C, C→A, C→B.

A small DP stores, for each subproblem “move \(m\) disks from X to Y with Bob starting at S”, a length‑6 vector of transition counts. The Hanoi recursion updates these vectors. There are only \(6\) ordered (X→Y) pairs and 3 start positions, i.e. **18 states** per \(m\).

### 4) Work entirely modulo \(10^9\)

We only need the last nine digits. All formulas are polynomial in \(10^n,3^n,6^n,9^n\), so we can compute:
- \(10^n,3^n,6^n,9^n \bmod 10^9\) iteratively,
- all transition counts \(\bmod 10^9\),
- and accumulate the sum \(\bmod 10^9\).

## Running

```bash
python3 main.py
```

The program prints the required 9-digit answer (with leading zeros if necessary).
