# Project Euler 506 Solution - Clock Sequence

<https://projecteuler.net/problem=506>:

* [506.py](506.py)

This solution computes:

- `S(n) = v₁ + v₂ + … + vₙ`
- `S(10¹⁴) mod 123454321`

where each `vₙ` is the next chunk of digits taken from the infinite repeating stream:

`123432123432123432…`

such that the **sum of digits** inside `vₙ` equals `n`.

## Key techniques

### 1) Rotate-and-repeat structure (period 6, sum 15)

The digit stream repeats every 6 digits:

`[1,2,3,4,3,2]`

and each full 6-digit block contributes a digit-sum of `15`.

So, from any starting position (0–5), the set of achievable digit-sums is:

`prefix_sum(i) + 15*t` for `i ∈ {1..6}`, `t ≥ 0`

This means that for all `n ≥ 15`, choosing how many digits to take is determined only by:

- the **start position** in the 6-cycle, and
- `n mod 15`.

### 2) Finite-state cycle for start positions (period 15)

After brute-forcing the first 14 terms, the `(start_position, n mod 15)` state becomes periodic.
In fact, it cycles with period **15**, so the pattern of chunk “shapes” repeats every 15 values of `n`.

This lets us handle `10¹⁴` terms by:
- summing over complete 15-term cycles, plus
- a small remainder.

### 3) Summing repeated decimal blocks with geometric series (no modular inverse)

Each large chunk consists of:
- `t` full repetitions of a 6-digit block (a rotated version of `123432`), then
- a short prefix of that block.

Concatenating `t` copies of a fixed 6-digit block corresponds to a geometric series in `10⁶`:

`block * (1 + 10⁶ + 10¹² + … + 10⁶(t-1))`

We compute:
- `pow(base, n) mod M`
- `sum_{k=0..n-1} base^k mod M`
- and also `sum_{k=0..n-1} k*base^k mod M`

using **exponentiation by squaring**, avoiding modular division entirely.

### 4) Closed-form summation across cycles

Across successive 15-term cycles, the “repeat count” `t` increases by exactly 1 each cycle.
That turns the needed sums into combinations of:

- geometric sums, and
- *weighted* geometric sums (`∑ k r^k`),

both computable in `O(log N)` time.

## Complexity

- Time: `O(log N)` arithmetic with small constants (a few dozen recursive squarings)
- Memory: `O(1)`

## Files

- `main.py` prints the final answer and includes asserts for the example values from the statement.
