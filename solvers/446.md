# Project Euler 446 Solution - Retractions B

<https://projecteuler.net/problem=446>:

* [446.py](446.py)

## Key math observations

### 1) Retractions are exactly idempotent affine maps
The problem considers maps

\[
f(x)\equiv ax+b \pmod n
\]

A **retraction** satisfies:

\[
f(f(x))\equiv f(x)\pmod n \quad \forall x
\]

Expanding:

\[
f(f(x)) \equiv a(ax+b)+b \equiv a^2x + ab + b
\]

So we need:

- \(a^2 \equiv a \pmod n\)  (i.e. \(a(a-1)\equiv 0\pmod n\))
- \(ab \equiv 0 \pmod n\)

For a fixed valid \(a\), the number of \(b\) values is \(\gcd(a,n)\), so \(R(n)\) becomes a weighted count of idempotent residues \(a\).

---

### 2) Closed form for \(R(n)\) from prime powers
If \(n=\prod p_i^{k_i}\), the solutions of \(a^2\equiv a\pmod n\) are the CRT-combinations of:

- \(a\equiv 0 \pmod{p_i^{k_i}}\) or
- \(a\equiv 1 \pmod{p_i^{k_i}}\)

For such an \(a\), \(\gcd(a,n)\) equals the product of those prime powers where \(a\equiv 0\). Summing \(\gcd(a,n)\) over all CRT choices gives:

\[
\sum_{a^2\equiv a} \gcd(a,n) = \prod_i (1+p_i^{k_i})
\]

But the problem forbids \(a=0\) (it requires \(0<a<n\)), and the forbidden \(a=0\) term contributes \(\gcd(0,n)=n\). Therefore:

\[
R(n)=\Big(\prod_i(1+p_i^{k_i})\Big) - n
\]

So computing \(R(n)\) reduces to knowing the **prime-power factorization** of \(n\).

---

### 3) Special factorization of \(n^4+4\)
Use Sophie Germain’s identity:

\[
n^4+4 = (n^2-2n+2)(n^2+2n+2) = ((n-1)^2+1)\,((n+1)^2+1)
\]

Define:

\[
C_k = k^2+1
\]

Then the term for \(n\) is:

\[
n^4+4 = C_{n-1}\,C_{n+1}
\]

A crucial gcd fact:

- For **odd primes** \(p\), \(p\mid C_{n-1}\) and \(p\mid C_{n+1}\) cannot both happen (it would force \(p=2\)).
- When \(n\) is **even**, both \(C_{n-1}\) and \(C_{n+1}\) are even, and in fact each has exactly one factor of 2, so the only shared prime is \(2\).

This lets us combine multiplicative contributions from \(C_{n-1}\) and \(C_{n+1}\) with just a tiny correction in the even-\(n\) case.

---

## Algorithmic techniques used

### Polynomial sieving over the index (not over the value)
We need to factor **10,000,002** values \(C_k=k^2+1\), each up to about \(10^{14}\).

Instead of trial-dividing each number independently, we sieve in blocks over \(k\):

1. For each prime \(p\le 10^7\), solve:
   \[
   k^2\equiv -1\pmod p
   \]
   This has solutions only for \(p=2\) or \(p\equiv 1\pmod 4\).
2. For each solution \(r\), all indices \(k\equiv r\pmod p\) in the current block satisfy \(p\mid (k^2+1)\).
3. Divide out the full prime power \(p^e\) (rarely \(e>1\)) and multiply the running product by \((1+p^e)\).

This is analogous to a segmented sieve for factoring many related numbers.

### Fast square root of \(-1\) mod \(p\)
For primes \(p\equiv 1\pmod 4\), \(-1\) is a quadratic residue. If \(g\) is a quadratic non-residue mod \(p\), then:

\[
\left(g^{(p-1)/4}\right)^2 \equiv g^{(p-1)/2} \equiv -1 \pmod p
\]

So we find a small non-residue \(g\) via Euler’s criterion and compute \(r=g^{(p-1)/4}\pmod p\).

### Streaming accumulation with O(1) extra memory
We compute \(P_k=\prod(1+p^e)\pmod M\) for \(C_k\) in increasing \(k\), and immediately use the pair \((k-2,k)\) to contribute the term for \(n=k-1\). No large arrays of all \(P_k\) are needed.

---

## Correctness check included
The problem statement gives:

- \(F(1024)=77532377300600\)

`main.py` computes this exact value with a small helper and asserts it, and also asserts that the fast modular solver agrees with the modulo of that value.

---

## Running

```bash
python3 main.py
```

or for a smaller run:

```bash
python3 main.py 1024
```
