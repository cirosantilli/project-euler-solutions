# Project Euler 890 Solution - Binary Partitions

<https://projecteuler.net/problem=890>:

* [890.py](890.py)

## 1. Mathematical Reformulation

Let `p(n)` be the number of unordered representations of `n` as a sum of powers of two.

A standard generating function is:

\[
P(x)=\prod_{k\ge 0}\frac{1}{1-x^{2^k}}
\]

A known recurrence implies:

\[
p(2m)=p(2m+1)=S(m), \quad S(m)=\sum_{i=0}^m p(i)
\]

So computing `p(n)` reduces to computing `S(n//2)`.

Define:

\[
A(x)=\sum_{m\ge 0} S(m)x^m
\]

Then:

\[
A(x)=\frac{P(x)}{1-x}
\]

Using the identity:

\[
\frac{1}{1-t}=\prod_{j\ge 0}\left(1+t^{2^j}\right)
\]

one can rewrite:

\[
A(x)=\prod_{k\ge 0}(1+x^{2^k})^{k+2}
\]

Thus:

- `S(m)` is exactly the coefficient `[x^m] A(x)`
- `p(n) = [x^{n//2}] A(x)`

---

## 2. Carry-Based Dynamic Programming in Base 2

Each factor:

\[
(1+x^{2^k})^{k+2}=\sum_{j=0}^{k+2}\binom{k+2}{j}x^{j2^k}
\]

Selecting terms is equivalent to choosing `j` items of weight `2^k` from `k+2` copies.

When summing weights in binary, each bit position has a carry.
We run DP over bit positions:

- State: `dp[c]` = number of ways to match processed bits with carry `c`
- Transition: convolve `dp` with binomial row `C(k+2, j)` then pick coefficients
  of the correct parity (matching the target bit)

---

## 3. Fast Convolution via Big-Integer Packing

A naive convolution per bit would be too slow.

To accelerate, coefficients are packed into a large-base integer:

- Choose base \(B=2^{80}\) (large enough to prevent carry overlap)
- Encode a coefficient list `[a0, a1, ...]` as:

\[
A = a_0 + a_1B + a_2B^2 + \cdots
\]

Then ordinary integer multiplication `A * B` produces exact convolution
coefficients in base \(2^{80}\).

Python’s big integers use efficient algorithms in optimized C, so this becomes fast.

After multiplication, we unpack only the needed digits (every second coefficient),
reducing overhead further.

---

## 4. Complexity

Let `L = bit_length(m)` where `m = n//2`.

- `L ≈ 2181` for the target input
- DP runs for `L` steps
- Each step uses one big-integer multiplication with ~O(L) digits

This is practical in pure Python without external libraries.

---

## 5. Correctness Checks

The code includes asserts for statement examples:

- `p(7) = 6`
- `p(7^7) mod 1e9+7 = 144548435`

The final answer for `p(7^777)` is printed (and intentionally not embedded).
