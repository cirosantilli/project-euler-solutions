# Project Euler 867 Solution - Tiling Dodecagon

<https://projecteuler.net/problem=867>:

* [867.py](867.py)

This repository solves the “tiling a regular dodecagon” task for `n = 10` and prints the result modulo `1_000_000_007`.

## Key ideas

### 1) Corner forcing in a dodecagon
At each 150° corner of a regular dodecagon, the only way to fill the angle using unit regular polygons (with edges aligned) is to combine a unit square and a unit equilateral triangle. That local restriction propagates:

- If a side is adjacent to the square at its endpoints, the entire strip along that side is forced to be squares (so rectangles are uniquely tiled).
- The adjacent side (paired with triangles at the endpoints) can only be completed using unit triangles and unit hexagons.

This lets us “peel” the dodecagon layer by layer, reducing it to a smaller equiangular 12‑gon plus 6 identical corner regions.

### 2) A recursion on alternating side lengths
Define an equiangular 12‑gon by alternating side lengths `(u, v)`.

Peeling a layer of thickness `(u - w)` turns `(u, v)` into `(v, w)` and creates **six** congruent corner regions. The recurrence therefore has the form:

- a base case when the inner shape becomes a regular hexagon,
- a sum over all valid peel thicknesses `w`,
- a `corner_count^6` multiplier for the six identical corners.

A small indicator term handles the one exceptional “unit dodecagon” tiling.

### 3) Counting triangle/hexagon tilings via independent sets
Both the central hexagon and the corner regions can be tiled only with **unit triangles and unit hexagons**.

Start from the all‑triangle triangulation. Placing a unit hexagon corresponds to selecting a “center” position in a derived lattice; selected centers must be non‑adjacent to avoid overlap. The remaining area is then automatically filled by unit triangles.

So the counting problem becomes:

> Count independent sets in a small lattice graph.

### 4) Bitmask DP with a subset‑sum speedup
The center lattice can be scanned row by row. Each row is encoded by a bitmask; valid masks have no adjacent `1` bits.

Between consecutive rows, adjacency constraints depend only on whether the next row is longer by 1 or shorter by 1. For a fixed next‑row mask, the set of compatible previous‑row masks is exactly a **subset constraint**, enabling a fast subset‑sum (zeta transform) to aggregate transitions efficiently.

This makes the computation for all required subregions fast enough in pure Python.
