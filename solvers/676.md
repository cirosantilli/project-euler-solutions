# Project Euler 676 Solution - Matching Digit Sums

<https://projecteuler.net/problem=676>:

* [676.py](676.py)

This repo contains a pure-Python solution (no external libraries) for **Project Euler 676**.

## Key idea 1: Digit sums in bases `2^m` become a simple per-bit weight

Write a number in binary:

\[
 i = \sum_{p \ge 0} b_p 2^p \quad\text{with}\quad b_p \in \{0,1\}.
\]

In base \(2^m\), digits are blocks of \(m\) bits. The value of a block is
\(\sum b_p 2^{\text{offset}}\). When you sum the digits (block values), **each bit contributes only by its position inside the block**:

\[
 d(i, 2^m) = \sum_{p \ge 0} b_p \cdot 2^{(p \bmod m)}.
\]

So the equality condition becomes a single linear equation over bits:

\[
 d(i,2^k) = d(i,2^l)
\iff
\sum_{p \ge 0} b_p\left(2^{(p\bmod k)} - 2^{(p\bmod l)}\right)=0.
\]

For this problem, `k ≤ 6`, so the coefficients are small (at most 31).

## Key idea 2: Digit DP over the binary representation of `n`

We need

- **all** numbers `i ≤ n` satisfying the equation, and
- the **sum of those i**.

We process bits from MSB → LSB with a standard **digit DP** using two maps:

- `tight`: states where the prefix equals `n` so far
- `loose`: states where the prefix is already smaller than `n`

DP state is just the running difference:

\[
\Delta = d(i,2^k) - d(i,2^l).
\]

Each time we set a bit at position `p` to 1, we

- add `c_p = 2^(p mod k) - 2^(p mod l)` to `Δ`, and
- add `2^p` to the numeric value.

To also compute the **sum of values**, every state stores a pair:

- `count`: how many numbers reach this state
- `sum`: sum of those numbers

When we set a bit to 1 at position `p`, the sum updates by `+ (2^p) * count`.

## Complexity

Let `B` be the number of bits in `n` (≈ 54 for `10^16`). The DP explores a manageable range of `Δ` values (a few thousand at most), so runtime is roughly:

\[
O(B \cdot |\Delta|)
\]

and is easily fast enough for all required `(k,l)` pairs.

## Output

`main.py` prints the **last 16 digits** of:

\[
\sum_{k=3}^{6}\sum_{l=1}^{k-2} M(10^{16}, 2^k, 2^l).
\]

It also includes `assert` checks for the sample values from the problem statement.
