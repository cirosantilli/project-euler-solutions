# Project Euler 503 Solution - Compromise or Persist

<https://projecteuler.net/problem=503>:

* [503.py](503.py)

This repository contains a fast solution for **Project Euler 503**.

## Main ideas

### 1) Symmetry / exchangeability
The deck is a random permutation of `1..n`.  
Alice never sees card values; she only learns the **relative rank** of the current card among those seen so far.

A crucial symmetry fact:

- The **relative order pattern** of the seen cards is independent of **which absolute values** they are.

So, if Alice **continues** (discarding the current card), her information about absolute values doesn’t improve in a way that affects expectations.  
The expected future outcome depends only on **how many cards are left / which iteration we’re on**, not on the exact rank she just heard.

### 2) Expected value of an order statistic
If you take a random `t`-subset of `{1,2,...,n}`, the expected value of the `k`-th smallest element is:

\[
\mathbb{E}[X_{(k)}] = \frac{n+1}{t+1}\,k
\]

In this problem, at iteration `t`, Bob’s message determines `k` (the current card’s rank among the first `t` seen), so the expected score **if Alice stops now** is exactly that order-statistic expectation.

### 3) Optimal stopping becomes a 1D DP with a threshold rule
Let `G_t` be the optimal expected score starting at iteration `t` (before drawing the `t`-th card).

At iteration `t`:

- the rank `k` of the current card among the first `t` seen cards is **uniform** in `{1..t}`
- stopping yields expected score `(n+1)*k/(t+1)`
- continuing yields `G_{t+1}` (independent of `k` by the symmetry argument)

Since the stop payoff increases with `k`, the optimal policy is:

> **Stop iff** \( \frac{n+1}{t+1}k \le G_{t+1} \)

That is, “stop if the rank is good enough” — a simple **rank threshold**.

### 4) O(n) computation with constant-time updates
With the threshold `K_t = floor( G_{t+1}(t+1)/(n+1) )`, the recurrence becomes:

\[
G_t=\frac{1}{t}\left(\frac{n+1}{t+1}\sum_{k=1}^{K_t} k + (t-K_t)G_{t+1}\right)
\]

and \(\sum_{k=1}^{K} k = K(K+1)/2\), so each `t` is updated in constant time.

### 5) Numerical stability trick: normalize by (n+1)
We compute `x_t = G_t/(n+1)`, which removes the large factor `(n+1)` from comparisons and makes the recurrence cleaner:

- stop value becomes `k/(t+1)`
- continuation value is `x_{t+1}`

The final answer is `F(n) = (n+1)*x_1`.

## Complexity

- Time: **O(n)**
- Memory: **O(1)** (only the next DP value is needed)

For `n = 10^6`, this runs quickly in pure Python.
