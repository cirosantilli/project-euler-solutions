# Project Euler 673 Solution - Beds and Desks

<https://projecteuler.net/problem=673>:

* [673.py](673.py)

`main.py` is a standalone solution for Project Euler problem 673.

It reads the pairing lists from the **current working directory**:

- `0673_beds.txt`
- `0673_desks.txt`

and prints the required count modulo **999,999,937**.

You can also run:

```bash
python3 main.py [beds_file] [desks_file] [n]
```

If `n` is omitted, it defaults to 500.

## Main techniques

### 1) Encode beds and desks as involutions
Each pairing list defines an involution (a permutation of order 2) on `{1..n}`:

- if a line `a,b` exists, then `a ↔ b` (a transposition),
- any student not listed is unpaired and is a fixed point.

Let `B` be the bed involution and `D` the desk involution.

### 2) The constraints become commutation
After choosing a permutation `σ`, student `k` receives the bed that used to belong to
`σ(k)`. The roommate relation after the change is `σ⁻¹ B σ`; demanding that roommates
stay the same means `σ⁻¹ B σ = B`, i.e. `σB = Bσ`. Similarly, desk partners staying the
same gives `σD = Dσ`.

So we must count permutations `σ` that commute with both involutions.

### 3) Decompose into simple connected components
Build a graph whose vertices are students; add one undirected edge of color `B` from
`v` to `B(v)` and one edge of color `D` from `v` to `D(v)` (loops when fixed). Every
vertex has exactly one `B` edge and one `D` edge, so every connected component is
one of:

- an even alternating cycle (no loops at all),
- an alternating path whose endpoints have loops,
- a single isolated vertex (loops of both colors).

### 4) Count automorphisms of one component
An allowed `σ` is exactly a color-preserving automorphism of this disjoint union.

For a component with `s` vertices:

- **Cycle (no loops):** `s` is even and the colored cycle has exactly `s` automorphisms
  (`s/2` rotations by two steps, and `s/2` reflections that preserve colors).
- **Path (has loops):** there are 2 automorphisms iff the component is symmetric,
  which happens exactly when `s` is even (the two endpoint loops have the same
  color); otherwise only the identity.

Even-sized paths come in two non-isomorphic types: endpoints having `B`-loops versus
endpoints having `D`-loops, so they are counted separately.

### 5) Combine identical components
If a component type `t` occurs `c` times, then:

- each copy can be acted on independently: `aut(t)^c`,
- the `c` copies can be permuted among themselves: `c!`.

Thus the total answer is:

`∏_t aut(t)^{c_t} · c_t!  (mod M)`.

## Complexity
With `n = 500`, we do a single DFS over at most 500 vertices.

- Time: `O(n)`
- Memory: `O(n)`

The code includes `assert` checks for the sample values in the problem statement.
