# Project Euler 521 Solution - Smallest Prime Factor

<https://projecteuler.net/problem=521>:

* [521.py](521.py)

We need:

\[
S(n)=\sum_{i=2}^{n} \operatorname{smpf}(i), \quad \text{where smpf(i) is the smallest prime factor of } i,
\]
and compute:

\[
S(10^{12}) \bmod 10^9.
\]

The problem statement includes the check value **S(100)=1257**.

---

## 1) Rewriting the sum by smallest prime factor

Each integer `i` contributes exactly one prime: its smallest prime factor.

For a prime `p`, let `C(p)` be the count of integers `i ≤ n` whose smallest prime factor is `p`. Then:

\[
S(n)=\sum_{p\le n} p\cdot C(p).
\]

Any `i` with smallest prime factor `p` can be written as:

\[
i = p \cdot m
\]

where `m` has **no prime factor smaller than p** (i.e., `m` is *p-rough*).

So:

\[
C(p) = \Phi(\lfloor n/p \rfloor, \pi(p-1)),
\]

where `Φ(x, a)` counts integers `≤ x` not divisible by the first `a` primes.

---

## 2) Range splitting (using n = 10^12)

For `n=10^12`, the thresholds are:

- \(n^{1/4} = 10^3\)
- \(n^{1/3} = 10^4\)
- \(\sqrt{n} = 10^6\)

That gives a crucial observation: for large `p`, the cofactor `m` cannot have many prime factors (all ≥ p), because `p*m ≤ n`.

### a) `p ≤ 10^3`
`m` may have many prime factors, so we compute:

\[
C(p)=\Phi(\lfloor n/p \rfloor, \pi(p-1))
\]

directly using a cached recursive `Φ`.

### b) `10^3 < p ≤ 10^4`
Here \(p^4 > n\), so `m` can have **at most 2 prime factors**:

- `m = 1`
- `m = q` (prime, `q ≥ p`)
- `m = q r` (primes, `p ≤ q ≤ r`, and `qr ≤ n/p`)

This reduces `C(p)` to prime-counting queries and a semiprime pair count.

### c) `10^4 < p ≤ 10^6`
Here \(p^3 > n\), so `m` can have **at most 1 prime factor**:

\[
C(p)=1 + \pi(\lfloor n/p \rfloor) - \pi(p-1).
\]

### d) `p > 10^6`
If `p > √n`, then the only integers with smallest prime factor `p` are the prime `p` itself, so `C(p)=1`.
Thus we just need the sum of primes in that interval:

\[
\sum_{\sqrt{n}<p\le n} p.
\]

---

## 3) Fast π(x): segmented sieve up to 10^8 + Lehmer for larger

We need many `π(x)` queries, mainly with `x ≤ 10^8` (because `n/p ≤ 10^8` once `p ≥ 10^4`).

- A **lazy segmented sieve** builds the prime list up to `10^8` once, then answers `π(x)` by binary search.
- For `π(x)` with larger `x` (e.g., up to `10^12` inside the `10^3 < p ≤ 10^4` region), we use **Lehmer prime counting**, which is efficient using primes up to `10^6`.

---

## 4) Prime summatory function with a Min_25 sieve (mod 1e9)

To handle the final range `p > √n`, we need:

\[
\sum_{p\le n} p \quad\text{(mod 1e9)}.
\]

The solution implements a **Min_25 sieve variant** that computes:

\[
\text{PrimeSum}(n) = \sum_{p\le n} p \bmod 10^9
\]

in about \(O(n^{2/3})\) time using:

- the distinct values of \(\left\lfloor\frac{n}{i}\right\rfloor\),
- a pair of index tables for O(1) lookup,
- a prime loop up to \(\sqrt{n}\) to “sieve out” composites,
- all arithmetic carried modulo \(10^9\) (valid because the method is linear).

Then:

\[
\sum_{\sqrt{n}<p\le n} p \equiv \text{PrimeSum}(n) - \text{PrimeSum}(\sqrt{n}) \pmod{10^9}.
\]

---

## Tests included

From the statement:

- `smpf(91)=7`
- `smpf(45)=3`
- `S(100)=1257`

These are asserted in `main.py`.
