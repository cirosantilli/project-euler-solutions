# Project Euler 324 Solution - Building a Tower

<https://projecteuler.net/problem=324>:

* [324.py](324.py)

We want the number of tilings of a **3 × 3 × n** box using **2 × 1 × 1** blocks (dominoes), where dominoes may be oriented along any axis. The answer is required **modulo** `100000007`.

## Techniques used

### 1) Profile DP / transfer matrix on slices

Cut the tower perpendicular to its length. Each slice is a **3 × 3** layer with **9 cells**.

A domino can:
- lie **within the current slice** (two adjacent cells in the 3×3 plane), or
- stick **forward into the next slice** (same (x,y) cell, next z).

That means the only information that must cross a slice boundary is which cells in the *current* slice are already occupied by dominoes that started in the previous slice.

Represent that boundary as a **9‑bit mask** ⇒ **2⁹ = 512 states**.

For each incoming mask we recursively enumerate all ways to finish the slice and count which **next mask** is produced. This gives a sparse transition list:

`mask -> [(next_mask, count), ...]`

Iterating those transitions yields `f(n)` for moderate `n`.

### 2) Even-height reduction

The box has `9n` unit cubes. Since `9` is odd, `9n` is even **iff** `n` is even, so:

- `f(n) = 0` for odd `n`
- define `a(m) = f(2m)` and work only with `a`

### 3) Berlekamp–Massey to find a short recurrence

The sequence `a(m) mod MOD` satisfies a linear recurrence with constant coefficients.

Using a prefix of values computed by the transfer DP, **Berlekamp–Massey** finds the *shortest* recurrence over the finite field (here `MOD = 100000007` is prime).

This collapses the problem from a 512‑state DP to a small `k`‑term recurrence.

### 4) Kitamasa (polynomial exponentiation) for huge indices

To evaluate `a(m)` for a gigantic `m` (here `m = 5·10⁹⁹⁹⁹`), we use **Kitamasa’s algorithm**:

- represent `a(m)` as a linear combination of the first `k` values
- compute the coefficient vector by exponentiating `x^m` **modulo the characteristic polynomial**
- complexity is **O(k² log m)**

This makes `f(10^10000)` feasible.

## Correctness checks

`main.py` includes `assert`s for all example values from the problem statement:

- `f(2) = 229`
- `f(4) = 117805`
- `f(10) mod q = 96149360`
- `f(10^3) mod q = 24806056`
- `f(10^6) mod q = 30808124`
