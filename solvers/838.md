# Project Euler 838 Solution - Not Coprime

<https://projecteuler.net/problem=838>:

* [838.py](838.py)

This repository contains a pure-Python solution (no external libraries) that computes:

- `ln(f(10^6))` rounded to 6 digits after the decimal point,

where `f(N)` is the smallest positive integer that is **not coprime** to every `n ≤ N` whose last digit is `3`.

## Key techniques

### 1) Reframing as a “hit every number by a prime factor” problem
If we write `f(N)` as a product of primes, then the condition

> for every `n` ending in `3`, `gcd(f(N), n) > 1`

means:

> for every such `n`, at least one prime dividing `f(N)` must also divide `n`.

So the task is to choose a set of primes so that every eligible `n` is “hit” by at least one chosen prime, while making the product of chosen primes as small as possible.

Minimizing a product is equivalent to minimizing the sum of logs, so we give each prime `p` weight `ln(p)`.

### 2) Forced primes from the problem structure
Two classes of primes are unavoidable:

- Any prime `p ≤ N` with `p ≡ 3 (mod 10)` must be included because `n = p` is itself among the numbers ending in `3`.
- Any prime `p ≡ 7 (mod 10)` with `p^3 ≤ N` must be included because `p^3` ends in `3`, has no `≡3 (mod 10)` prime factor, and can only be “hit” by including `p`.

These forced primes dramatically reduce what remains to be covered.

### 3) Reduction to a bipartite vertex cover
After forcing, any remaining uncovered number ending in `3` must have:
- at least one prime factor `≡ 7 (mod 10)`, and
- at least one prime factor `≡ 9 (mod 10)`,

otherwise it would contain at least three `≡7` factors (forcing a small cube prime).

Therefore it is enough to enforce constraints for semiprimes `p*q` where:
- `p ≡ 7 (mod 10)` is **not** forced,
- `q ≡ 9 (mod 10)`,
- `p*q ≤ N`.

Each such semiprime enforces: choose `p` or choose `q`.

This is exactly a **vertex cover** problem on a bipartite graph:
- left vertices = eligible `≡7 (mod 10)` primes,
- right vertices = eligible `≡9 (mod 10)` primes,
- edges represent `p*q ≤ N`.

Weights are `ln(p)` / `ln(q)`.

### 4) Solving minimum weight vertex cover via min-cut
Minimum weight vertex cover in a bipartite graph reduces to an `s-t` min-cut:

- connect `source -> left(p)` with capacity `weight(p)`,
- connect `right(q) -> sink` with capacity `weight(q)`,
- connect `left(p) -> right(q)` with capacity `INF` for every edge.

A minimum cut corresponds to a minimum weight vertex cover:
- take all left nodes **not reachable** from the source in the residual graph,
- and all right nodes **reachable** from the source.

The implementation uses Dinic’s max-flow algorithm.

### 5) Stable summation of logarithms
The final result is the sum of many `ln(p)` values. To keep floating error comfortably below the required `1e-6` rounding, Kahan summation is used for the final log-sum.

## Tests
The code asserts the sample values from the statement:

- `f(40) = 897` and `ln(f(40))` rounds to `6.799056`,
- `ln(f(2800))` rounds to `715.019337`.

Running `main.py` performs these tests and then prints the requested value for `N = 10^6`.
