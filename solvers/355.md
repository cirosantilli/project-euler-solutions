# Project Euler 355 Solution - Maximal Coprime Subset

<https://projecteuler.net/problem=355>:

* [355.py](355.py)

This repository contains a standalone solution for **Project Euler 355**.

## Problem recap

Let **Co(n)** be the maximal possible sum of a set of **pairwise coprime** elements chosen from `{1,2,...,n}`.

The task is to compute `Co(200000)` (with a few smaller values given for checking).

## Main techniques used

### 1) Prime-factor “resource” viewpoint

If a set is pairwise coprime, **no prime factor may appear in two different chosen numbers**.

So each prime `p` can be “spent” at most once across the chosen set.

### 2) Baseline: take the best number for each prime

If a prime `p` is used at all, and it is used alone, the best choice is the **largest prime power**
`p^k ≤ n`.

All prime powers for distinct primes are automatically pairwise coprime, so a valid baseline set is:

- always include `1`
- for every prime `p ≤ n`, include `max power p^k ≤ n`

This gives a baseline sum:

`1 + Σ_p v(p)` where `v(p) = max p^k ≤ n`.

### 3) Improving the baseline by “pairing” primes

A better solution can sometimes replace two baseline choices:

- `v(p)` and `v(q)`  
with a single number that uses both primes:

- `m = p^a · q^b ≤ n`

The improvement (gain) is:

`gain(p,q) = m − v(p) − v(q)`.

For the Euler 355 instance with `n = 200000`, any composite using two distinct primes must include
a prime `≤ √n`, so we only need to consider pairings between:

- **small primes** `p ≤ √n`
- **large primes** `q > √n` (then necessarily `q^2 > n`, so `q` can only appear to the power `1`)

For a fixed pair `(p, q)` with `q > √n`, the best combined number is:

`m = q · max(p^a ≤ n/q)`.

### 4) Reduction to a maximum-gain matching (assignment)

Each small prime can be paired with **at most one** large prime, and each large prime can be used
**at most once**.

That is exactly a **maximum-weight bipartite matching / assignment** problem:

- left side: small primes `p ≤ √n`
- right side: large primes `√n < q ≤ n/2` (primes `> n/2` cannot pair with anything ≥ 2)
- edge weight: `gain(p,q)` when positive
- leaving a small prime unpaired is allowed (gain `0`)

### 5) Solving the assignment with Min-Cost Max-Flow

Because the number of small primes is small (only 86 when `n=200000`), we solve the assignment via
**min-cost max-flow**:

- Send 1 unit of flow from the source through each small prime.
- Either:
  - route to a large prime (pay cost `C − gain`), or
  - route directly to the sink (unpaired, pay cost `C`)
- With an appropriate constant `C ≥ max(gain)`, all *forward* costs are non-negative, and the
  standard successive shortest augmenting path algorithm with potentials works efficiently.

Finally:

`Co(n) = baseline + total_gain`.

## Output

Running `python3 main.py` prints:

- `Co(200000) = 1726545007`

The script also includes `assert` checks for the values given in the problem statement.
