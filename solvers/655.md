# Project Euler 655 Solution - Divisible Palindromes

<https://projecteuler.net/problem=655>:

* [655.py](655.py)

This solution counts **positive** base‑10 palindromes with up to 32 digits that are divisible by a given modulus (here `10,000,019`), using a residue‑class dynamic program.

## Key ideas

### 1) Build palindromes from the center outward
A palindrome of length `L+2` can be formed from a palindrome `x` of length `L` by choosing an outer digit `d` and creating:

`d ... x ... d`

Numerically this is:

`new = d·10^(L+1) + 10·x + d`

Working modulo `m` gives:

`new_res = (10·old_res + d·(10^(L+1)+1)) mod m`

For each length we only want palindromes whose **first digit is non‑zero**, so when counting the results for a given length we exclude the case `d = 0`.

### 2) Count by residues modulo `m`
For each length we store a table `dp[r]` = “how many palindromic strings of this length have remainder `r` modulo `m`”.

The answer for that length is the entry `dp[0]` **after removing the contribution from outer digit 0**.

### 3) Reduce the “sum over digits” to a sliding window on a cycle
A direct transition would be:

`next[r] = Σ_{d=0..9} temp[(r - d·c) mod m]`

where `c = (10^(L+1)+1) mod m` and `temp` is `dp` permuted by multiplication by 10.

Because `gcd(m,10)=1`, both multiplying by 10 and stepping by `c` are permutations of residues. If we visit residues in the order:

`0, c, 2c, 3c, ... (mod m)`

then the digit‑sum above becomes a **cyclic sliding sum of 10 consecutive values** along that order. That turns each length extension into an `O(m)` pass instead of `O(10m)`.

## Complexity

- Time: `O(m · max_len)` with small constants (two linear passes per added digit‑pair).
- Memory: two arrays of length `m` holding 64‑bit counters.

The method assumes `gcd(m, 10) = 1` so that these modular permutations exist (true for the modulus used in the problem).
