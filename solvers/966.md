# Project Euler 966 Solution - Triangle Circle Intersection

<https://projecteuler.net/problem=966>:

* [966.py](966.py)

This repo contains a single-file solution (`main.py`) that computes

\[
\sum I(a,b,c)\quad\text{for integer triangles }1\le a\le b\le c < a+b,\ a+b+c\le 200,
\]

where **\(I(a,b,c)\)** is the **maximum possible area of intersection** between:

- a triangle with side lengths \(a,b,c\), and
- a circle whose area equals the triangle’s area,

allowing the circle to be translated freely in the plane.

## Main techniques used

### 1) Deterministic coordinate placement
For side lengths \(a,b,c\), the triangle is placed as:

- \(A=(0,0)\)
- \(B=(c,0)\)
- \(C=(x,y)\) from the law of cosines so that \(|AC|=b\) and \(|BC|=a\)

This removes irrelevant rigid motions.

### 2) Equal-area circle radius
If the triangle has area \(T\), the circle satisfies \(\pi r^2 = T\), hence
\[
r=\sqrt{T/\pi}.
\]

### 3) Triangle–circle intersection via per-edge triangle/sector contributions
To evaluate overlap for a fixed circle center:

- translate so the circle is centered at the origin
- for each oriented edge \(P\to Q\), compute its signed contribution:
  - split the segment at its intersection point(s) with the circle
  - **classify each resulting subsegment using its endpoints**
    (inside/on circle → triangle area; otherwise → sector area)
  - project computed intersection points back onto the circle to reduce drift

Summing the three edge contributions (and taking absolute value) yields the
triangle–circle intersection area.

### 4) Maximization by pattern search
To compute \(I(a,b,c)\), the code maximizes the overlap over the circle center
using a deterministic, derivative-free search:

- try several geometric start points (centroid, incenter, circumcenter, vertices, midpoints)
- perform an 8-direction pattern search (axes + diagonals)
- at each step size, “keep walking” while improvements exist, then halve the step

### 5) Similarity scaling speedup (group by gcd)
If \((a,b,c)=g(a',b',c')\), scaling scales all areas by \(g^2\), so
\[
I(ga',gb',gc') = g^2 I(a',b',c').
\]
The program groups triangles by their gcd-reduced shape and accumulates the
needed \(g^2\) weights so each shape is optimized only once.

## Running

```bash
python3 main.py
