# Project Euler 926 Solution - Total Roundness

<https://projecteuler.net/problem=926>:

* [926.py](926.py)

## Key idea
For an integer `n`, the **roundness** in base `b` is the number of trailing zeros in base `b`, i.e. the largest `k` such that `b^k` divides `n`.

Define:

- `v_b(n)` = roundness of `n` in base `b`
- `R(n) = sum_{b>1} v_b(n)`

The trick is to rewrite the sum over bases into a sum over **powers**.

### 1) Swap the order of counting
Use the identity

`v_b(n) = sum_{k>=1} [b^k divides n]`.

So

`R(n) = sum_{b>1} sum_{k>=1} [b^k | n] = sum_{k>=1} ( count of b>1 with b^k | n )`.

For a fixed `k`, the condition `b^k | n` means `b` can be any divisor of

`m_k = product_p p^{ floor(e_p / k) }`

where `n = product_p p^{e_p}`.

Therefore

`count(b>1 with b^k | n) = d(m_k) - 1`

where `d(x)` is the divisor-counting function.

So

`R(n) = sum_{k=1..max(e_p)} ( d(m_k) - 1 )`.

For this problem, `n = N!`.

### 2) Compute `d(m_k)` from prime exponents
For each prime `p`, let `e_p = v_p(N!)` (Legendre’s formula).

Then

`d(m_k) = product_p ( floor(e_p / k) + 1 )`.

If we define an array `D[k] = d(m_k) (mod M)`, we can build it by multiplying in each prime’s contribution.

### 3) Range updates via quotient grouping
For a fixed exponent `e`, the value `floor(e / k)` is constant on ranges of `k`.

Using the standard division-grouping loop:

- let `q = e // k`
- then `q` stays constant until `r = e // q`

On each block `[k..r]`, every `D[i]` is multiplied by the same factor `(q+1)` (or `(q+1)^count` when many primes share the same `e`).

This removes almost all *division* operations from the inner loops.

### 4) Group primes larger than `sqrt(N)`
If `p > sqrt(N)`, then `p^2 > N`, so

`v_p(N!) = floor(N / p)`.

Many primes share the same value of `floor(N/p)`, which is at most `sqrt(N)`.

The code counts how many large primes have each exponent `e`, then applies their combined effect in one pass:

`D[k] *= ( floor(e / k) + 1 )^count`.

This collapses hundreds of thousands of individual prime updates into about `O(sqrt(N)^2)` lightweight multiplications on the first `sqrt(N)` entries.

### 5) Final accumulation
Once `D[k] = d(m_k)` is built,

`R(N!) = sum_{k>=1} (D[k] - 1)`.

Since `D[k]=1` for `k > max(e_p)`, the sum is finite and we compute it modulo `10^9+7`.
