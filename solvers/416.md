# Project Euler 416 Solution - A Frog's Trip

<https://projecteuler.net/problem=416>:

* [416.py](416.py)

# A Frog's Trip

## Approach

The frog makes `m` round trips from square 1 to square `n` and back.
Each round trip corresponds to two directional paths:

- Outward path from 1 to `n` using steps 1, 2, 3.
- Homeward path from `n` to 1 using steps 1, 2, 3 (leftward).

The total set of visited squares is the union of all `2m` directional paths.
We must count all round-trip collections where at most one square is unvisited.

## Key Ideas

- Each directional path visits a set of squares based on its positions.
- For each square `j`, a directional path visits `j` exactly when the path reaches a
  position whose index matches `j`.
- We model all `2m` directional paths independently and track, for each square,
  how many of the `2m` paths visit it.
- A square is "missed" only if **none** of the `2m` paths visit it.
- The requirement is that at most one square is missed.

### Counting Paths by Offset States

For a fixed square index, a path's ability to visit it depends only on the
position of the path relative to that square. We track three offsets:

- offset 0: the path is exactly at the square,
- offset 1: one square away,
- offset 2: two squares away.

At each square position we maintain counts:

- `a`: number of paths at offset 0,
- `b`: number of paths at offset 1,
- `c`: number of paths at offset 2.

We derive a fixed transition rule for `(a, b, c)` as we move one square to the right,
based on how offset-0 paths split to offsets 0/1/2 in the next step.
This yields a small state space of size `(k+1)(k+2)/2` (for `k=20`, only 231 states).

### Tracking Missed Squares

We extend the DP with a second dimension for "miss count":

- `dp0`: no missed squares so far,
- `dp1`: exactly one missed square so far.

If a square has `a=0` (no path visits it), it is missed and transitions from `dp0`
to `dp1`. We disallow transitions that would create a second miss.

### Fast Exponentiation in `n`

The per-square update is a linear transformation on `(dp0, dp1)`, so we build
two matrices:

- `A`: transitions where the next square is visited (`a_new > 0`)
- `B`: transitions where the next square is missed (`a_new = 0`)

This gives a block matrix:

```
[ A  0 ]
[ B  A ]
```

Block multiplication keeps the same form:

```
A' = A1 * A2
B' = B1 * A2 + A1 * B2
```

So we can exponentiate `(A, B)` in `O(log n)` matrix multiplications using
231x231 matrices instead of full 462x462 matrices.
