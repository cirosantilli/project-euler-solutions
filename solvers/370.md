# Project Euler 370 Solution - Geometric Triangles

<https://projecteuler.net/problem=370>:

* [370.py](370.py)

## Key math idea: parameterize all geometric triangles

A “geometric triangle” has integer sides \(a \le b \le c\) in geometric progression:

\[
b^2 = a c
\]

Write the common ratio as a reduced fraction \(r = \frac{m}{n}\) with \(\gcd(m,n)=1\), \(m \ge n\).
Then the sides must be:

\[
(a,b,c) = (k n^2,\; k m n,\; k m^2)
\qquad (k \ge 1)
\]

The perimeter becomes:

\[
P = k\,(m^2 + mn + n^2) = kS
\]

So the counting problem is:

\[
\sum_{\substack{\gcd(m,n)=1 \\ n \le m \\ \text{triangle inequality}}}
\left\lfloor \frac{N}{m^2+mn+n^2} \right\rfloor
\]

## Triangle inequality becomes a ratio bound

The only nontrivial inequality is \(a+b>c\):

\[
n^2 + mn > m^2
\]

Divide by \(n^2\) to get \(1 + r > r^2\), hence:

\[
r < \varphi = \frac{1+\sqrt{5}}{2}
\]

So for each \(n\), valid \(m\) are in:

\[
m \in [n,\; \lfloor \varphi n \rfloor]
\]

## Performance technique 1: group equal quotients (“hyperbola” trick)

For fixed \(n\), the quantity

\[
q(m) = \left\lfloor \frac{N}{S(m,n)} \right\rfloor,\quad S(m,n)=m^2+mn+n^2
\]

is non-increasing in \(m\). Instead of iterating every \(m\), we jump across *runs* where \(q(m)\)
stays constant by solving:

\[
S(m,n) \le \left\lfloor \frac{N}{q} \right\rfloor
\]

This is a quadratic in \(m\); the last valid \(m\) in the run comes from an integer square root.

## Performance technique 2: count coprimes by inclusion–exclusion (Möbius on divisors)

We must enforce \(\gcd(m,n)=1\). For a fixed \(n\), the indicator can be written using the Möbius function:

\[
\mathbf{1}_{\gcd(m,n)=1} = \sum_{d\mid n}\mu(d)\,\mathbf{1}_{d\mid m}
\]

So the number of \(m\) in an interval \([L,R]\) coprime to \(n\) is:

\[
\sum_{d\mid n}\mu(d)\left(\left\lfloor\frac{R}{d}\right\rfloor - \left\lfloor\frac{L-1}{d}\right\rfloor\right)
\]

In code, we generate all **squarefree** divisors of \(n\) (since \(\mu(d)=0\) otherwise) using the
distinct prime factors of \(n\).

## Supporting technique: sieve for smallest prime factors

To factor each \(n\) quickly, we build a smallest-prime-factor table up to \(\sqrt{N/3}\) with a linear sieve.

## Correctness checks (from the statement)

- The example \((144,156,169)\) satisfies the definition.
- There are exactly **861805** geometric triangles with perimeter \(\le 10^6\).

Both are asserted in `main.py`.

## Output

The official Euler input is \(N = 2.5\cdot 10^{13}\) and the answer is:

\[
41791929448408
\]

`main.py` prints this value by default.
