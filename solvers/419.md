# Project Euler 419 Solution - Look and Say Sequence

<https://projecteuler.net/problem=419>:

* [419.py](419.py)

The task is to compute:

- `A(n)` = number of `1` digits
- `B(n)` = number of `2` digits
- `C(n)` = number of `3` digits

in the **n-th** look-and-say term (starting from `1`), for `n = 10^12`, with all answers taken **modulo `2^30`**.

## Key ideas used

### 1) Conway “elements” (audioactive decay)
For sufficiently old look-and-say strings, the sequence can be uniquely factored into a concatenation of **elements** (also called “atoms”).

Crucially:

- If a term factors as `E1 E2 ... Ek`, then **each element evolves independently** under further look-and-say steps.
- Therefore, the next term’s factorization is obtained by applying look-and-say to each `Ei` and re-factorizing the result.

That makes the evolution **linear** on the vector of element multiplicities.

### 2) Splitting with a small, local oracle (`spl0`)
To factor a string into elements efficiently, the code uses a *parsimonious splitting oracle* (`spl0`) published in Kevin Watkins’ write-up of Conway’s cosmological theorem.

In practice, the oracle only needs to inspect a *constant-sized* prefix of the suffix starting at a candidate split point (a handful of characters), so factorization is **O(length)**.

In `main.py`, the Haskell pattern-matching rules are translated into two functions:

- `_spl0_at(s, i)` — decides whether there is a split **after** position `i`.
- `_spl00_at(s, j)` — helper used by `_spl0_at`.

These are specialized to digits `1..3` because the standard look-and-say sequence never needs larger digits.

### 3) Build the element set and decay rules *from scratch*
No precomputed element table is stored.

Starting from a “mature” term (the 40th term, which is still small enough to build directly), we:

1. factor it into elements,
2. repeatedly apply: `element -> say(element) -> factor into elements`,
3. keep adding newly discovered elements until reaching closure.

This produces a finite set of elements and their **decay rules** automatically.

### 4) Matrix exponentiation modulo `2^30`
Let `v_t` be the row-vector of element counts at term `t`.

If `M` is the decay matrix where `M[i][j]` is “how many times element `j` appears after one step applied to element `i`”, then:

- `v_{t+1} = v_t · M`
- `v_n = v_40 · M^(n-40)`

The code computes `v_40 · M^(n-40)` using exponentiation by squaring, keeping all arithmetic modulo `2^30`.

Finally, `A,B,C` are obtained by dot products of `v_n` with per-element digit counts.

## Correctness check
The problem statement provides:

- `A(40) = 31254`, `B(40) = 20259`, `C(40) = 11625`

`main.py` computes the 40th term directly and includes an `assert` for this triple.
