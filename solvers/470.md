# Project Euler 470 Solution - Super Ramvok

<https://projecteuler.net/problem=470>:

* [470.py](470.py)

This solution computes:

\[
F(20)=\sum_{d=4}^{20}\sum_{c=0}^{20} S(d,c)
\]

where `S(d,c)` is the expected optimal profit from **Super Ramvok**, starting from a fair `d`-sided die with all faces visible.

---

## Core Techniques Used

### 1) **Myopic optimality (strategy decouples from state evolution)**

In Super Ramvok:

- You play a Ramvok game on the current die state (some faces blank).
- Then **exactly one random face is toggled** (visible → blank, blank → visible).
- Importantly: **Your Ramvok decisions do not affect which face gets toggled.**

Therefore, maximizing total expected profit reduces to maximizing expected profit **independently in each game**, i.e. the optimal global strategy is *myopic*:

> For every die state `A`, play Ramvok optimally for that state only.

So total expectation becomes:

\[
S(d,c)=\mathbb{E}\Big[\sum_{t<T} R(A_t,c)\Big]
\]

where `A_t` is the die subset at game `t`, and `R(A,c)` is single-game optimal profit on that subset.

---

### 2) **Symmetry reduction to “number of visible faces” (Hamming weight)**

Starting state is fully visible, and the toggling step treats all faces uniformly.
Thus, the Markov chain over subsets is symmetric under permutation of faces.

Consequences:

- The probability distribution over subsets depends only on the **number of visible faces** `k`.
- Expected number of visits to “any subset of size k” can be computed using the **1D Ehrenfest (toggle) chain** on `k = 0..d`.

We compute:

\[
V_k(d) = \text{expected number of visits to a die state with }k\text{ visible faces}
\]

---

### 3) **Absorbing Markov chain via fundamental matrix**

The chain on visible-face count `k` transitions:

- `k → k-1` with probability `k/d`
- `k → k+1` with probability `(d-k)/d`
- `0` is absorbing

Let `Q` be the transient transition matrix on states `1..d`.
Then the fundamental matrix:

\[
N = (I-Q)^{-1}
\]

Row `d` of `N` gives expected visit counts to every transient `k`.

Because `d ≤ 20`, we invert using a small **Gauss-Jordan** routine (no libraries).

---

### 4) **Enumerating all subsets (feasible because d ≤ 20)**

For each `d`, we need averages:

\[
A_{d,k,c} = \frac{1}{\binom{d}{k}}\sum_{|A|=k} R(A,c)
\]

Since `2^{20} = 1,048,576`, brute enumeration of all subsets is feasible.

We accumulate sums grouped by subset size `k`, then divide by `C(d,k)`.

---

### 5) **Fast Ramvok evaluation for a fixed subset**

If visible values are `v1 < v2 < ... < vk`, then for a horizon `t`:

\[
f_0 = 0,\quad f_t = \frac{1}{k}\sum_{i=1}^{k}\max(v_i, f_{t-1})
\]

The optimal profit for cost `c` is:

\[
R(A,c)=\max_{t\ge 0}(f_t - c t)
\]

Optimization used:

- Maintain a pointer `p = # of values < f_{t-1}` (monotone increasing)
- Use cumulative sums so each `f_t` is computed in **O(1)** after pointer moves
- For integer `c ≥ 1`, horizons beyond `max(A)` cannot improve profit (profit ≤ 0), so we bound `t`

---

## Correctness Checks (from statement)

The code includes:

- `assert R(4,0.2) == 2.65`
- `assert S(6,1) == 208.3` (within floating tolerance)

---

## Output

Running:

```bash
python3 main.py
