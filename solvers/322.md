# Project Euler 322 Solution - Binomial Coefficients Divisible by 10

<https://projecteuler.net/problem=322>:

* [322.py](322.py)

We need

\[
T(m,n)=\#\{\,i\mid n \le i < m,\; \binom{i}{n}\equiv 0 \pmod{10}\,\}
\]

Given: `T(10^9, 10^7-10) = 989697000`.

The program computes `T(10^18, 10^12-10)`.

## Key ideas used

### 1) Inclusion–exclusion over the prime factors of 10

`10 = 2 · 5`, so “divisible by 10” means divisible by **both** 2 and 5.

Let

* `A2` = indices `i` where \(\binom{i}{n}\) is **not divisible by 2** (i.e. odd)
* `A5` = indices `i` where \(\binom{i}{n}\) is **not divisible by 5**

Then

\[
\#\{\text{divisible by 10}\}= (m-n) - |A2| - |A5| + |A2 \cap A5|.
\]

So the whole problem becomes: count `A2`, count `A5`, count the intersection.

### 2) Lucas’ theorem to detect divisibility by a prime

For a prime \(p\), Lucas’ theorem implies:

\[
\binom{i}{n} \not\equiv 0 \pmod{p}
\iff
\text{every base-}p\text{ digit of } i \text{ is } \ge \text{ the corresponding digit of } n.
\]

That turns a divisibility question into a *digitwise constraint*.

### 3) Fast counting for `p = 2` (bitmask DP)

In base 2, each digit is 0/1, so the digitwise condition becomes:

\[
\binom{i}{n} \text{ is odd} \iff (i \;\&\; n) = n.
\]

Counting `i < m` with forced 1-bits is done with a small binary digit-DP
(`tight/loose` states), in \(O(\log m)\).

### 4) Fast counting for `p = 5` (base-5 digit DP)

For `p = 5` we apply a standard digit DP in base 5:

* upper bound: `i < m`
* per-digit lower bound: `digit_i >= digit_n`

This runs in \(O(\text{#digits} \cdot 5)\), i.e. a few hundred operations.

### 5) Counting the intersection `A2 ∩ A5` (CRT + modular inverse trick)

We need `i` such that:

* base-5 digits satisfy `digit_i >= digit_n` (Lucas for 5)
* bits satisfy `(i & n) == n` (Lucas for 2)

Write \(L\) for the number of base-5 digits of `n` and let \(B = 5^L\).
Any number satisfying the base-5 constraint can be written as:

\[
i = \text{low} + B\cdot h
\]

where `low < B` has the constrained digits and `h` contains the higher base-5
digits.

For this problem family (`n = 10^k - 10`), the number of admissible `low`
values is tiny (only a few thousand), because many base-5 digits of `n` are 4,
leaving only one choice per digit.

To force the low **binary** bits of `i`, we solve

\[
i \equiv \text{low} + B\cdot h \pmod{2^k}
\]

for `h`, where \(2^k\) is chosen just larger than the possible `h` range.
Since `B` is odd, it has an inverse modulo \(2^k\), so each allowed residue
for `i (mod 2^k)` maps to exactly one candidate `h`:

\[
h \equiv (i - \text{low}) \cdot B^{-1} \pmod{2^k}.
\]

We enumerate only the residues that satisfy the required 1-bits in the lowest
`k` bits, generate the corresponding `h` values, and then verify the full
`(i & n) == n` condition.

This keeps the intersection computation under ~1e6 simple operations.

## Complexity

All steps are tiny:

* `p=2` DP: ~60 iterations
* `p=5` DP: ~26 digits × 5 choices
* intersection: a few thousand `low` values × a few hundred residues

The whole solution runs comfortably in well under a second in Python.
