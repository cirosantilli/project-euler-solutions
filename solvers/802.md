# Project Euler 802 Solution - Iterated Composition

<https://projecteuler.net/problem=802>:

* [802.py](802.py)

This solution avoids numerical work with π entirely, even though the original map contains it.

## 1) Rewriting the 2D map as a complex polynomial

With `z = x + i y`, the given map

- `x' = x^2 - x - y^2`
- `y' = 2xy - y + π`

is exactly:

\[
F(z) = z^2 - z + i\pi.
\]

Periodic points of the 2D map correspond 1:1 with periodic points of \(F\) in the complex plane, and the requested sum of \(x\)-coordinates is the real part of a sum over complex periodic points.

## 2) A conjugation that kills the linear term

Shift by \(1/2\): write \(z = w + 1/2\). Then \(F\) becomes conjugate to

\[
G(w) = w^2 + d,\quad d = i\pi - 3/4,
\]

which has **no** linear term.

A crucial consequence is that every iterate \(G^{(n)}(w)\) is a polynomial containing **only even powers** of \(w\). (Squaring preserves even exponents, and adding a constant doesn’t introduce odd exponents.)

## 3) Sum of roots via the missing \(w^{\deg-1}\) coefficient

Consider the polynomial whose roots are points of period dividing \(n\):

\[
H_n(w) = G^{(n)}(w) - w.
\]

- \(H_n\) is monic of degree \(2^n\).
- For \(n \ge 2\), the coefficient of \(w^{2^n-1}\) is **zero**:
  - \(G^{(n)}(w)\) has only even powers, and \(2^n - 1\) is odd and larger than 1.
  - The only odd term in \(H_n\) is the `-w`, which has degree 1.

By Vieta’s formula, the sum of all roots of \(H_n\) is `-coeff(w^{deg-1})`, hence:

- \(\sum w = 0\) for \(n \ge 2\),
- and a small direct check handles \(n = 1\).

Translating back \(z = w + 1/2\), the sum over the corresponding \(z\)-roots is:

\[
\sum z = \sum w + 2^n \cdot \frac{1}{2} = 2^{n-1}\quad (n\ge 2),
\]

so the sum of **real parts** (the \(x\)-coordinates) for points with period dividing \(n\) is simply \(2^{n-1}\) for \(n\ge 2\), and 2 for \(n=1\).

Define:

- \(A(n)\) = sum of \(x\)-coordinates of all points with period dividing \(n\).

Then:

- \(A(1)=2\),
- \(A(n)=2^{n-1}\) for \(n\ge 2\).

This is why π disappears: the required sum depends only on the *shape* of the quadratic iteration, not on the constant term.

## 4) Möbius inversion: from “dividing \(n\)” to “exactly \(n\)”

Let:

- \(S(n)\) = sum of \(x\)-coordinates of points with **exact** period \(n\).

Every point of period dividing \(n\) has exact period \(d\) for some divisor \(d\mid n\), so:

\[
A(n) = \sum_{d\mid n} S(d).
\]

Möbius inversion gives:

\[
S(n) = \sum_{d\mid n} \mu\!\left(\frac{n}{d}\right) A(d),
\]

where \(\mu\) is the Möbius function.

The problem asks:

\[
P(N) = \sum_{n\le N} S(n).
\]

Reordering the double sum yields a classic convolution with the **Mertens function**
\(M(t)=\sum_{k\le t}\mu(k)\):

\[
P(N) = \sum_{d\le N} A(d)\, M\!\left(\left\lfloor \frac{N}{d}\right\rfloor\right).
\]

## 5) Efficient evaluation

Two standard techniques make \(N=10^7\) feasible in pure Python:

1. **Linear sieve** to compute \(\mu(n)\) for all \(n\le N\), while tracking the Mertens prefix sum.
2. **Floor-division grouping** (“harmonic lemma”):
   values of \(\left\lfloor N/d\right\rfloor\) repeat over ranges, and there are only \(O(\sqrt N)\) distinct values.
   Over each range \([l,r]\), \(A(d)\) is a power of two, so the range sum has a closed form.

The implementation computes:
- Mertens values only at the needed \(\left\lfloor N/d\right\rfloor\) points,
- then evaluates the grouped sum modulo the required modulus.

---
Run `python3 main.py` to print the required result (modulo the given modulus).
