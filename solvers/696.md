# Project Euler 696 Solution - Mahjong

<https://projecteuler.net/problem=696>:

* [696.py](696.py)

This solution counts **distinct winning hands** (tile multisets), not the number of different decompositions into chows/pungs.

## Key ideas

### 1) Model one suit as a language over `{0,1,2,3,4}`
For a fixed suit, each number `i` contributes `c_i ∈ {0..4}` tiles.  
A suit-hand is a string `c_1 … c_n`.

A valid hand must be decomposable into:

- **Pungs**: `3×` the same tile
- **Chows**: one tile each from three consecutive numbers
- optionally **one Pair**: `2×` the same tile

### 2) NFA for “decomposable” prefixes, then determinize (DFA)
Process numbers from left to right and track how many chows are “in flight”:

- `a`: chows started at `i-1` that need one tile at `i`
- `b`: chows started at `i-2` that need one tile at `i` to finish
- `p`: whether the pair has already been used

Given `c_i`, we must allocate all tiles at `i` to:
- finish pending chows (`a+b` tiles),
- start new chows,
- make pungs,
- maybe make the pair (at most once).

This naturally gives an **NFA** (multiple allocations can work for the same `c_i`).  
Since we must count **strings** (multisets) and not **paths** (decompositions), the NFA is determinized into a **DFA** using subset construction.

### 3) Exploit that only ≤ `3t+2` tiles matter
For the final problem `t=30`, any single suit can contribute at most `3t+2 = 92` tiles (otherwise it would already exceed the total triples/pair budget).

With `n` as large as `10^8`, almost all `c_i` must be zero, so the string consists of a few **blocks**:

- a **block** is a maximal run of positive symbols (`1..4`),
- blocks are separated by at least one `0`.

Because a `0` forces all pending chows to be finished, blocks are independent.

### 4) Count blocks by `(length, tiles)` and place them with stars-and-bars
Using the DFA, we count:

- `H[L][T]`: blocks that end with **no pending chows** and **no pair used**
- `J[L][T]`: blocks that end with **no pending chows** and **pair used**

Then, for a suit made of `B` blocks with total positive length `L`:

- the number of ways to place those blocks among `n` numbers (with ≥1 zero between blocks) is:

`C(n - L + 1, B)`.

Finally, we convert “tiles” to “triples” via:
- no pair: `T = 3k`
- with pair: `T = 3k + 2`

yielding per-suit polynomials:
- `A_k` = ways to contribute `k` triples and no pair
- `B_k` = ways to contribute `k` triples and one pair

### 5) Combine suits with a truncated polynomial power
A global hand has exactly one pair in exactly one suit:

- choose the suit with the pair: factor `s`
- that suit contributes `B_k`
- the other `s-1` suits contribute triples via `A(x)^(s-1)`

Only degree `t` is needed, so polynomial multiplication is truncated to degree `t`.

---

Files:
- `main.py` contains the full implementation and the asserts from the statement.
