# Project Euler 272 Solution - Modular Cubes, Part 2

<https://projecteuler.net/problem=272>:

* [272.py](272.py)

We want all `n ≤ 10^11` such that

> `C(n) = #{ x : 1 < x < n and x^3 ≡ 1 (mod n) } = 242`.

Because `x = 1` is always a solution, this is the same as asking for **243** total cube roots of unity modulo `n`.

## Key ideas used

### 1) Count cube roots via prime powers + CRT

Let `R(n)` be the number of solutions to `x^3 ≡ 1 (mod n)`.

* For a prime power `p^a`, any solution must be a unit.
* For odd primes, `(Z / p^a Z)^*` is cyclic, so the number of solutions to `x^3 = 1` equals `gcd(3, φ(p^a))`.
* This implies:
  - If `p ≡ 1 (mod 3)`, then `gcd(3, φ(p^a)) = 3` for all `a ≥ 1`.
  - If `p ≡ 2 (mod 3)` (or `p = 2`), then the count is `1`.
  - For `p = 3`, the count is `1` when `a = 1` and `3` when `a ≥ 2`.

By the Chinese Remainder Theorem, `R(n)` is multiplicative, so it becomes a product of `1`s and `3`s.

Therefore:

* `R(n) = 3^k`, where `k` is the number of **distinct** prime factors contributing a `3`:
  - primes `p ≡ 1 (mod 3)` (any exponent),
  - plus the prime `3` if its exponent is at least `2`.

We need `R(n) = 243 = 3^5`, i.e. **exactly five** such “good” primes.

### 2) Split `n` into a good part and an inert part

Write:

* `n = g · b`
* `g` contains exactly 5 good primes (with any exponents ≥ 1, and for `3` the exponent ≥ 2 if included as a good prime)
* `b` contains only “inert” primes (no prime `≡ 1 (mod 3)`, and at most one factor of `3` — i.e. **not divisible by 9**)

Then every valid `g` contributes:

* `g · (sum of all valid b ≤ N/g)`.

### 3) Precompute inert sums with a sieve + prefix sums

The smallest possible `g` is `3^2·7·13·19·31 = 482391`, so `b ≤ 10^11 / g ≤ 207300`.

That’s small enough to:

* sieve all `b` up to `207300`,
* mark disallowed values (multiples of primes `≡ 1 (mod 3)` and multiples of `9`),
* build prefix sums:
  - `pref_allow3[t] = Σ b` (allows a single factor of `3`),
  - `pref_no3[t] = Σ b` (also forbids multiples of `3`),
    used when `g` already contains `3^a (a ≥ 2)` so `b` must not add another `3`.

### 4) Enumerate good parts with DFS + pruning

We enumerate products of distinct good primes with exponents:

* **Case A:** `3` is good (`3^a, a≥2`) + 4 primes `≡ 1 (mod 3)`
* **Case B:** 5 primes `≡ 1 (mod 3)` (no good `3`)

The DFS uses a small pruning table `min_prod[k][i]` = product of the `k` smallest remaining primes starting at index `i`.
If even the minimal possible completion exceeds `N`, we stop the loop early.

## Output

Running `main.py` prints the required sum:

`8495585919506151122`.
