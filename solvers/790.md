# Project Euler 790 Solution - Clock Grid

<https://projecteuler.net/problem=790>:

* [790.py](790.py)

The grid is far too large to simulate directly. The key observations and techniques are:

## 1) Order doesn’t matter: reduce to rectangle overlap counts
Each step increments clocks inside a rectangle, and the hour after all updates depends only on the **number of increments** at each point modulo 12.  
So instead of simulating time, we compute for every grid point how many of the first `t` rectangles cover it (mod 12).

## 2) Discrete coordinate compression
Rectangles are defined by pseudo-random endpoints. Only rectangle boundaries can change the overlap count, so we compress:

- all `y_lo` and `y_hi+1` boundaries (plus `0` and `M`)
- all `x_lo` and `x_hi+1` boundaries (plus `0` and `M`)

This turns the enormous grid into a manageable number of **x-stripes** and **y-segments**, while preserving exact point counts.

## 3) Sweep line over x with a lazy segment tree over y
We sweep increasing `x`:

- At `x_lo` a rectangle becomes active (`+1` on its y-interval).
- At `x_hi+1` it stops being active (`-1` on its y-interval).

A segment tree over compressed y-segments maintains, for each node, **12 buckets**:
`len[r]` = how many y-points in that node currently have overlap count `≡ r (mod 12)`.

Range updates add `±1` to overlap counts, which is just a **rotation of the 12 buckets**.
Lazy propagation stores pending rotations, keeping updates `O(log N)`.

For each x-stripe of width `w`, the root buckets give the y-length per residue, so we add `w * len[r]` into the global residue counts.

## 4) Convert residues to hour-sum
If the overlap residue is:

- `0` → the clock shows `12`
- `r = 1..11` → the clock shows `r`

The final answer is the weighted sum over all residues.

## Complexity
Let `R = t` rectangles.

- unique x boundaries: `O(R)`
- unique y boundaries: `O(R)`
- events: `2R`
- sweep updates: `O(R log R)` (segment tree factor from y)

This is fast enough for `t = 10^5` in pure Python with careful memory use.
