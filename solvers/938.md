# Project Euler 938 Solution - Exhausting a Colour

<https://projecteuler.net/problem=938>:

* [938.py](938.py)

This repository contains a single-file solution (`main.py`) that computes the probability

> **P(R,B)** = probability that the game ends with **only black cards** remaining,

under the rules given in the problem statement.

The program prints the required value for `P(24690,12345)` with **10 digits after the decimal point**,
and it includes assertions for the sample values provided in the statement.

## Main techniques used

### 1) Remove the “do-nothing” self-loop
Drawing two black cards (`BB`) leaves the deck unchanged, which would create a self-loop in a direct
Markov recurrence. Writing the usual expectation equation and rearranging eliminates that self-loop:

\[
P(r,b) = \frac{(r-1)\,P(r-2,b) + 2b\,P(r,b-1)}{(r-1)+2b}
\]

This recurrence is valid for `r >= 2` and `b >= 1` (with boundary values `P(0,b)=1` and `P(r,0)=0`).

### 2) Parity invariant (odd number of reds can’t vanish)
Red cards are only discarded in pairs (`RR`). Therefore, the parity of `R` never changes.
If `R` is odd, it is impossible to reach `R = 0`, so the probability of ending all-black is **0**.
This trims the state space and lets us write `R = 2a`.

### 3) Convert to a Pascal-style recurrence by renormalizing
With `R = 2a`, define `F(a,b) = P(2a,b)`. The recurrence becomes

\[
F(a,b) = \frac{(2a-1)F(a-1,b) + 2bF(a,b-1)}{(2a-1)+2b}.
\]

Multiplying by a carefully chosen factor

\[
C(a,b) = \frac{\Gamma(a+b+\tfrac12)}{\Gamma(a+\tfrac12)\,\Gamma(b+1)}
\]

turns it into a simple **Pascal recursion**:

\[
U(a,b) = U(a-1,b) + U(a,b-1),\quad\text{where }U(a,b)=C(a,b)F(a,b).
\]

This is powerful because Pascal recurrences have closed-form solutions as sums of binomial-weighted
boundary terms.

### 4) Closed-form sum and stable numeric evaluation
Using the boundary values, one obtains

\[
U(a,b) = \sum_{k=1}^{b} \Big(\frac{\binom{2k}{k}}{4^k}\Big)\binom{a+b-k-1}{a-1}.
\]

Finally,

\[
F(a,b) = \frac{U(a,b)}{C(a,b)}.
\]

The code evaluates the sum in **log-space**:

- `math.lgamma` gives \(\log\Gamma(\cdot)\), so large binomial coefficients are computed without huge integers.
- A streaming **log-sum-exp** accumulation avoids overflow/underflow.

This yields an **O(B)** time, **O(1)** memory solution for the required input size.

## Running

```bash
python3 main.py
```

Or with custom `R B`:

```bash
python3 main.py 34 25
```
