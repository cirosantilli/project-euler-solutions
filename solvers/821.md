# Project Euler 821 Solution - 123-Separable

<https://projecteuler.net/problem=821>:

* [821.py](821.py)

This repository contains a single-file solver (`main.py`) for the problem:

- A set **S** is **123-separable** if **S**, **2S**, and **3S** are pairwise disjoint.
- Define **F(n)** as the maximum size of  
  \[(S \cup 2S \cup 3S) \cap \{1,2,\dots,n\}\]
  over all 123-separable sets **S**.
- Compute **F(10¹⁶)**.

## Core ideas

### 1) Split integers into independent “k-blocks”

Every positive integer has a unique factorization

\[
x = 2^a\,3^b\,k \quad\text{with}\quad \gcd(k,6)=1.
\]

Multiplying by 2 or 3 only increases \(a\) or \(b\); it never changes \(k\).  
So elements with different \(k\) values cannot collide between **S**, **2S**, and **3S**.  
That means we can optimize independently for each \(k\), then add the results.

For a fixed \(k\), the relevant numbers are \(k\cdot 2^a3^b \le n\), i.e. \(2^a3^b \le \lfloor n/k \rfloor\).
Let:

- **H(N)** = maximum number of covered values among \(\{2^a3^b \le N\}\).

Then:

\[
F(n) = \sum_{\substack{1\le k\le n\\ \gcd(k,6)=1}} H\!\left(\left\lfloor \frac{n}{k}\right\rfloor\right).
\]

### 2) Geometric view: packing L-shaped triominoes

Represent each smooth number \(2^a3^b\) as the lattice point \((a,b)\).  
Choosing an element \(2^a3^b\in S\) forces the three numbers

- \(2^a3^b\) (in **S**),
- \(2^{a+1}3^b\) (in **2S**),
- \(2^{a}3^{b+1}\) (in **3S**),

to be used exactly once and never overlap any other choice.  
On the lattice, that is an L-shaped triomino covering \((a,b)\), \((a+1,b)\), and \((a,b+1)\).

Maximizing **H(N)** becomes a “most-covered-squares” packing problem in the region
\(\{(a,b): 2^a3^b \le N\}\).

### 3) An almost-complete packing with a tiny set of forced holes

For this problem, there is a very regular packing that covers *all but a sparse, explicit list*
of smooth numbers. Those missing values (“holes”) start as:

- 6, 24, 54, …

and then continue with two geometric progressions.  
`main.py` generates the hole list up to the needed limit and uses:

\[
H(N) = \#\{2^a3^b \le N\} - \#\{\text{holes} \le N\}.
\]

For small limits (up to 48), `main.py` computes **H(N)** exactly by enumerating all subsets of
anchors; after that, the closed-form hole counting is used.

### 4) Fast summation by grouping equal H(⌊n/k⌋)

The value **H(t)** only changes when \(t\) crosses a new smooth number \(2^a3^b\).  
So instead of iterating over all \(k\), we iterate over intervals of quotients where **H** is constant.

For each consecutive pair of smooth breakpoints \([L, R]\), all \(k\) such that

\[
\left\lfloor \frac{n}{k}\right\rfloor \in [L,R]
\]

lie in a single integer range:

\[
\left\lfloor\frac{n}{R+1}\right\rfloor + 1 \;\le\; k \;\le\; \left\lfloor\frac{n}{L}\right\rfloor.
\]

We also need \(k\) coprime to 6, counted by inclusion–exclusion:

\[
\#\{k\le m:\gcd(k,6)=1\} = m - \left\lfloor\frac m2\right\rfloor - \left\lfloor\frac m3\right\rfloor + \left\lfloor\frac m6\right\rfloor.
\]

This makes the overall runtime tiny: the number of breakpoints is only \(O(\log^2 n)\).

## Running

```bash
python3 main.py
```

The script includes assertions for the two sample values from the statement and prints **F(10¹⁶)**.
