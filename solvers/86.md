# Project Euler 86 Solution - Cuboid Route

<https://projecteuler.net/problem=86>:

* [86.py](86.py)
* [86.lean](86.lean)

For a cuboid with integer sides `(a, b, c)` (ignoring rotations), we count it once by ordering
`1 ≤ a ≤ b ≤ c ≤ M`.

A shortest surface path between opposite corners can be found by “unfolding” two faces.
There are three candidates:
- `sqrt((a+b)^2 + c^2)`
- `sqrt((a+c)^2 + b^2)`
- `sqrt((b+c)^2 + a^2)`

When `a ≤ b ≤ c`, the first one is always minimal because:
- `((a+c)^2 + b^2) - ((a+b)^2 + c^2) = 2a(c-b) ≥ 0`
- `((b+c)^2 + a^2) - ((a+b)^2 + c^2) = 2b(c-a) ≥ 0`

So we only need to test whether `((a+b)^2 + c^2)` is a perfect square.

For each fixed largest side `c`, let `s = a + b` with `2 ≤ s ≤ 2c`.
If `s^2 + c^2` is a square, we add the number of valid pairs `(a, b)`:
- `a+b = s`
- `1 ≤ a ≤ b ≤ c`

Counting those pairs is done by:
- `a ≥ max(1, s-c)` (to keep `b = s-a ≤ c`)
- `a ≤ floor(s/2)` (to keep `a ≤ b`)
So the count is `max(0, floor(s/2) - max(1, s-c) + 1)`.

We incrementally increase `c = M` and accumulate counts until the total exceeds `1,000,000`.
This runs in about `O(M^2)` checks, easily fast enough for the required range.
