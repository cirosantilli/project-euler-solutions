#!/usr/bin/env python3
# Generated by GPT-5.2 Thinking web UI on 2025-12-24.
"""
Project Euler 177
Integer angled quadrilaterals.

We enumerate integer splits of each vertex angle by the diagonals:
  (a1,a2,b1,b2,c1,c2,d1,d2)
and enforce:
- the 4 triangle angle-sum constraints induced by both diagonals
- convexity (each interior angle < 180)
- a sine-product compatibility constraint that ensures consistent scaling:
    sin(c1)*sin(d1)*sin(a1)*sin(b1) = sin(a2)*sin(b2)*sin(c2)*sin(d2)

We count up to similarity, factoring out dihedral symmetries (rotations+reflections).
"""

from __future__ import annotations

import math
from typing import Dict, List, Tuple

Angles = Tuple[int, int, int, int, int, int, int, int]


def canon_dihedral(t: Angles) -> Angles:
    """
    Canonical representative under dihedral symmetries (4 rotations + 4 reflections).
    t = (a1,a2,b1,b2,c1,c2,d1,d2).
    """
    a1, a2, b1, b2, c1, c2, d1, d2 = t

    r0 = t
    r1 = (b1, b2, c1, c2, d1, d2, a1, a2)
    r2 = (c1, c2, d1, d2, a1, a2, b1, b2)
    r3 = (d1, d2, a1, a2, b1, b2, c1, c2)

    # Reflection reverses vertex order and swaps the split angles at each vertex.
    f0 = (a2, a1, d2, d1, c2, c1, b2, b1)
    f1 = (b2, b1, a2, a1, d2, d1, c2, c1)
    f2 = (c2, c1, b2, b1, a2, a1, d2, d1)
    f3 = (d2, d1, c2, c1, b2, b1, a2, a1)

    return min(r0, r1, r2, r3, f0, f1, f2, f3)


def is_integer_angled_quadrilateral(t: Angles, tol: float = 1e-12) -> bool:
    a1, a2, b1, b2, c1, c2, d1, d2 = t
    if any(x <= 0 or x >= 180 for x in t):
        return False

    # Triangle sums:
    # ABC: a2 + (b1+b2) + c1 = 180
    # ABD: (a1+a2) + b1 + d2 = 180
    # ADC: a1 + (d1+d2) + c2 = 180
    # CBD: (c1+c2) + b2 + d1 = 180
    if a2 + b1 + b2 + c1 != 180:
        return False
    if a1 + a2 + b1 + d2 != 180:
        return False
    if a1 + d1 + d2 + c2 != 180:
        return False
    if c1 + c2 + b2 + d1 != 180:
        return False

    # Convexity (interior angles < 180):
    if a1 + a2 >= 180 or b1 + b2 >= 180 or c1 + c2 >= 180 or d1 + d2 >= 180:
        return False

    s = [0.0] * 181
    for i in range(181):
        s[i] = math.sin(math.radians(i))

    lhs = s[c1] * s[d1] * s[a1] * s[b1]
    rhs = s[a2] * s[b2] * s[c2] * s[d2]
    return abs(lhs - rhs) <= tol


def solve() -> int:
    sinv = [0.0] * 181
    for i in range(181):
        sinv[i] = math.sin(math.radians(i))

    SCALE = 1e11
    tol = 1e-12

    sols = set()

    for a2 in range(1, 179):
        sin_a2 = sinv[a2]
        for b1 in range(1, 179 - a2):
            sin_b1 = sinv[b1]

            max_b2 = 179 - a2 - b1  # b2>=1 and c1=180-a2-b1-b2>=1
            if max_b2 <= 0:
                continue

            # c2 in 1..a2+b1-1 gives d1 = a2+b1-c2 in 1..a2+b1-1
            max_c2 = a2 + b1 - 1
            if max_c2 <= 0:
                continue

            # Map key -> list of c2 values for M = sin(d1)/sin(c2)
            M_map: Dict[int, List[int]] = {}
            for c2 in range(1, max_c2 + 1):
                d1 = a2 + b1 - c2
                key = int((sinv[d1] / sinv[c2]) * SCALE + 0.5)
                M_map.setdefault(key, []).append(c2)

            # Precompute for each b2: c1 and invL = sin(b2)/sin(c1)
            L_list: List[Tuple[int, int, float, float, float]] = []
            for b2 in range(1, max_b2 + 1):
                c1 = 180 - a2 - b1 - b2
                invL = sinv[b2] / sinv[c1]
                L_list.append((b2, c1, invL, sinv[b2], sinv[c1]))

            max_a1 = 179 - a2 - b1  # a1>=1 and d2=180-a1-a2-b1>=1
            for a1 in range(1, max_a1 + 1):
                sin_a1 = sinv[a1]
                d2 = 180 - a1 - a2 - b1
                sin_d2 = sinv[d2]

                # R = sin(a2)sin(d2)/(sin(a1)sin(b1))
                R_scaled = (sin_a2 * sin_d2) / (sin_a1 * sin_b1) * SCALE

                for b2, c1, invL, sin_b2, sin_c1 in L_list:
                    needed_key = int(R_scaled * invL + 0.5)
                    c2_list = M_map.get(needed_key)
                    if not c2_list:
                        continue

                    for c2 in c2_list:
                        # Extra quick feasibility: triangle ADC needs 180-a1-c2 > 0
                        if a1 + c2 >= 180:
                            continue

                        d1 = a2 + b1 - c2

                        # Verify sine-product equality to reject hash rounding collisions
                        lhs = sin_c1 * sinv[d1] * sin_a1 * sin_b1
                        rhs = sin_a2 * sin_b2 * sinv[c2] * sin_d2
                        if abs(lhs - rhs) > tol:
                            continue

                        # Convexity already checked via sums, but keep safe:
                        if (
                            a1 + a2 >= 180
                            or b1 + b2 >= 180
                            or c1 + c2 >= 180
                            or d1 + d2 >= 180
                        ):
                            continue

                        t: Angles = (a1, a2, b1, b2, c1, c2, d1, d2)
                        sols.add(canon_dihedral(t))

    return len(sols)


def _assert_examples() -> None:
    # Statement: square example -> all eight angles 45Â°
    square: Angles = (45, 45, 45, 45, 45, 45, 45, 45)
    assert is_integer_angled_quadrilateral(square)

    # Statement example:
    # DAC=20, BAC=60, ABD=50, CBD=30, BCA=40, DCA=30, CDB=80, ADB=50
    example: Angles = (20, 60, 50, 30, 40, 30, 80, 50)
    assert is_integer_angled_quadrilateral(example)


if __name__ == "__main__":
    _assert_examples()
    print(solve())
