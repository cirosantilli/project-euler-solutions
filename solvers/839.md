# Project Euler 839 Solution - Beans in Bowls

<https://projecteuler.net/problem=839>:

* [839.py](839.py)

This repository contains a standalone Python solution (no third‑party libraries) for **Project Euler 839**.

## Core ideas

### 1) View the process as a directed “chip‑firing” stabilization
Each step moves one bean **one position to the right** at the leftmost inversion `a[i] > a[i+1]`.
The terminal condition is exactly that the sequence is **nondecreasing**.

Although simulating every move is impossible (the number of steps is enormous), the final stable state can be characterized and computed efficiently.

### 2) Block pooling (Pool Adjacent Violators, integer version)
Represent the final stable sequence as consecutive blocks.
A block has:
- length `L`
- total beans `T`

Inside a stable block, the “most left‑heavy” nondecreasing arrangement with sum `T` is as flat as possible:
- `base = T // L`
- `rem  = T % L`
- values are `base` repeated `L-rem` times, then `base+1` repeated `rem` times.

For two adjacent blocks `A` then `B`, the entire sequence remains nondecreasing iff

- `last(A) <= first(B)`

With the block layout above:
- `last(A)  = ceil(TA/LA)`
- `first(B) = floor(TB/LB)`

So the condition is:

- `ceil(TA/LA) <= floor(TB/LB)`

If it fails, the two blocks must be merged (their sums and lengths add), and the check repeats backward. This is the classic **PAV** stack merge pattern, giving amortized **O(N)** time.

### 3) Count moves via a conserved potential
Define the potential

- `P = sum(i * a[i])`

A single move transfers one bean from `i` to `i+1`, increasing `P` by exactly **1**.
Therefore:

- `B(N) = P_final - P_initial`

This avoids tracking per‑boundary flow or simulating steps.

### 4) Streaming generation
The pseudo‑random initial counts `S_n` are generated on the fly from the recurrence, so the program never stores the full length‑`N` array.

## What the code does
- Streams `S_0 .. S_{N-1}`.
- Maintains a stack of pooled blocks (length, sum).
- After processing all `N`, computes `P_final` directly from blocks using arithmetic‑series formulas.
- Prints `B(10^7)`.

The asserts in `main.py` check the example values given in the problem statement.
