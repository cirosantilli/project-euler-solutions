# Project Euler 245 Solution - Coresilience

<https://projecteuler.net/problem=245>:

* [245.py](245.py)

# Coresilience (Project Euler style)

## Key observations
- If `n = A * m` where `A` is the product of distinct primes and `m` is the remaining prime powers, then `n - φ(n) = (A - B) * m` with `B = ∏(p-1)`.  
  The divisibility `n - φ(n) | n - 1` forces `m = 1`, so **all valid `n` are squarefree**.
- For squarefree `n = ∏ p`, we have `φ(n) = B` and `n - φ(n) = A - B`.  
  The unit fraction condition is equivalent to **`A - B` dividing `B - 1`**.
- Adding a new prime `r` to a partial product `(A, B)` yields a linear condition that can be solved
  with a small integer `u`:
  `r = (B(u+1)+1)/(B - u(A-B))`.  
  Using monotonicity of `r(u)` gives tight bounds for `u`.

## Algorithm
1. **Semiprimes (`k = 2`)**  
   For primes `p < q`, let `d = p + q - 1`. Then `d` must divide `p^2 - p + 1`.  
   Factor `p^2 - p + 1` (Pollard Rho) and test each divisor `d` to get candidate `q`.
2. **`k >= 3` primes**  
   Recursively pick `k-1` primes `p1 < ... < p_{k-1}`.  
   From `(A, B)` compute all admissible `u` and derive `r` with the formula above.  
   Check primality and the divisibility condition.
3. Sum all valid composite `n <= 2e11`.

The recursion uses a power bound: if `remaining` primes are still needed and the next prime is `p`,
the minimal possible product is `A * p^(remaining+1)`. This bounds the search space tightly.

## Complexity
- Sieve up to `sqrt(2e11) ≈ 4.5e5`.
- Semiprime phase factors ~`4e4` values near `p^2` using Pollard Rho.
- Recursion over higher `k` is small due to the power bound.

All computations complete in a few seconds on PyPy3.
