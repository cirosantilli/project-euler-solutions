# Project Euler 552 Solution - Chinese Leftovers II

<https://projecteuler.net/problem=552>:

* [552.py](552.py)

## Core idea

We build the sequence \(A_n\) incrementally using the **Chinese Remainder Theorem** (CRT).

Let \(P_{n-1} = \prod_{i=1}^{n-1} p_i\).  
If we already have \(A_{n-1}\) satisfying all constraints up to \(p_{n-1}\), then

- \(A_n \equiv A_{n-1} \pmod{P_{n-1}}\)
- \(A_n \equiv n \pmod{p_n}\)

So \(A_n = A_{n-1} + tP_{n-1}\) for some \(t\), and we solve

\[
A_{n-1} + tP_{n-1} \equiv n \pmod{p_n}
\]

Because \(p_n\) is prime and \(\gcd(P_{n-1}, p_n)=1\), we can compute

\[
t \equiv (n - A_{n-1}) \cdot (P_{n-1}^{-1} \bmod p_n) \pmod{p_n}
\]

using a modular inverse (via Fermat: \(x^{-1} \equiv x^{p-2} \bmod p\)).

This gives the exact (big-integer) \(A_n\) and the running product \(P_n\).

## Finding which primes divide *any* \(A_n\)

A prime \(q\) can only divide \(A_n\) while itâ€™s **not yet among the first \(n\) primes**, because if \(q=p_i\) is already constrained then
\(A_n \bmod q = i \ne 0\).

We want all primes \(q \le 300000\) that divide at least one \(A_n\). Checking every \(q\) separately is too slow, so we use **block modular tracking**:

- Split all primes \(\le N\) into blocks (size 64 in this solution).
- For each block with modulus \(M = \prod q\) (squarefree), maintain:
  - \(a \equiv A \pmod M\)
  - \(p \equiv P \pmod M\)

When we update \(A \leftarrow A + tP\) and \(P \leftarrow P\cdot p_n\), we also update each block:

- \(a \leftarrow (a + t\cdot p)\bmod M\)
- \(p \leftarrow (p\cdot p_n)\bmod M\)

Now, any prime divisor inside the block is revealed by:

\[
\gcd(a, M)
\]

Because \(M\) is a product of distinct primes, the gcd is exactly the product of the primes in that block that divide the current \(A_n\).

## Shrinking block moduli

At step \(n\), every prime \(\le p_n\) can never divide \(A_n\) (or any future \(A_k\)), so we remove those primes from the relevant block by dividing them out of \(M\) and reducing the stored residues modulo the smaller modulus.

This keeps block moduli small as \(n\) grows, making the whole computation fast enough in pure Python.

## Complexity notes

- Prime generation: sieve up to 300000.
- CRT steps: about 26000 iterations.
- Block operations: many cheap modular updates + a gcd against a small-ish modulus, with the modulus shrinking over time.

The final output printed by `main.py` is \(S(300000)\).
