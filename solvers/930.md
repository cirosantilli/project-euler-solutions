# Project Euler 930 Solution - The Gathering

<https://projecteuler.net/problem=930>:

* [930.py](930.py)

This solution computes
\(G(12,12)=\sum_{n=2}^{12}\sum_{m=2}^{12} F(n,m)\), where \(F(n,m)\) is the expected number of moves until all \(m\) balls are in the same bowl.

## Key ideas

### 1) Reduce to relative positions
Because the bowls form a cycle, adding the same offset to every ball’s position doesn’t change the process.
Fix ball 1 as a reference and track the differences

\[
 d_i = x_i - x_1 \pmod n \quad (i=2..m).
\]

The process stops exactly when all differences are \(0\), i.e. when the state is the origin in \((\mathbb{Z}_n)^{m-1}\).
With the random initial placement, the difference vector is **uniform** over \((\mathbb{Z}_n)^{m-1}\).

### 2) View it as a random walk on an abelian group
In the difference coordinates (dimension \(d=m-1\)) each step is:

- pick one of the \(d\) coordinates and add \(\pm 1\) (moving a non-reference ball), or
- add \(\pm(1,1,\dots,1)\) (moving the reference ball),

each with probability \(1/(2m)\).
So we have a translation-invariant random walk on the finite abelian group \(G=(\mathbb{Z}_n)^d\).

### 3) Use Fourier diagonalisation (characters)
For translation-invariant walks on a finite abelian group, the eigenvectors are the group characters.
Index characters by \(k=(k_1,\dots,k_d)\in (\mathbb{Z}_n)^d\). The corresponding eigenvalue is

\[
\lambda_k = \frac{1}{m}\left(\sum_{j=1}^{d}\cos\frac{2\pi k_j}{n} + \cos\frac{2\pi (k_1+\dots+k_d)}{n}\right).
\]

A standard spectral identity for the expected **hitting time of the origin from the uniform start** gives

\[
F(n,m) = \sum_{k\neq 0}\frac{1}{1-\lambda_k}.
\]

(This matches the exact sample values in the statement.)

### 4) Count frequencies instead of iterating all \(n^{m-1}\) vectors
Directly summing over all \(k\) is impossible when \(n^{m-1}\) is huge.
But \(\lambda_k\) only depends on:

- how many coordinates equal each residue \(r\in\{0,\dots,n-1\}\), and
- the residue of \(k_1+\dots+k_d\pmod n\).

So we enumerate **compositions** (count vectors) \(c_r\) with \(\sum_r c_r=d\) (a “stars and bars” enumeration).
For each count vector:

- the sum \(\sum_j \cos(2\pi k_j/n)\) becomes \(\sum_r c_r\cos(2\pi r/n)\),
- the modulo-sum becomes \(\sum_r c_r r \pmod n\),
- the number of \(k\)-vectors with those counts is the multinomial coefficient
  \(\frac{d!}{\prod_r c_r!}\), computed incrementally using binomial coefficients.

This reduces the worst case from \(12^{11}\) possibilities to
\(\binom{11+12-1}{12-1}=705{,}432\) count-vectors.

### 5) Numerical care
All terms are positive (no cancellation), but the sum can be large.
The implementation uses **Kahan summation** to reduce floating-point accumulation error.

## Running

```bash
python3 main.py
```

`main.py` also includes `assert` checks for all numerical examples given in the problem statement.
