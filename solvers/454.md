# Project Euler 454 Solution - Diophantine Reciprocals III

<https://projecteuler.net/problem=454>:

* [454.py](454.py)

We count the number of integer solutions to:

\[
\frac1x + \frac1y = \frac1n
\]

with **positive integers** \(x,y,n\) and the bound \(x<y\le L\). The required value is \(F(10^{12})\).

## Key techniques

### 1) Algebraic reformulation and a coprime parametrization
Starting from:

\[
\frac{1}{x}+\frac{1}{y}=\frac{1}{n}
\quad\Longleftrightarrow\quad
xy = n(x+y)
\]

Write \(x=g\,m,\;y=g\,k\) with \(\gcd(m,k)=1\). Then:

\[
n=\frac{xy}{x+y}=\frac{gmk}{m+k}
\]

Because \(\gcd(m+k,m)=\gcd(m+k,k)=1\), we get \((m+k)\mid g\). Let \(g=t(m+k)\). Then:

\[
x=t\,m(m+k),\qquad y=t\,k(m+k),\qquad \gcd(m,k)=1
\]

So solutions are counted by triples \((m,k,t)\) with \(\gcd(m,k)=1\), \(m<k\), and \(t\,k(m+k)\le L\).

After reindexing \(s=m+k\), the core sum becomes:

\[
F(L)=\sum_{n\le \sqrt{L}}\;\sum_{s=n+1}^{2n-1}\Big\lfloor\frac{L}{ns}\Big\rfloor\cdot [\gcd(n,s)=1]
\]

where \([P]\) is 1 if \(P\) holds, else 0.

### 2) Möbius inversion to remove the gcd condition
Use the identity:

\[
[\gcd(n,s)=1] = \sum_{d\mid \gcd(n,s)} \mu(d)
\]

This converts the coprimality test into a divisor sum over squarefree divisors \(d\) (those with \(\mu(d)\ne 0\)).

A further simplification (using \(d\mid n\) and substituting \(k=n/d\)) reduces the needed range in the inner sum to a short segment \(i\in(k,2k)\).

### 3) Fast floor-division summation (“harmonic” grouping)
We repeatedly need sums of the form:

\[
\sum_{i=a}^{b}\left\lfloor\frac{x}{i}\right\rfloor
\]

The quotient \(q=\left\lfloor x/i\right\rfloor\) stays constant on intervals, so we can jump in **blocks**:

- compute \(q=x//i\)
- the last index with that quotient is \(j=x//q\)
- add \(q\cdot(j-i+1)\) and continue at \(i=j+1\)

This computes a whole segment in roughly \(O(\#\text{distinct quotients})\), typically about \(O(\sqrt{x})\), and is fast enough for \(L=10^{12}\).

## Complexity (high level)
- Outer loop: \(n\le\sqrt{L}=10^6\)
- For each \(n\), we enumerate its **squarefree** divisors (about \(2^{\omega(n)}\), small on average)
- Each contribution uses the block-jumping floor-sum

This is an efficient implementation of the standard Möbius + divisor-sum compression approach for this family of Euler problems.

## Files
- `main.py` — computes `F(L)` and prints `F(10^12)` by default. It also asserts the statement checks `F(15)=4` and `F(1000)=1069`.
