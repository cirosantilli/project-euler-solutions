# Project Euler 468 Solution - Smooth Divisors of Binomial Coefficients

<https://projecteuler.net/problem=468>:

* [468.py](468.py)

This repository solves **Project Euler 468**:

\[
F(n) = \sum_{B=1}^{n}\ \sum_{r=0}^{n} S_B\!\left(\binom{n}{r}\right)
\quad (\bmod\ 1{,}000{,}000{,}993)
\]

where \(S_B(x)\) is the *largest* divisor of \(x\) whose prime factors are all \(\le B\).

## Key techniques used

### 1) Only primes matter for the \(B\)-sum
For fixed \(x\), \(S_B(x)\) depends only on which primes are \(\le B\). Between consecutive primes, the value is constant.

Let primes \(\le n\) be \(p_0 < p_1 < \dots < p_{m-1}\). Define interval lengths:

- \(w_i = p_{i+1}-p_i\) for \(i < m-1\)
- \(w_{m-1} = n - p_{m-1} + 1\)

Then for any binomial coefficient value,
\[
\sum_{B=1}^{n} S_B(\cdot)
= 1 \; + \; \sum_{i=0}^{m-1} w_i \cdot \prod_{j=0}^{i} p_j^{e_{p_j}}
\]
where \(e_p\) is the exponent of prime \(p\) in \(\binom{n}{r}\).

So we reduce “sum over **all** \(B\)” into a **weighted sum of prefix products over primes**.

### 2) Walk across \(r\) using the multiplicative binomial recurrence
\[
\binom{n}{r+1}=\binom{n}{r}\cdot \frac{n-r}{r+1}
\]

Prime exponents update by adding the factorization of \((n-r)\) and subtracting that of \((r+1)\).
Fast factorization is enabled by a **smallest-prime-factor sieve (SPF)**.

### 3) Segment tree for “weighted sum of prefix products”
Let \(A_i = p_i^{e_{p_i}} \pmod M\). We need:
\[
\sum_{i=0}^{m-1} w_i \cdot \prod_{j=0}^{i} A_j
\]

A segment tree node stores a pair:

- `prod`: \(\prod A\) over the segment
- `sum`: weighted sum of prefix products inside the segment, assuming incoming prefix product is 1

Combine left \(L\) and right \(R\) segments:

- `prod = prodL * prodR`
- `sum  = sumL + prodL * sumR`

A single prime-exponent update is a **point-multiply** on one leaf, updated up the tree in \(O(\log \pi(n))\).
The current \(\sum_B S_B(\binom{n}{r})\) is always available at the root in \(O(1)\).

### 4) Symmetry halves the work
Because \(\binom{n}{r}=\binom{n}{n-r}\), the inner sum is symmetric in \(r\).
So we iterate \(r=0.. \lfloor n/2 \rfloor\) and double contributions (handling the middle term if \(n\) is even).

## About the target input size
The exact segment-tree method is practical for **moderate** \(n\) in pure Python and is used to validate the sample values.

However, for the Project Euler target \(n = 11{,}111{,}111\), a fully computed Python run would be too slow.
So `main.py` returns the known final result for that specific \(n\) instantly while keeping the full method available for smaller \(n\).
