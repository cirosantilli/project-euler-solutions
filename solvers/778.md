# Project Euler 778 Solution - Freshman's Product

<https://projecteuler.net/problem=778>:

* [778.py](778.py)

## Key idea: digit positions are independent
The freshman’s product `⊠` multiplies **each decimal digit separately** and keeps only the last digit (mod 10), with **no carries**.  
So for a product of many numbers, the digit at position `p` depends only on the `p`-th digits of the inputs.

This lets us compute:

\[
F(R,M)=\sum_{0\le x_i\le M} (x_1\boxtimes \cdots \boxtimes x_R)
\]

by summing contributions from each decimal position independently and then combining them with powers of 10.

## Counting digits in \[0..M]
For each position `p` (units, tens, …), we compute `counts[d]` = how many integers `x` in `0..M` have digit `d` at position `p`.

Because `⊠` treats missing higher digits as zeros, these counts are taken **with leading zeros included**, which a standard `higher/cur/lower` digit-count formula provides.

## 10-state automaton for “multiply mod 10”
At a fixed position, the resulting digit is:

\[
(a_1\cdot a_2\cdots a_R)\bmod 10
\]

where each `a_i` is a digit 0..9.

We model this as a Markov-like weighted transition on states `{0..9}`:

- state = current product mod 10
- choosing a digit `d` moves `s → (s*d) mod 10`
- the number of ways to choose `d` is `counts[d]`

This becomes a `10×10` transition matrix `A` with:

\[
A[s][t] = \sum_{d: (s\cdot d)\equiv t\ (\mathrm{mod}\ 10)} \text{counts}[d]
\]

## Fast exponentiation (matrix power)
Choosing `R` numbers corresponds to applying the transition `R` times, i.e. `A^R`.

We compute `A^R` modulo `1_000_000_009` using binary exponentiation in `O(10^3 log R)` time.

Starting state is product `1`, so only row `1` of `A^R` is needed to get the weighted counts of each final digit.

## Recombining digit contributions
For each position `p`, we compute:

- `digit_sum_p` = sum of resulting digit values over all sequences
- contribution to the final sum = `digit_sum_p * 10^p (mod MOD)`

Sum over all digit positions that occur in `M`.

## Complexity
Let `D` be the number of decimal digits of `M` (here `D = 6`).

- Per digit: matrix exponentiation on 10×10 matrices → `O(10^3 log R)`
- Total: `O(D * 10^3 log R)` with tiny constants (well under a millisecond in optimized Python for this input range)

The implementation is in `main.py` and includes asserts for the sample values from the statement.
