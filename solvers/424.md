# Project Euler 424 Solution - Kakuro

<https://projecteuler.net/problem=424>:

* [424.py](424.py)

This repository contains a self-contained solver for **Project Euler 424** (“cryptic kakuro”), implemented in `main.py` with **no external libraries**.

## Input file

`main.py` expects the 200 puzzle lines to be available in the current directory as:

- `0424_kakuro200.txt`

Running:

```bash
python3 main.py
```

will print the required sum.

## Key techniques used

### 1) Robust parsing of the encoded puzzles
The puzzle lines are comma-separated, but clue cells contain parentheses like `(hFE,vD)` which themselves contain commas.  
`split_tokens()` scans the line character-by-character and splits only on commas **outside** parentheses.

### 2) Constraint Satisfaction Problem (CSP) model
Variables:

- **Letters A–J**: 10 variables (digits **0–9**), with an **all-different** constraint.
- **White empty cells (`O`)**: one variable per cell (digits **1–9**).
- **Prefilled letter cells** reuse the corresponding letter variable and therefore automatically enforce consistency.

Constraints:

- **All-different** across the 10 letter variables.
- For each kakuro **run** (a contiguous set of white cells):
  - Digits are **all distinct** inside the run.
  - The **sum** of the run equals the decrypted clue sum (one or two letter-digits).

### 3) Bitmask domains
Each variable domain is a 10-bit (letters) or 9-bit (cells) integer bitmask.
This makes intersection and singleton checks extremely fast.

### 4) Precomputed run digit permutations
Runs have length ≤ 6 in this dataset.  
The solver precomputes all permutations of distinct digits `1..9` for each run length and groups them by `(length, sum)`.

During propagation for a run, it enumerates only the permutations whose sum matches a currently-possible decrypted clue sum.

### 5) Generalized arc consistency (GAC) + queue-based propagation
For each run, the solver keeps only values (digits) that have **support** in at least one satisfying assignment, shrinking domains.

Propagation uses a queue so that when a variable changes, only constraints that depend on it are reprocessed.

### 6) Backtracking with MRV (Minimum Remaining Values)
If propagation can’t finish the puzzle, a depth-first search assigns the variable with the smallest remaining domain (MRV),
using propagation after each assignment (forward checking).

## Built-in checks from the problem statement

`main.py` includes asserts for the statement’s test values (for the official 200-puzzle input file):

- The first puzzle’s decoded answer is `8426039571`.
- The sum of answers for the first 10 puzzles is `64414157580`.
