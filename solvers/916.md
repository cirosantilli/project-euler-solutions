# Project Euler 916 Solution - Restricted Permutations

<https://projecteuler.net/problem=916>:

* [916.py](916.py)

This repository contains a Python solution (`main.py`) for **Project Euler 916: Restricted Permutations**.

## Key ideas

### 1) Translate subsequence constraints via RSK

The Robinson–Schensted–Knuth (RSK) correspondence maps a permutation to a pair of standard Young tableaux of the same shape `λ`.

Two classical consequences:

- The **length of the longest increasing subsequence (LIS)** equals the length of the **first row** of `λ`.
- The **length of the longest decreasing subsequence (LDS)** equals the **number of rows** of `λ`.

For this problem (permutations of `{1..2n}`):

- `LDS ≤ 2`  ⇒  the shape has **at most two rows**.
- `LIS ≤ n+1`  ⇒  the first row has length **at most `n+1`**.

A two-row partition of `2n` is `(a, 2n-a)` with `a ≥ n`. Combining with `a ≤ n+1`, only two shapes are possible:

- `(n, n)`
- `(n+1, n-1)`

### 2) Count permutations with a fixed shape

A standard result from RSK says:

> The number of permutations whose RSK shape is `λ` equals `(f^λ)^2`,

where `f^λ` is the number of **standard Young tableaux** (SYT) of shape `λ`.

So:

`P(n) = (f^(n,n))^2 + (f^(n+1,n-1))^2`.

### 3) Hook-length formula for two-row SYT

The hook-length formula yields a closed form for two-row shapes `(a,b)` (`a ≥ b`):

`f^(a,b) = ((a-b+1)/(a+1)) * binom(a+b, b)`.

Applying this:

- `f^(n,n) = binom(2n, n)/(n+1)` — the **Catalan number** `Cat(n)`.
- `f^(n+1,n-1)` simplifies to `Cat(n) * (3n/(n+2))`.

Therefore:

`P(n) = Cat(n)^2 * ( 1 + (3n/(n+2))^2 )`.

So the whole problem reduces to computing `Cat(n)` modulo `1_000_000_007`.

### 4) Modular arithmetic

Because the modulus is prime, divisions are done with modular inverses:

- `x / y (mod M)` becomes `x * y^(M-2) (mod M)`.

The implementation computes:

- `binom(2n, n) = (2n)! / (n!)^2 (mod M)`
- `Cat(n) = binom(2n,n) / (n+1) (mod M)`

### 5) Computing factorial products for large `n`

To build `(2n)!` and `n!` modulo `M`, the code multiplies two ranges:

- `A = ∏_{i=1..n} i`
- `B = ∏_{i=n+1..2n} i`

Then:

- `n! = A`
- `(2n)! = A * B`

For the target `n = 10^8`, `main.py` can optionally use **multiprocessing** (standard library only) to split each range into chunks, compute chunk products in parallel, then combine them modulo `M`.

You can control the number of workers with:

- `PE916_WORKERS=<k> python3 main.py`

(Defaults to `min(8, cpu_count)`.)

## Tests

The file includes assertions for the test values given in the problem statement:

- `P(2) = 13`
- `P(10) ≡ 45265702 (mod 1_000_000_007)`
