# Project Euler 843 Solution - Periodic Circles

<https://projecteuler.net/problem=843>:

* [843.py](843.py)

This repository contains a fast, **pure-Python** solution (no third‑party libraries).

## 1) Reduce to Rule 90 over GF(2)
When the circle entries are restricted to `{0,1}`, the absolute difference equals XOR:

- `|0-0|=0`, `|1-1|=0`, `|0-1|=|1-0|=1`

So one step becomes

`b[i] = a[i-1] XOR a[i+1]`.

That is the classic **Rule 90** cellular automaton on a ring, and it is **linear over GF(2)**.

## 2) Polynomial model
Encode a state as

`A(x) = a0 + a1 x + ... + a(n-1) x^(n-1)`

in the ring `GF(2)[x] / (x^n - 1)`.

One update is multiplication by

`g(x) = x + x^(n-1)`

(which equals `x + x^{-1}` in that ring).

Eventual periods come from the action of `g` on the **invertible** part of the ring; factors where `g` is not invertible only contribute transient (nilpotent) behaviour.

## 3) Factor structure for even `n`
Write `n = 2^a * m` with `m` odd. In characteristic 2:

`x^n - 1 = x^n + 1 = (x^m + 1)^(2^a)`.

So it is enough to factor `x^m + 1` (square‑free for odd `m`), then handle prime‑power lifting up to exponent `2^a`.

The code factors `x^m + 1` using **Berlekamp’s algorithm** over GF(2).

## 4) Faster order computation via the Frobenius orbit
A naïve approach would compute multiplicative orders of `g` inside fields of size `2^d` (where `d` can be as large as ~80 here), which leads to large numbers of the form `2^d - 1`.

This solution uses a key speedup:

- Work modulo an irreducible `p(x)`.
- Let `a = g mod p` (a field element).
- Compute the smallest `k` such that `a^(2^k) = a`.

That `k` is the degree of the **smallest subfield** containing `a`, so the order of `a` must divide `2^k - 1`.

For `n ≤ 100`, the relevant `k` never exceeds 41, so factoring `2^k - 1` is cheap (done with a simple prime sieve + trial division).

## 5) Prime-power lifting contributes only powers of two
For `p(x)^t` with `t>1`, the order can only gain a factor of 2 at each lift step.
So each irreducible factor contributes:

- an **odd** base order (mod `p`), and
- a maximum extra `2^s` multiplier obtainable when lifting up to `p^(2^a)`.

## 6) Enumerating all periods with an LCM DP (compressed)
To build all possible periods for a fixed `n`, we avoid an exponential blowup by tracking only:

- the LCM of chosen **odd** orders, and
- the maximum required exponent of 2.

If a subset yields `(odd_lcm, max_s)`, then *all* periods `odd_lcm * 2^e` for `0 ≤ e ≤ max_s` are achievable.

Finally, the program unions all periods over `3 ≤ n ≤ 100` and sums the distinct values.

## Sanity checks
The code asserts the values given in the problem statement:

- `S(6) = 6`
- `S(30) = 20381`

Then it prints `S(100)`.
