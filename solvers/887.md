# Project Euler 887 Solution - Bounded Binary Search

<https://projecteuler.net/problem=887>:

* [887.py](887.py)

This repository contains a Python solution (no third‑party libraries) for Project Euler 887.

The problem asks for the *worst‑case* number of "greater than" questions needed to identify a secret number `x ∈ {1..N}`, with an additional constraint that **small secrets must be found quickly**:

- A strategy is valid if it always identifies `x` using at most `x + d` questions.
- `Q(N, d)` is the smallest possible worst‑case number of questions among all valid strategies.
- The required output is a double sum of `Q(N, d)` over `d = 0..7` and `N = 1..7^10`.

## Key ideas

### 1) Switch from `Q(N, d)` to a capacity function

Instead of computing `Q` directly for every `N`, define a *capacity* function:

- `F(q, d)` = the **maximum** `N` for which some strategy exists with
  - worst‑case questions `≤ q`, and
  - per‑value bound `questions(x) ≤ x + d`.

Then:

- `Q(N, d)` is the smallest `q` such that `N ≤ F(q, d)`.

### 2) A monotone optimal split gives a simple recurrence

The first question splits `{1..N}` into a left part `{1..L}` and a right part `{L+1..N}`.

After spending the first question:

- Left branch (`x ≤ L`): remaining allowance becomes `x + (d-1)`.
- Right branch (`x = L+t`): remaining allowance becomes `t + (L + d - 1)`.

So any strategy with worst‑case height `q` must satisfy:

- `L ≤ F(q-1, d-1)`
- `N-L ≤ F(q-1, L + d - 1)`

To **maximize** `N` for fixed `q,d`, you should take the largest possible `L`, because:

- A larger `L` increases `L` directly, and
- it also makes the right branch’s slack `L + d - 1` larger (never harder), since `F(q,·)` is non‑decreasing in `d`.

This yields the recurrence used in code:

- Base cases:
  - `F(0, d) = 1` (0 questions can only handle `N=1`)
  - `F(q, d<0) = 1` (when `d<0`, even `x=1` would need ≤0 questions)
- If the constraint never binds (`d ≥ q-1`), the information‑theoretic limit applies:
  - `F(q, d) = 2^q`
- Otherwise:
  - `L = F(q-1, d-1)`
  - `F(q, d) = L + F(q-1, L + d - 1)`

Memoization makes `F` very fast because only small `q` (≈ 30) are needed.

### 3) Summing over all `N` without iterating to `7^10`

For fixed `d`, the values of `Q(N,d)` are constant on ranges:

- `Q(N,d) = q` for `F(q-1,d) < N ≤ F(q,d)`.

So

- count how many `N` fall into each range,
- multiply by `q`,
- and accumulate.

This reduces the work to `O(q_max)` per `d`.

### 4) Special‑case `d = 0`

The statement includes `Q(N,0) = N-1`, so

- `∑_{N=1..M} Q(N,0) = M(M-1)/2`.

This avoids any large loops for the `d=0` term.

## How to run

```bash
python3 main.py
```

The program will run a few small asserts from the problem statement and then print the required result.
