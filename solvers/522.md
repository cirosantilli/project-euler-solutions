# Project Euler 522 Solution - Hilbert's Blackout

<https://projecteuler.net/problem=522>:

* [522.py](522.py)

We are given `n` floors. Each floor sends power to **exactly one other floor** (no self-loops).
So each arrangement is a **loopless functional digraph** on `n` labeled vertices: outdegree = 1,
and cycles have length ≥ 2.

Hilbert may **rewire** floors (change a vertex’s outgoing edge). The arrangement is **safe** iff
starting from **any** floor, power eventually reaches *all* floors — which is only possible when
the digraph is a **single directed `n`-cycle**.

The task is to compute:

- `F(n)` = sum, over all `(n-1)^n` loopless arrangements, of the **minimum number of rewires** needed,
- and output `F(12344321) mod 135707531`.

The problem statement gives sample values: `F(3)=6`, `F(8)=16276736`,
and `F(100) mod 135707531 = 84326147`. citeturn0search0turn0search2turn0search4

---

## 1) Graph decomposition

A functional digraph decomposes into components, each containing exactly one directed cycle with
(in-arborescence) trees feeding into the cycle.

Define:

- `z` = number of vertices with indegree 0 (nobody points to them),
- `c` = number of components (cycles),
- `p` = number of **pure** components: components that are *only* a directed cycle (no trees attached).

In a loopless functional digraph:

- every **cycle vertex** has indegree ≥ 1 (its predecessor on the cycle),
- every nontrivial attached tree contains at least one leaf (indegree-0 vertex),
  and each **impure** component contains ≥ 1 such leaf.

Let `q = c - p` be the number of impure components. Then `z ≥ q`, so:

`z + p ≥ (c - p) + p = c`.

So `max(c, z+p) = z+p` always.

---

## 2) Minimal rewires simplify to `z + p` (with one exception)

Project Euler 522’s minimal-rewire value can be expressed (and brute-checked for small `n`) as:

- If the graph is already a single `n`-cycle: **0** rewires.
- Otherwise: **`z + p`** rewires.

Since an `n`-cycle has `z=0` and `p=1`, we can write:

**minimum rewires = `z + p - I[n-cycle]`**.

Summing over all arrangements:

`F(n) = (sum z) + (sum p) - (# directed n-cycles)`.

The number of directed `n`-cycles on labeled vertices is `(n-1)!`.

---

## 3) Counting `sum z` by linearity of expectation

Fix a vertex `v`. For any other vertex `u≠v`, the probability `u` points to `v` is `1/(n-1)`,
so the probability `u` does **not** point to `v` is `(n-2)/(n-1)`.

Thus:

`P(indegree(v)=0) = ((n-2)/(n-1))^(n-1)`,

and by linearity:

`E[z] = n * ((n-2)/(n-1))^(n-1)`.

Multiply by the total number of arrangements `(n-1)^n`:

**`sum z = n*(n-1)*(n-2)^(n-1)`**.

---

## 4) Counting `sum p` by counting pure cycle components

A **pure component** is a directed cycle (length ≥ 2) with **no incoming edges** from outside.

Fix a directed cycle on `k` chosen vertices. Let `m = n-k` be outside vertices.

For the cycle to be a pure component, every outside vertex must point to another outside vertex
(not itself). Each outside vertex then has `(m-1)` choices, giving `(m-1)^m` outside mappings.

Number of directed `k`-cycles on labeled vertices is `C(n,k)*(k-1)! = n!/(k*(n-k)!)`.

So:

`sum p = (n-1)! + n! * Σ_{m=2..n-2} (m-1)^m / ((n-m)*m!)`.

Finally, since `F(n)` subtracts `(n-1)!`, those cancel and we only need:

**`F(n) = n*(n-1)*(n-2)^(n-1) + n! * Σ_{m=2..n-2} (m-1)^m / ((n-m)*m!)`  (mod M)**

with `M = 135707531`.

`M` is prime (it appears as a proven prime in prime lists). citeturn1search1turn1search5  
Also `n=12344321 < M`, so all integers `1..n` are invertible mod `M`.

---

## 5) Implementation techniques (what `main.py` does)

- Uses the closed-form `sum z`.
- Computes `n! mod M`.
- Uses **O(n)** precomputation of modular inverses:

  `inv[i] = M - (M//i) * inv[M%i] (mod M)`  (valid for prime `M`, `i<M`)

- Streams `inv_fact = 1/m!` incrementally using `inv[m]`.
- Accumulates the summation in one pass.

Memory: stores only `inv[0..n]` using `array('I')` (~4 bytes per entry), about 50 MB for `n≈12.3M`.  
Time: linear passes plus modular exponentiation (`pow(base, exp, M)`) per `m`.
