# Project Euler 299 Solution - Three Similar Triangles

<https://projecteuler.net/problem=299>:

* [299.py](299.py)

This repo contains a fast solver for Project Euler problem 299.

- `main.py` prints the answer for `LIMIT = 100_000_000`.
- It also contains asserts for the check values stated in the problem (`LIMIT = 100` and `LIMIT = 100000`, plus the worked example).

## Main techniques

### 1) Reduce the geometry to a = c and a point on x + y = a

The problem places

- **A** = (a, 0), **B** = (b, 0)
- **C** = (0, c), **D** = (0, d)

and asks for an integer point **P** on segment **AC** such that triangles **ABP**, **CDP**, and **BDP** are all similar.

A key fact (given in the statement) is that similarity forces **a = c**. Then the segment **AC** is the 45° diagonal line

`x + y = a`

so any integer point on **AC** is of the form **P** = (x, a − x).

### 2) Case split into two disjoint Diophantine families

When you track how the equal angles can correspond between the three triangles, the similarity constraints collapse into exactly one of two families:

#### Family A — “Incenter” solutions

In one correspondence, **P** becomes the incenter of triangle **OBD** (O = (0,0)), which forces **P** = (i, i) and therefore **a = 2i**.
Enforcing “distance from (i,i) to line BD equals i” leads to

`b^2 + d^2` is a perfect square.

Let `s = sqrt(b^2 + d^2)`. Then the corresponding `a` is uniquely determined by

`a = b + d − s`.

So counting triplets in this family is the same as counting **ordered** leg-pairs `(b,d)` of Pythagorean triples with `b + d < LIMIT`.

**Counting trick:**
Generate all **primitive** Pythagorean triples `(x,y,z)` once, then add the number of multiples `k` such that

`k*(x + y) < LIMIT`.

Every such multiple contributes **two** ordered pairs `(kx, ky)` and `(ky, kx)`.

`main.py` generates primitive triples using **Berggren’s ternary tree**, which avoids scanning all `(m,n)` pairs and avoids most gcd work.

#### Family B — “Parallel” solutions

In the other correspondence, the constraints force **BD ∥ AC**, which implies **b = d**.
Solving for an integer point on **AC** gives a quadratic whose discriminant must be a square, which simplifies to

`a^2 − 2(b − a)^2` is a perfect square.

Let `f = b − a > 0` and `q^2 = a^2 − 2f^2`. Then

`q^2 + 2f^2 = a^2`.

This is a norm equation and has a Euclid-like parametrization (primitive solutions) using coprime integers `u, v` with `u` odd:

- `a = u^2 + 2v^2`
- `f = 2uv`
- `q = |u^2 − 2v^2|`

Then `b = a + f = u^2 + 2v^2 + 2uv`, and the constraint `b + d < LIMIT` becomes `2b < LIMIT`.

**Counting trick:**
For each primitive `(u,v)`, count all scale factors `k` such that

`2*k*b < LIMIT`.

### 3) Pure counting via floor division

Both families end up as “enumerate primitive objects once, then count multiples” problems.
That turns the whole task into summing a lot of `floor(...)` terms, which is what the solver does.

## Complexity notes

- The incenter family enumerates all primitive Pythagorean triples with `x + y < LIMIT`, which is a few million items for `LIMIT = 10^8`.
- The parallel family enumerates coprime `(u,v)` pairs under a quadratic bound.

Both are fast enough in optimized Python with `math.isqrt` and `math.gcd`.
