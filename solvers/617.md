# Project Euler 617 Solution - Mirror Power Sequence

<https://projecteuler.net/problem=617>:

* [617.py](617.py)

This is a fast, **pure-Python** solution for Project Euler problem 617.

## Key observation

For fixed integers `n, e > 1` define:

`f(x) = min(x^e, n - x^e)`

A starting value `a0 > 1` yields a valid infinite sequence iff iterating `f` never produces `0` or `1`.
Because the state space is finite, every valid sequence eventually becomes periodic (enters a cycle).

## Structure of every cycle

For `x > 1`, the “power step” `x → x^e` is strictly increasing.
So a cycle cannot be made purely of power steps — it must contain a “mirror step”

`x → n - x^e`

which jumps back down.

This forces cycles to have a **power-tower** form:

`m, m^e, m^(e^2), …, m^(e^(L-1))`

and the last step mirrors back to the start:

`m^(e^L) = n - m   ⇔   n = m + m^(e^L)`.

If `m` itself is an exact `e`-th power, write `m = t^(e^a)` where `t` is *primitive* (not an exact `e`-th power). Then:

`n = t^(e^a) + t^(e^b)` with `0 <= a < b`.

So for fixed `e`:

> **Valid `n` are exactly those representable as** `n = t^(e^a) + t^(e^b)` with `t>1`, `0<=a<b`, and `t` not an exact `e`-th power.

## Counting sequences for fixed `e`

For a given `(t, e, b)`:

- Each `a in [0, b-1]` gives one `n = t^(e^a) + t^(e^b)`.
- For that `n`, the valid starting values are exactly

`a0 ∈ { t^(e^0), t^(e^1), …, t^(e^(b-1)) }`,

so the number of sequences contributed is **`b`**.

Therefore, for each exponent `e` we sum over primitive `t` and over `b>=1`:

- `b = 1` (`n = t + t^e`) is handled by counting `t` via an **integer-root bound** (no enumeration up to `t ≈ 10^9`).
- `b >= 2` has tiny search space because `t^(e^b)` grows extremely fast, so we can enumerate `t`.

Finally:

`D(N) = Σ_{e>=2} count_for_exponent(N, e)`.

## Techniques used

- Cycle classification (single mirror step + power tower)
- Unique representation using a **primitive base** `t`
- Exact integer arithmetic with **binary-search nth roots**
- Split counting: root-based for `b=1`, enumeration for `b>=2`

`main.py` prints `D(10^18)` and includes asserts for the sample values given in the problem statement.
