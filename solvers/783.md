# Project Euler 783 Solution - Urns

<https://projecteuler.net/problem=783>:

* [783.py](783.py)

This repository contains a solution for **Project Euler #783** in `main.py` (no external libraries).

## Key ideas

### 1) Model the process with a single state variable
Let:

- `X_t` = number of **black** balls in the urn at the **start** of turn `t` (before adding new black balls)

At turn `t`:

1. Add `k` black balls, so the black count becomes `Y_t = X_t + k`.
2. Remove `2k` balls uniformly at random **without replacement**.

The number of black balls removed on that turn, `B_t`, is **hypergeometric**.

### 2) Use hypergeometric second-moment formulas
For a hypergeometric random variable with:

- population size `M`
- success count `Y`
- draws `m`

the second moment can be written in a convenient polynomial form:

\[
\mathbb{E}[B^2 \mid Y] = c_1 Y + c_2 Y^2
\]

where:

\[
c_1 = \frac{m(M-m)}{M(M-1)}, \quad
c_2 = \frac{m(m-1)}{M(M-1)}.
\]

This is crucial: it depends only on `Y` and `Y²`.

### 3) Track only the first two moments
Because `E[B^2 | Y]` is quadratic in `Y`, we only need:

- `μ_t = E[X_t]`
- `s_t = E[X_t²]`

to compute:

- `E[B_t²] = c1 * E[Y_t] + c2 * E[Y_t²]`

and to update moments for the next turn using:

- `X_{t+1} = Y_t - B_t`.

This yields an **O(n)** algorithm with **O(1)** memory.

### 4) Numerical stability
The total is a sum of `n` terms, so `main.py` uses **Kahan summation** to reduce floating-point accumulation error.

## Complexity

- Time: **O(n)**  
- Memory: **O(1)**

For the required input `n = 10^6`, this runs quickly in pure Python.

## Running

```bash
python3 main.py
```

It prints the requested rounded value.
