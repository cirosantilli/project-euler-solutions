# Project Euler 471 Solution - Triangle Inscribed in Ellipse

<https://projecteuler.net/problem=471>:

* [471.py](471.py)

## Key math steps

### 1) Closed form for the inradius
From the tangency/geometry constraints of the incircle (center fixed at `(2b, 0)`), the inradius can be expressed **purely algebraically** as a rational function of `a` and `b`:

\[
r(a,b)=\frac{b(a-2b)}{a-b}.
\]

This matches the examples in the statement:
- \(r(3,1)=\tfrac12\)
- \(r(6,2)=1\)
- \(r(12,3)=2\)

The implementation uses the equivalent form:

\[
r(a,b)= b - \frac{b^2}{a-b},
\]

which makes the summation structure clearer.

### 2) Turning the double sum into harmonic numbers
For fixed `a`, the inner sum becomes

\[
\sum_{b=1}^{\lfloor (a-1)/2 \rfloor} r(a,b)
=
m(a+m+1) - a^2\big(H_{a-1}-H_{\lfloor a/2\rfloor}\big),
\]

where \(m=\lfloor (a-1)/2\rfloor\) and \(H_n=\sum_{k=1}^n \frac1k\) is the harmonic number.

So the full function

\[
G(n)=\sum_{a=3}^n \sum_{b=1}^{\lfloor (a-1)/2 \rfloor} r(a,b)
\]

reduces to a combination of:
- simple polynomial sums (closed forms for \(\sum k\), \(\sum k^2\))
- a few harmonic numbers at large indices (`n-1`, `n//2`, etc.)

### 3) Summation identities
To avoid any iteration up to \(10^{11}\), the code uses standard identities like:

\[
\sum_{k=1}^m H_k = (m+1)H_m - m,
\]
\[
\sum_{k=1}^m kH_k = \frac{m(m+1)}2 H_m - \frac{m(m-1)}4,
\]
\[
\sum_{k=1}^m k^2H_k = \frac{m(m+1)(2m+1)}6 H_m - \frac{m(4m^2-3m-1)}{36}.
\]

These express all needed weighted sums using only \(H_m\) and polynomials.

### 4) Fast harmonic numbers for huge `n`
For large \(n\), harmonic numbers are computed via the Eulerâ€“Maclaurin expansion:

\[
H_n=\ln n + \gamma + \frac1{2n} - \frac1{12n^2} + \frac1{120n^4} - \cdots
\]

A few terms are more than enough at \(n\approx 10^{11}\).

For small `n` (used in the asserts), the code computes \(H_n\) exactly by direct summation.

## Numerical output formatting
The answer must be printed in scientific notation with **10 significant digits** and a lowercase `e`. The code formats the `Decimal` value accordingly (mantissa rounded to 9 digits after the decimal point).

## Complexity
- Time: **O(1)** for the main computation (only a handful of big-integer polynomials + a few harmonic evaluations)
- Memory: **O(1)**

Running `main.py` prints the required `G(10^11)` value.
