# Project Euler 307 Solution - Chip Defects

<https://projecteuler.net/problem=307>:

* [307.py](307.py)

We model the process as **throwing `k` labelled balls into `n` bins** (each defect independently chooses a chip).
We want

- `p(k,n)` = probability that **some chip gets at least 3 defects**.

## Key idea: take the complement
Instead of counting configurations with a triple-defect chip directly, compute

- `q(k,n)` = probability that **every chip has at most 2 defects**

and return `p = 1 - q`.

## Counting configurations with max occupancy â‰¤ 2
Let

- `a` = number of chips with exactly **2** defects
- `b` = number of chips with exactly **1** defect

Then `2a + b = k`.
For a fixed `a`:

1. Choose which chips have 2 defects and which have 1 defect:
   - `C(n, a) * C(n-a, b)`
2. Assign `k` **labelled** defects to those chips with the required multiplicities:
   - `k! / (2!)^a = k! / 2^a`

So the probability contribution is

\[
T(a)=\frac{\binom{n}{a}\binom{n-a}{k-2a}\,k!}{2^a\,n^k}.
\]
Summing `T(a)` over `a = 0 .. floor(k/2)` gives `q(k,n)`.

## Avoiding huge factorials: a term recurrence
Directly evaluating `T(a)` overflows, so the program computes terms via a **ratio recurrence**:

- Start with
  \[
  T(0)=\frac{n\mathrm{P}k}{n^k}=\prod_{i=0}^{k-1}\left(1-\frac{i}{n}\right).
  \]
  This is computed in **log space** using `log1p`.

- With `b = k - 2a`, the ratio is
  \[
  \frac{T(a+1)}{T(a)}=\frac{b(b-1)}{2(a+1)(n-k+a+1)}.
  \]

This makes each next term an `O(1)` update, so the whole sum is `O(k)`.

## Numerical stability
- `T(0)` can be extremely small, so we compute it as `exp(sum(log1p(...)))`.
- The final sum is accumulated with `math.fsum` for improved precision.

For the required instance (`k=20000`, `n=1000000`), standard double precision is sufficient to round the answer to **10 decimal places**.
