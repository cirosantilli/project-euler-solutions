# Project Euler 718 Solution - Unreachable Numbers

<https://projecteuler.net/problem=718>:

* [718.py](718.py)

We need the sum of all **unreachable** positive integers `n` for a fixed `p` in:

\[
17^p a + 19^p b + 23^p c = n,\quad a,b,c>0
\]

Let:

- \(A = 17^p\)
- \(B = 19^p\)
- \(C = 23^p\)
- \(S = A+B+C\)

## 1) Remove the “positive coefficients” constraint

Because \(a,b,c\ge 1\),

\[
A a + B b + C c = n
\iff
A(a-1) + B(b-1) + C(c-1) = n - S
\]

So the reachable `n` with **positive** coefficients correspond exactly to values `m = n - S` reachable with **nonnegative** coefficients in the semigroup \(\langle A,B,C\rangle\).

That yields:

- Every `n` with `1 ≤ n < S` is unreachable.
- For `n ≥ S`, unreachable `n` are exactly `m+S` where `m` is a **gap** (a nonrepresentable nonnegative integer) of \(\langle A,B,C\rangle\).

Therefore:

\[
G(p)
=
\sum_{n=1}^{S-1} n
+
\sum_{m\in \text{gaps}} (m+S)
=
\frac{(S-1)S}{2}
+
\sum_{m\in \text{gaps}} m
+
|\text{gaps}| \cdot S
\]

So the task becomes computing:

- the number of gaps, and
- the sum of all gaps,

for the 3-generator numerical semigroup \(\langle A,B,C\rangle\).

## 2) Residue-class viewpoint (Apéry-style idea)

Fix modulus `A` (the smallest generator). For each residue \(r \in [0, A-1]\), define:

- \(d[r]\): the **smallest** representable value congruent to `r (mod A)`.

Once \(d[r]\) is known, every value \(d[r] + kA\) is representable, and every value in that residue class **below** \(d[r]\) is a gap.

Write:

\[
d[r] = r + q_r A
\]

Then there are exactly `q_r` gaps in residue class `r`:

\[
r,\, r+A,\, r+2A,\, \dots,\, r+(q_r-1)A
\]

Their sum is:

\[
q_r\cdot r \;+\; A\cdot\frac{q_r(q_r-1)}{2}
\]

So total gaps and total gap-sum follow from the \(q_r\)’s.

## 3) Computing all \(d[r]\) in **O(A)**

Naively, computing all \(d[r]\) is a shortest-path problem on `A` residues, usually done with Dijkstra.

Here we exploit that we only have *two* “non-A” generators (`B` and `C`) and that `B` is invertible mod `A`.

Key steps:

1. Work in a transformed residue \(r_0 = r \cdot B^{-1} \pmod A\).
2. Express candidate representations using only `B` and `C` (adding `A` later doesn’t change residue).
3. Show that the minimum can be written as:

\[
d[r] = B\cdot r_0 + \min(\text{prefix part}, \text{suffix part})
\]

where the prefix part is a minimum over `t ≤ A-r0-1`, and the suffix part is a minimum over `t ≥ A-r0` but with a constant correction (`-B*A`) to account for wrap-around in modular addition.

This structure lets us compute:

- a **prefix minimum array** over `t = 0..A-1`, and
- a running minimum over the suffix as we sweep `r0 = 0..A-1`.

Both sweeps are linear time. Only one large array is stored: `A` unsigned 64-bit integers.

## 4) Complexity

For `p=6`, \(A = 17^6 = 24,137,569\).

- Time: two linear passes over `A` residues (plus lightweight arithmetic), designed to run in practical time in Python.
- Memory: one `array('Q')` of length `A` (≈ 8·A bytes), about **193 MB** for `p=6`.

## 5) Validation

The code asserts the statement’s examples:

- `G(1) = 8253`
- `G(2) = 60258000`

Then it prints `G(6) mod 1_000_000_007`.
