# Project Euler 603 Solution - Substring Sums of Prime Concatenations

<https://projecteuler.net/problem=603>:

* [603.py](603.py)

This repository solves:

\[
S\big(C(10^6, 10^{12})\big)\ \bmod\ (10^9+7)
\]

where:

- `S(x)` is the sum of all **contiguous decimal substrings** of `x` (substrings may have leading zeros).
- `P(n)` is the decimal string formed by concatenating the first `n` primes.
- `C(n,k)` is `k` copies of `P(n)` concatenated.

## Key techniques

### 1) Turn the digit string into a “concatenation monoid”

For any decimal digit string `X`, keep a small set of aggregates (all mod `M = 1e9+7`):

- `len(X)` and `len(X) mod M`
- `val(X)`: numeric value of the whole string
- `pre(X)`: sum of all prefix values
- `suf(X)`: sum of all suffix values
- `S(X)`: sum of all substring values (what we ultimately need)
- `10^len(X)` and \(\sum_{i=1}^{len(X)}10^i\)

These aggregates can be **merged in O(1)** for concatenation:

\[
\text{Node}(AB) = \text{merge}(\text{Node}(A), \text{Node}(B))
\]

This works because every substring of `AB` is either:
- fully inside `A`,
- fully inside `B`,
- or crosses the boundary (a suffix of `A` + a prefix of `B`).

The “crossing” contribution is expressible using only `suf(A)`, `pre(B)`, and the geometric sum of powers of 10 for the length of `B`.

### 2) Stream digits to build `P(10^6)` in one pass

`P(10^6)` is millions of digits long. We never store it.

Instead, while generating the first million primes, we convert each prime to decimal and **append its digits** to the running Node in O(1) per digit.

### 3) Use binary exponentiation to repeat the block `10^12` times

`C(n,k)` is `k` concatenations of `P(n)`.

Because `merge` is associative, we can compute:

\[
\text{Node}(P(n))^k
\]

using **binary exponentiation** in \(O(\log k)\) merges (≈ 40 merges for \(k=10^{12}\)).

### 4) Efficient prime generation via an odd-only sieve

To get the first million primes, we use a classic **odd-only sieve of Eratosthenes**, with an upper bound from the prime number theorem:

\[
p_n < n(\log n + \log\log n)\quad (n \ge 6)
\]

This keeps memory and runtime reasonable in pure Python.

## Validation

The code includes `assert`s for the examples given in the problem statement:

- `S(2024) = 2304`
- `P(7) = 2357111317`
- `C(7,3) = 235711131723571113172357111317`
