# Project Euler 870 Solution - Stone Game IV

<https://projecteuler.net/problem=870>:

* [870.py](870.py)

This solver computes the transition value **T(123456)** and prints it rounded to **10 digits after the decimal point**.

## Main ideas

### 1) Losing positions form a generalized base (g-base)

For a fixed real parameter `r > 0`, define `L(r)` as the set of initial pile sizes `n` for which the **second** player has a winning strategy.

A standard result for this family of *dynamic one-pile Nim* games is that `L(r)` can be generated by an increasing sequence `B(r) = (b0, b1, b2, ...)` (a **g-base**) satisfying:

- `b0 = 1`
- `b(k+1) = b(k) + b(i)`, where `i` is the smallest index such that  
  `floor(r * b(i)) >= b(k)`

This reproduces the examples in the statement:
- `r = 1/2` gives `B = [1]`
- `r = 1` gives powers of two
- `r = 2` gives Fibonacci-like growth

### 2) Each step gives an interval of valid `r`

At each step `k`, the choice of the index `i` is controlled by inequalities like:

- `floor(r * b(i-1)) < b(k)`
- `floor(r * b(i)) >= b(k)`

These inequalities define an interval of `r` values for which the same `i` would be chosen.
The **upper endpoint** of that interval is the rational number:

- `b(k) / b(i-1)` (when `i > 0`)

### 3) Next transition value is the smallest upper endpoint

If `q` is a transition value, the next transition after `q` is the smallest upper endpoint
encountered while generating `B(q)`. So we can compute `T(i)` iteratively:

- Start with `T(1) = 1`
- Repeatedly build `B(T(i))` and take the minimum `b(k)/b(i-1)` produced along the way

### 4) Exact arithmetic, no floats

All comparisons of rationals are done with **cross-multiplication** on integers, avoiding
floating point error. The final rounding to 10 decimal places is done by integer long division.

## Files

- `main.py` â€” implementation and the required asserts from the problem statement.
