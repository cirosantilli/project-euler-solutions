# Project Euler 641 Solution - A Long Row of Dice

<https://projecteuler.net/problem=641>:

* [641.py](641.py)

This repository contains a fast, library-free solution to **Project Euler 641**.

## Key ideas

### 1) Turn-count equals “number of divisors minus one”
Die `i` is turned once for every `k ∈ {2..n}` that divides `i`.  
So the number of turns is:

- `turns(i) = τ(i) - 1`, where `τ(i)` is the divisor-count function.

Starting from face `1` and adding `1 (mod 6)` each turn, die `i` ends on `1` iff:

- `τ(i) - 1 ≡ 0 (mod 6)`  ⟺  `τ(i) ≡ 1 (mod 6)`.

So `f(n)` is the count of `i ≤ n` with `τ(i) ≡ 1 (mod 6)`.

---

### 2) `τ(i) ≡ 1 (mod 6)` forces `i` to be a perfect square
`τ(i)` is odd **iff** `i` is a perfect square.  
Since `τ(i) ≡ 1 (mod 6)` is odd, any contributing `i` must be `i = x²`.

Write `x = ∏ p^b`. Then:

- `τ(x²) = ∏ (2b + 1)`.

Working modulo `3`:

- `2b + 1 ≡ 1 - b (mod 3)`.

So:
- `b ≡ 1 (mod 3)` is impossible (factor becomes `0 mod 3`),
- `b ≡ 2 (mod 3)` contributes `-1 mod 3`,
- and we need an **even** number of `b ≡ 2 (mod 3)` primes so the total product is `1 mod 3`.

Thus `f(n)` becomes a counting problem over `x ≤ ⌊√n⌋` with exponent constraints mod `3`.

---

### 3) Unique decomposition `x = y³ · z²` with `z` squarefree
Every integer `x` can be written uniquely as:

- `x = y³ · z²`

where:
- `z` is **squarefree**,
- primes in `z` are exactly those with exponent `b ≡ 2 (mod 3)` in `x`.

The condition “even number of such primes” becomes:

- `ω(z)` (number of prime factors of `z`) is **even**.

Then, for `M = ⌊√n⌋`:

- `f(n) = #{ x ≤ M : x = y³ z², z squarefree, ω(z) even }`
- `= ∑_{z squarefree, ω(z) even} ⌊ (M / z²)^{1/3} ⌋`.

---

### 4) Möbius trick to enforce squarefree + even parity
For squarefree `z`, the Möbius function satisfies:

- `μ(z) = (-1)^{ω(z)}` and `μ(z)=0` if `z` is not squarefree.

So the indicator of “squarefree and `ω(z)` even” is:

- `(μ(z)² + μ(z)) / 2`.

This converts the problem into two sums:

- `S0 = ∑ μ(z)² · t(z)`  (counts squarefree `z`)
- `S1 = ∑ μ(z)   · t(z)`  (alternating by parity)

where `t(z) = ⌊(M / z²)^{1/3}⌋`, and:

- `f(n) = (S0 + S1) / 2`.

---

### 5) Group by constant `t(z)` and use prefix sums
`t(z)` only takes values `y = 1..⌊M^{1/3}⌋`.

For fixed `y`, the `z` with `t(z)=y` satisfy:

- `√(M/(y+1)³) < z ≤ √(M/y³)`.

So we just need fast queries of:

- `M(n) = ∑_{k≤n} μ(k)`  (Mertens function),
- `Q(n) = ∑_{k≤n} μ(k)²` (squarefree counting function),

to get interval sums by subtraction.

Implementation details:

- `M(n)` is computed with a **small Möbius sieve** plus a **divide-and-conquer recursion** that groups equal `n//i`.
- `Q(n)` uses the identity  
  `Q(n) = ∑_{d≤√n} μ(d) · ⌊n/d²⌋`  
  and groups ranges where `⌊n/d²⌋` is constant.

This makes `f(10^36)` feasible in a few seconds in pure Python.

## Files

- `main.py` — computes the answer and includes asserts for the statement’s test values.
