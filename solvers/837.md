# Project Euler 837 Solution - Amidakuji

<https://projecteuler.net/problem=837>:

* [837.py](837.py)

This solution counts 3-line **Amidakuji** diagrams with:

- `m` rungs between the first two lines (swap `(12)`)
- `n` rungs between the last two lines (swap `(23)`)

where rungs are ordered top-to-bottom, and the induced permutation is the **identity**.

## 1) Turn the ladder into a word in S₃
Each rung is a transposition in the symmetric group:

- A–B rung → `s = (12)`
- B–C rung → `t = (23)`

An Amidakuji with `m` A–B rungs and `n` B–C rungs is a word of length `m+n` in `{s,t}`.
The ladder outcome is the product of the word in **S₃**.
So `a(m,n)` is the number of such words whose product is the identity.

## 2) Use characters / representations to extract the identity coefficient
Consider the group-algebra expression:

\[
(x s + y t)^{L}, \quad L=m+n
\]

The coefficient of the identity element can be recovered using the irreducible representations of `S₃`.
This reduces the answer to a small combination of traces:

- trivial representation → contributes \((x+y)^L\)
- sign representation → contributes \((x+y)^L\) when `L` is even, else cancels
- standard 2D representation → trace collapses to a quadratic form

In the standard representation, the matrix \(xS+yT\) has **trace 0**, so:

\[
(xS+yT)^2 = -\det(xS+yT)\,I
\]

Hence for even \(L=2k\), the trace becomes \(2(-\det)^k\), producing the quadratic form
\((x^2-xy+y^2)^k\). Translating back to coefficients gives:

\[
a(m,n) \equiv \frac{\binom{L}{m} + 2D}{3}\pmod p,\quad
D=[z^m](z^2-z+1)^k,
\]
and `a(m,n)=0` when `L` is odd.

## 3) Convert \(D\) to a finite hypergeometric-type sum
Use the algebraic identity:

\[
z^2 - z + 1 = \frac{1+z^3}{1+z}.
\]

Then:

\[
(z^2-z+1)^k = (1+z^3)^k (1+z)^{-k}.
\]

Expanding both sides yields a *finite* sum:

\[
D = \sum_{j=0}^{\lfloor m/3\rfloor} (-1)^{m-3j}
\binom{k}{j}\binom{k+m-3j-1}{m-3j}.
\]

To avoid recomputing binomials for every term, the implementation walks from
the last term `j = ⌊m/3⌋` downwards, using a **rational ratio** between consecutive
terms.

## 4) Batch inversions (one `pow` per block)
Both large binomials and the coefficient sum require many divisions modulo a prime.
Instead of calling `pow(…, p-2, p)` per step, the code uses **batch inversion**:

- multiply all denominators in a block to get a prefix product array
- invert the total product once with Fermat’s little theorem
- recover every individual inverse by a backward pass

This makes all “division-heavy” loops feasible in pure Python.

---

Files:

- `main.py` — solver + asserts for the two statement checks
- `README.md` — this explanation
