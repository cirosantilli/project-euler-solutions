# Project Euler 980 Solution - Unknown Title

<https://projecteuler.net/problem=980>:

* [980.py](980.py)

# Neutral strings — solution outline

We build strings over `x,y,z` starting from the empty string using three moves:

1. Insert `xx` / `yy` / `zz`.
2. Replace one letter by two letters: `x→yz`, `y→zx`, `z→xy`.
3. Swap two adjacent **different** letters.

A string is **neutral** if it can be produced in an **even** number of steps.

## 1) Encoding with the quaternion group

Model each word as a product in the quaternion group **Q8**:

- Elements: `±1, ±i, ±j, ±k`.
- Rules: `i²=j²=k²=-1`, `ij=k`, `jk=i`, `ki=j` and anti-commutation (e.g. `ji=-ij`).

Use the mapping:

- `x → i`
- `y → j`
- `z → -k`

Under this mapping, each allowed operation flips the sign of the product:

- Inserting `aa` multiplies by `a² = -1`.
- Swapping different letters uses anti-commutation, so `ab = -ba`.
- The replacement rules are chosen so that `yz = -x`, `zx = -y`, `xy = -z`.

So **every step multiplies the Q8 value by `-1`**. Starting from the empty word (value `+1`),
a word is reachable in an even number of steps **iff its Q8 product is `+1`**.

That turns “neutrality” into a simple group check.

## 2) Reducing the pair count

Let `g(i)` be the Q8 product of the 50-letter string `c(i)`.
For concatenation:

`g(c(i)c(j)) = g(i) * g(j)`.

So `c(i)c(j)` is neutral exactly when:

`g(i) * g(j) = 1`  ⇔  `g(j) = g(i)⁻¹`.

Therefore we only need counts of each Q8 value among `g(0),...,g(N-1)`:

`F(N) = Σ_e  count[e] * count[e⁻¹]`  (ordered pairs).

## 3) Computing `g(i)` efficiently

The sequence `a_n` is generated by:

`a_0 = 88,888,888`  
`a_n = (8888 * a_{n-1}) mod 888,888,883`.

We only need `b_n = a_n mod 3` to choose letters for `c(i)`.
While iterating the recurrence, we update the current Q8 product using a small precomputed
right-multiplication table (8 group states × 3 possible letters).

- Time: `O(50·N)` (50 million steps for `N=10^6`)
- Memory: `O(1)` besides a few tiny tables.
