# Project Euler 888 Solution - 1249 Nim

<https://projecteuler.net/problem=888>:

* [888.py](888.py)

This solution counts losing positions in a multi-pile impartial game where a move is either:

- remove `1, 2, 4, or 9` stones from a pile, or
- split a pile into two non-empty piles.

A position with multiple piles is losing exactly when the XOR of the piles’ Grundy numbers is `0`.

## Techniques used

### 1) Sprague–Grundy reduction

For one pile of size `n`, its Grundy number `g(n)` is the mex of the Grundy numbers of all reachable positions:

- subtraction moves: `g(n-1), g(n-2), g(n-4), g(n-9)` (when defined),
- split moves: `g(i) XOR g(n-i)` for `1 ≤ i < n`.

The program computes a table of `g(n)` for a moderate prefix and stores them in a list.

### 2) Using a small split window

The split move naively requires scanning all `i < n`, which is quadratic.
Empirically (and consistent with the structure of this game), it is enough to consider splits where one part is at most a few hundred stones.
The program uses a conservative fixed bound and **verifies** it matches the full split computation on a sizeable prefix.

This keeps the Grundy precomputation essentially linear in the table size.

### 3) Periodicity check for fast counting

After a short “preperiod”, the computed Grundy values repeat with a fixed period.
The code does not assume this silently: it computes two consecutive periods and asserts that the repetition holds across the entire overlap.
Once validated, counting how many pile sizes `≤ N` yield each Grundy value becomes an `O(1)` arithmetic task.

### 4) Counting multisets with XOR = 0 via a ±1 filter

We need the number of **unordered** selections of `m` pile sizes from `{1..N}` such that the XOR of their Grundy numbers is `0`.

A key simplification is that, in XOR, only the **parity** of how many times a given pile size is chosen matters.
This leads to a generating function where each pile size contributes:

- even copies: `1 + x^2 + x^4 + …`
- odd copies:  `x * (sign depending on g(n))` times the same even series

This can be handled by introducing four sign variables (one per Grundy bit), then applying a 16-point “roots of unity” / Walsh–Hadamard-style filter by substituting each sign as `±1`.
For each of the 16 substitutions, the whole product collapses to a rational function depending only on one integer `a` (how many pile sizes map to `+1` under that substitution):

\[
(1-x)^{-a} (1+x)^{-(N-a)}.
\]

The desired count is the average of the `x^m` coefficients over all 16 substitutions.

Overall complexity for the counting step is `O(16·m)`.

### 5) Working modulo a composite number

The requested modulus is not guaranteed prime.
The code factors the modulus into prime powers, computes each coefficient modulo each prime power, and recombines them using the Chinese Remainder Theorem.

Because `m` is small, binomial-series coefficients are built incrementally while tracking prime factors explicitly (removing factors of `p` before taking modular inverses).

## Files

- `main.py` — complete solver, includes the two given checks as `assert`s.
- `README.md` — this summary.
