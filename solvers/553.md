# Project Euler 553 Solution - Power Sets of Power Sets

<https://projecteuler.net/problem=553>:

* [553.py](553.py)

This solution computes:

- `C(10^4, 10) mod 1_000_000_007`

and includes assertions for all test values given in the problem statement.

## Key ideas used

### 1) Interpret `X ⊆ Q(n)` as a hypergraph
An element `X ∈ R(n)` is a **set of non-empty subsets** of `{1..n}`.

Treat:

- vertices = `{1..n}`
- hyperedges = the subsets in `X`

Two hyperedges are adjacent in the intersection graph iff they share a vertex.  
So connected components of the intersection graph are exactly the **connected components of the hypergraph in the “edges share a vertex” sense**.

### 2) Inclusion–exclusion for “no isolated vertices”
Let `G(n)` be the number of hypergraphs on `n` labeled vertices where **every vertex is used by at least one edge**.

All hyperedges are chosen from the `2^n - 1` non-empty subsets, so the number of hypergraphs on `m` vertices is `2^(2^m - 1)`.

Using inclusion–exclusion over isolated vertices:

\[
G(n)=\sum_{t=0}^{n}(-1)^t \binom{n}{t} 2^{2^{n-t}-1}.
\]

This is computed efficiently as a binomial transform in **exponential generating function** (EGF) form.

### 3) Exponential formula (EGFs): connected vs. arbitrary
Let `F(n)` be the number of **connected** hypergraphs on `n` labeled vertices with no isolated vertices.

Then in EGF form:

- `H(x) = sum_{n≥0} G(n) x^n / n!`
- `A(x) = sum_{n≥1} F(n) x^n / n!`

The “set of connected components” construction implies:

\[
H(x)=\exp(A(x)) \quad \Rightarrow \quad A(x)=\log(H(x)).
\]

So we get the connected-component building block by taking a **formal power series logarithm**.

### 4) Put back unused vertices and force exactly `k` components
Vertices not used by any edge correspond to an independent factor `exp(x)` (each unused vertex contributes one labeled atom).

Exactly `k` connected components gives the EGF:

\[
\exp(x)\cdot \frac{A(x)^k}{k!}.
\]

Therefore:

\[
C(n,k)=n!\,[x^n]\left(\exp(x)\cdot \frac{A(x)^k}{k!}\right).
\]

### 5) Fast polynomial arithmetic
The main cost is multiplying power series up to degree `10^4`.

- Polynomial multiplications are done with **NTT** under three friendly primes and then combined with **CRT** to get results modulo `1_000_000_007`.
- The power series logarithm uses Newton inversion plus multiplication.

This keeps the whole computation fast enough in pure Python.

## Running

```bash
python3 main.py
```

It prints the answer for `C(10000, 10) mod 1_000_000_007`.
