# Project Euler 797 Solution - Cyclogenic Polynomials

<https://projecteuler.net/problem=797>:

* [797.py](797.py)

This solution computes \(Q_{10^7}(2) \bmod 1\,000\,000\,007\) using number-theoretic transforms on the divisor lattice, plus fast sieving.

## Key ideas

### 1) Cyclogenic polynomials = products of cyclotomic polynomials
Over the integers:
\[
x^n - 1 = \prod_{d\mid n}\Phi_d(x)
\]
Every monic integer divisor of \(x^n-1\) is exactly a product of a subset of \(\{\Phi_d(x): d\mid n\}\).

So, if we evaluate at \(x=2\), choosing a subset corresponds to multiplying the values \(\Phi_d(2)\).

### 2) Summing all divisors as a subset-product
Let
\[
T_n(2) = \prod_{d\mid n}\bigl(1 + \Phi_d(2)\bigr)
\]
This is the sum (at \(x=2\)) of **all** monic cyclotomic divisors of \(x^n-1\): each factor contributes “pick it or not”.

The problem’s \(P_n(2)\) is the sum of those divisors whose *least* cyclogenic level is exactly \(n\), and:
\[
T_n(2) = \sum_{m\mid n} P_m(2)
\]

### 3) Möbius inversion to isolate “exactly \(n\)”
From
\[
T_n = \sum_{m\mid n} P_m
\]
we get
\[
P_n = \sum_{d\mid n} \mu(d)\,T_{n/d}
\]
and then
\[
Q_N = \sum_{n\le N}P_n
      = \sum_{d\le N}\mu(d)\sum_{k\le N/d}T_k
\]
This last form is crucial: it turns the problem into a **prefix-sum of \(T_k\)** weighted by Möbius values.

### 4) Computing \(\Phi_n(2)\) with only \(2^{\omega(n)}\) terms
Using the standard identity
\[
\Phi_n(x) = \prod_{s\mid n}(x^s-1)^{\mu(n/s)}
\]
and noting \(\mu(n/s)\ne 0\) only when \(n/s\) is squarefree, we get:
\[
\Phi_n(2) = \prod_{s\mid \mathrm{rad}(n)} \bigl(2^{n/s}-1\bigr)^{\mu(s)}
\]
So we only need to iterate over the squarefree divisors of \(\mathrm{rad}(n)\), i.e. \(2^{\omega(n)}\) subsets of the distinct primes of \(n\).

### 5) Batch modular inverses
The formula above needs inverses of \((2^k-1)\) for many \(k\).
Instead of doing \(O(N)\) slow modular exponentiations, we use a **single** exponentiation plus prefix products to invert all values in linear time.

### 6) Harmonic grouping for the final sum
The value \(\left\lfloor N/d\right\rfloor\) changes only \(O(\sqrt{N})\) times.
We group ranges of \(d\) where this quotient is constant, using a prefix sum of \(\mu\) (the Mertens function) to get each block’s total Möbius weight quickly.

## Built-in checks from the statement
The program includes asserts for:
- \(P_6(2)=234\)
- \(Q_{10}(2)=5598\)

Run:

```bash
python3 main.py
