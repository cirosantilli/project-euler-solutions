# Project Euler 615 Solution - The Millionth Number with at Least One Million Prime Factors

<https://projecteuler.net/problem=615>:

* [615.py](615.py)

We need the **1,000,000-th smallest** integer `n` such that the total number of prime
factors with multiplicity is at least `1,000,000`:

- `Ω(n)` = sum of exponents in the prime factorization of `n`
- Find the millionth `n` with `Ω(n) ≥ 1,000,000`
- Output `n mod 123454321`

## Main ideas used

### 1) Factor out “almost all” twos

Among the smallest numbers with enormous `Ω(n)`, almost every factor is `2`.
We pick a small `k` and try to write:

```
n = 2^(m-k) * x,    where m = 1,000,000
```

Then:

```
Ω(n) = (m-k) + Ω(x)
```

So every `x` with `Ω(x) ≥ k` automatically yields an `n` with `Ω(n) ≥ m`,
and multiplying by the same power of two keeps the order.

To make this a correct *order-preserving* reduction for the first million values,
we must ensure the millionth answer is divisible by `2^(m-k)`. A sufficient check is:

- Any number **not** divisible by `2^(m-k)` has at most `m-k-1` factors of 2,
  so it needs at least `k+1` odd prime factors.
- The smallest such number is obtained by using all `3`s:
  `2^(m-k-1) * 3^(k+1)`.
- After dividing out `2^(m-k)`, this threshold becomes `3^(k+1) / 2`.

So if the millionth `x` with `Ω(x) ≥ k` satisfies:

```
x < 3^(k+1) / 2    (equivalently 2x < 3^(k+1))
```

then *all* first million answers are divisible by `2^(m-k)` and the reduction is valid.

For this problem, `k = 28` works (and is minimal).

### 2) Enumerate numbers with `Ω(x) ≥ k` by best-first search

We must compute:

```
x = the 1,000,000-th smallest integer with Ω(x) ≥ k    (k = 28)
```

Start from `2^k` (the smallest number with `k` prime factors).  
From a number `v` whose largest prime factor is `p_max`, we can generate larger valid
numbers in a canonical (nondecreasing factor) way:

- **Append** a prime `p ≥ p_max`:          `v -> v * p`
- **Replace** one factor `2` by `p ≥ p_max`, `p > 2`:  `v -> (v/2) * p`  (only if `v` is even)

This constructs each factorization in sorted order, avoiding combinatorial duplicates.

### 3) Lazy “multiply by primes” streams (multi-way merge)

A naive expansion would loop over *many* primes per popped heap element.

Instead, each “multiply by primes `p_max, next_prime, ...`” list is treated as a sorted stream:

- The heap stores the current stream head `base * prime[idx]`
- When popped, the stream advances by pushing `base * prime[idx+1]`

This turns the work into a multi-way merge and keeps the runtime practical in Python.

### 4) On-demand prime generation + modular exponentiation

- Primes are generated incrementally by trial division (only ~16k primes are needed).
- Final answer uses Python’s fast modular exponentiation:

```
answer = x * 2^(m-k) mod 123454321
```

## Files

- `main.py` — full solution (prints the Project Euler answer)
- Includes the required assert from the statement:
  - `nth_with_Ω≥5` at index 5 equals `80`.
