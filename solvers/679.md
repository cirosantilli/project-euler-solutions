# Project Euler 679 Solution - Freefarea

<https://projecteuler.net/problem=679>:

* [679.py](679.py)

We work over the alphabet **S = {A, E, F, R}** and must count length-`n` words that contain each keyword

- `FREE`
- `FARE`
- `AREA`
- `REEF`

**exactly once** as a substring (overlaps are allowed).

The program outputs `f(30)` and also checks the statement’s test values `f(9)=1` and `f(15)=72863`.

## Main techniques

### 1) Aho–Corasick automaton (multi-pattern substring matching)

Because the keywords overlap (e.g. `FREE` and `REEF` overlap in `FREEFAREA`), we need a matcher that correctly finds **all** keyword endings while scanning left-to-right.

We build a trie of the 4 keywords, then add failure links (like KMP) to create an **Aho–Corasick automaton**.  
Each automaton state stores an **output bitmask** of which keywords end at that position (including suffix matches via failure links).

### 2) Dynamic programming over (position, automaton-state, seen-mask)

We scan the word one character at a time:

- `state` = current node in the Aho–Corasick automaton
- `mask` = bitmask of which keywords have occurred so far

Transition with each next letter:

1. move to `next_state` via the automaton transition table
2. let `out` be the bitmask of keywords that end here
3. if `out` intersects `mask`, then some keyword would occur **twice** ⇒ discard
4. otherwise update `mask |= out`

At the end of length `n`, we sum all DP counts where `mask` has all 4 bits set.

### Complexity

The automaton has only 16 states for these patterns, and `mask` has 16 possibilities.  
So the DP is tiny: `O(n * states * 16 * |S|)` which is effectively instantaneous for `n = 30`.
