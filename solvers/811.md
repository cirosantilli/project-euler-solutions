# Project Euler 811 Solution - Bitwise Recursion

<https://projecteuler.net/problem=811>:

* [811.py](811.py)

This solution evaluates

- `A(n)` defined by the recursion in the problem, and
- `H(t,r) = A((2^t + 1)^r)` modulo `1_000_062_031`

without constructing the enormous integer `(2^t + 1)^r`.

## Key ideas

### 1) Convert the recursion into a product over zero-bits

Define a helper sequence:

- `v0 = 1`
- `v(k+1) = 5*v(k) + 3`

If you scan the binary representation of `n` from the most significant bit downwards:

- when you see a `1`, you increase the count of “ones seen so far”
- when you see a `0`, you multiply by `v(ones_seen)`

This gives `A(n)` as a product that depends only on where the **zero runs** are in the binary form of `n`.

In practice we don’t scan every bit (the gaps can be huge). Instead we use the fact that between two consecutive `1` bits there is a run of zeros of known length `L`, so we multiply by `v(k)^L` using fast modular exponentiation.

### 2) Work with the positions of 1-bits (sparse binary)

Let `pos` be the sorted list of bit positions where `n` has a `1`.  
Then every gap `pos[i] - pos[i-1] - 1` is the number of zeros between consecutive ones.

For each gap we do one modular power, so the overall cost is essentially:

- `O(#ones * log(max_gap))`

### 3) Exploit the structure of `(2^t + 1)^r` for huge `t`

We use the binomial expansion:

`(1 + 2^t)^r = sum_{k=0..r} C(r,k) * 2^(k*t)`

When `t` is larger than the bit-length of every `C(r,k)`, each term occupies its own distant block of bits and **no carries occur between blocks**.  
So the binary form can be built by:

- computing each coefficient `C(r,k)` as a normal integer
- listing the set bits in that coefficient
- shifting those bit positions by `k*t`

For this problem `r = 62` and `t = 10^14 + 31`, so the separation is enormous and the sparse representation stays small.

### 4) Safety fallback

For completeness, the code also includes a fallback sparse “add with carry” routine that can multiply by `(1 + 2^t)` even when `t` is small enough to cause block overlap. It isn’t needed for the target input, but it makes the method more generally correct.

## What the program does

1. Asserts the sample value `H(3,2) = 636056` and the example `b(24) = 8`.
2. Builds the sparse 1-bit positions of `(2^t + 1)^62`.
3. Computes `A(n)` from the zero gaps using the `v(k)` sequence.
4. Prints the requested value modulo `1_000_062_031`.
