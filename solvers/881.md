# Project Euler 881 Solution - Divisor Graph Width

<https://projecteuler.net/problem=881>:

* [881.py](881.py)

This repository contains a pure-Python solution (no third‑party libraries) for **Project Euler 881: Divisor Graph Width**.

## Key ideas

### 1) Divisor graph as an exponent lattice
Write

\[
 n = \prod_{i=1}^m p_i^{e_i}.
\]

Every divisor corresponds to an exponent vector \((f_1,\dots,f_m)\) with \(0\le f_i\le e_i\). An edge connects two divisors when their quotient is prime, i.e. when you multiply/divide by exactly one prime once. In the exponent-vector view, each edge changes exactly **one coordinate by \(\pm 1\)**.

Starting from \(n\) (the vector \((e_1,\dots,e_m)\)), reaching a divisor \((f_1,\dots,f_m)\) requires decreasing coordinates; the shortest path length is the **Manhattan distance**:

\[
\text{dist}(n, d) = \sum_i (e_i - f_i).
\]

So “level \(k\)” consists of all divisors whose total exponent *deficit* equals \(k\).

### 2) Level sizes via generating functions
For each prime \(p_i^{e_i}\), the deficit in that coordinate can be any integer from \(0\) to \(e_i\). The number of divisors at level \(k\) is therefore the coefficient of \(x^k\) in

\[
P(x) = \prod_{i=1}^m (1 + x + \cdots + x^{e_i}).
\]

The required quantity is

\[
 g(n) = \max_k [x^k]P(x).
\]

### 3) Fast multiplication by \(1+x+\cdots+x^e\)
Each factor \(1+x+\cdots+x^e\) has all coefficients equal to 1, so multiplying a coefficient array by this factor is a **sliding-window sum**:

\[
\text{new}[j] = \sum_{t=j-e}^{j} \text{old}[t]
\]

(with indices clamped to valid ranges). Using prefix sums, each multiplication runs in linear time in the polynomial length.

### 4) Searching for the smallest \(n\)
The width \(g(n)\) depends only on the exponent multiset \(\{e_i\}\), while the numeric value of \(n\) is minimized by assigning **larger exponents to smaller primes**. Thus we search over exponent sequences constrained to be **non-increasing**:

\[
 e_1 \ge e_2 \ge \cdots \ge e_m \ge 1.
\]

A branch-and-bound DFS builds exponents prime-by-prime:

- maintain the current polynomial coefficients and its current maximum coefficient (the current best possible level width),
- maintain the current numeric value of \(n\),
- prune any branch where \(n\) already exceeds the best solution found so far.

An initial (easy) upper bound is obtained by using only exponent 1 (distinct primes), i.e. \((1+x)^m\), increasing \(m\) until the peak coefficient reaches the target.

## Files

- `main.py` — implementation and solver; includes asserts for the example values from the statement.
