# Project Euler 388 Solution - Distinct Lines

<https://projecteuler.net/problem=388>:

* [388.py](388.py)

## Key observation
A line from the origin to a lattice point `(a,b,c)` depends only on its **direction**.  
All points on the same line are integer multiples of a **primitive** direction vector, i.e. a triple with `gcd(a,b,c)=1`.  
So `D(N)` equals the number of primitive integer triples in the cube `0 ≤ a,b,c ≤ N` excluding the origin.

## Möbius inversion
Let `μ(d)` be the Möbius function. Using the standard gcd-counting trick:

- The number of triples whose coordinates are all divisible by `d` is `(⌊N/d⌋ + 1)^3`.
- Möbius inversion extracts the contribution from `gcd(a,b,c)=1`.

Handling the `(0,0,0)` triple gives:

\[
D(N)=\sum_{d=1}^{N}\mu(d)\left((\lfloor N/d\rfloor+1)^3-1\right)
\]

Let `q = ⌊N/d⌋`. Then `((q+1)^3-1) = q^3+3q^2+3q`, a small polynomial.

## Fast summatory Möbius: Du Jiao sieve (memoized recursion)
To evaluate ranges like `∑_{d=l..r} μ(d)` quickly, we need the **Mertens function**:

\[
M(n)=\sum_{k=1}^{n}\mu(k)
\]

For large `n`, `M(n)` is computed with the classic divide-and-group recursion:

\[
M(n)=1-\sum_{l=2}^{n} (r-l+1)\,M(\lfloor n/l\rfloor)
\]
where `r = ⌊n / ⌊n/l⌋⌋`, so the quotient is constant on `[l,r]`.

We precompute `μ` and `M` up to
\[
B=\left\lfloor (N^2)^{1/3}\right\rfloor \approx N^{2/3}
\]
and memoize `M(n)` for `n > B`.

## Splitting the main sum at `B`
Compute

- **Part 1:** `d ≤ B` using only the precomputed prefix sums `M_small`.
- **Part 2:** `d > B` implies `q = ⌊N/d⌋ ≤ N/(B+1) ≈ N^{1/3}`, so only ~`N^{1/3}` quotients remain.  
  For each small `q`, the contributing `d` range is `(N//(q+1), N//q]`, and its Möbius sum is `M(right) - M(left-1)`.

This yields a solution fast enough for `N = 10^10` in pure Python.

## Output format
The required answer is the first 9 digits of `D(10^10)` immediately followed by the last 9 digits.
