# Project Euler 375 Solution - Minimum of Subsequences

<https://projecteuler.net/problem=375>:

* [375.py](375.py)

This repo solves **Project Euler 375** in `main.py` (no third‑party libraries).

## Key techniques

### 1) Online sum of subarray minimums (monotone stack)

Define

- `f(i) = sum_{k=1..i} min(S_k..S_i)` (sum of minima over all subarrays ending at `i`)
- `M(N) = sum_{i=1..N} f(i)`

We can compute `f(i)` online with a **monotone increasing stack** of pairs `(value, count)`:

- Each pair represents a block of suffixes ending at `i` that share the same minimum `value`,
  and `count` is how many suffixes have that minimum.
- Maintain `cur_sum = sum(value * count)` which equals `f(i)`.

When a new value `x` arrives:

1. Start `count = 1`.
2. While the stack top has `value >= x`, pop it and merge its `count` into ours (because `x` becomes the new minimum for all those suffixes).
3. Push `(x, count)`.
4. Update `cur_sum` accordingly and add it to the global total.

This gives **amortized O(1)** work per element, i.e. **O(N)** for a direct run.

### 2) Exploiting the PRNG’s short period

The PRNG

- `S0 = 290797`
- `S_{n+1} = S_n^2 mod 50515093`

produces a repeating sequence with period

- `CYCLE_LEN = 6,308,948` for outputs `S1, S2, ...`

So the infinite sequence is a repetition of one block of length `CYCLE_LEN`.

`main.py` generates this cycle once (stored as a compact `array('I')`).

### 3) Quadratic extrapolation across repeated blocks

Let `L = CYCLE_LEN`, and fix a remainder `r` with `0 <= r < L`.
Consider the values

- `f(k) = M(k*L + r)` for `k = 1, 2, 3, ...`

Because the underlying sequence repeats every `L` terms, the incremental contribution of each additional full block grows linearly in `k`,
so `f(k)` becomes **exactly a quadratic polynomial**:

- `f(k) = a*k^2 + b*k + c`

We compute `f(1)`, `f(2)`, and `f(3)` by running the monotone-stack algorithm over `3*L + r` terms (one pass),
fit `(a,b,c)` using second differences, and then evaluate at the required `k = N // L`.

For the actual problem:

- `N = 2,000,000,000`
- `N = 317*L + 63,484`

so only three cycles plus a short remainder must be processed directly.

## Running

```bash
python3 main.py
```

The program also asserts the problem’s provided checks:

- `M(10) = 432256955`
- `M(10000) = 3264567774119`
