# Project Euler 664 Solution - An Infinite Game

<https://projecteuler.net/problem=664>:

* [664.py](664.py)

## 1) Recognizing the game: a “Conway’s Soldiers” style move

A single move:

- chooses a token `T`,
- discards one token from a *neighboring* square,
- moves `T` to a neighboring square.

In terms of **token counts per square**, every move has the form

- remove 1 token from a square `u`,
- remove 1 token from an adjacent square `v`,
- add 1 token to some neighbor `w` of `v`.

So it is a **2 → 1** transformation on a local pattern, the same kind of “mass loss”
that appears in Conway’s Soldiers / solitaire-army puzzles.

That makes the classic **pagoda-function** (potential function) technique apply.

## 2) Pagoda function (potential) with the golden ratio conjugate

Let

- `φ = (1+√5)/2` (golden ratio),
- `σ = 1/φ = (√5−1)/2`, so `σ² + σ = 1`.

Pick a target square (the one `m` squares to the right of the dividing line) and
assign each square a **weight**

- `weight = σ^(ManhattanDistanceToTarget)`.

Because adjacent squares differ in Manhattan distance by `±1`, any legal move
(removing two tokens and creating one token nearby) cannot increase the total
weighted sum — this is the same “pagoda condition” used in Conway’s Soldiers,
and it relies on the identity `σ² + σ = 1`.

Therefore, if we denote the total weight by `W`, then throughout the game:

- `W` is **non-increasing**.

To actually *reach* the target square (weight `σ^0 = 1`), the initial position
must have **strictly more than** 1 total weight available for that target. This
strictness is what makes `F(0)=4` instead of 5.

## 3) Reducing the initial weight to a 1D series

In the Euler setup, every row is identical, and the `d`‑th column to the left
starts with `d^n` tokens per square.

When the target is `m` squares to the right of the line, the total initial weight
factorizes into:

- a vertical geometric sum (over all rows), and
- a horizontal sum over columns (weighted by distance to target).

This collapses the condition to a single series:

\[
A_n = \sum_{d\ge 1} d^n \, \sigma^d
\]

and the final formula:

\[
F(n) = 3 + \left\lceil \log_\varphi(A_n)\right\rceil.
\]

## 4) Computing `log(A_n)` for huge `n` via singularity analysis

Directly summing `A_n` is impossible for `n = 1,234,567`, but we only need
`log(A_n)`.

Observe that `A_n` is the *n*‑th moment of a geometric series and is the
*n*‑th derivative at 0 of a simple rational function:

\[
\sum_{n\ge 0} A_n \frac{x^n}{n!}
= \sum_{d\ge 1} \sigma^d e^{dx}
= \frac{\sigma e^x}{1-\sigma e^x}.
\]

This exponential generating function has a **dominant simple pole** at

- `x0 = ln(φ)`,

and the residue is 1, yielding the coefficient estimate

\[
A_n \approx \frac{n!}{(\ln \varphi)^{n+1}},
\]

with an error that is exponentially tiny (because the next poles are at
`ln(φ) ± 2π i`, far away). For `n = 1,234,567` this approximation is effectively
exact for the purposes of the final `ceil`.

So we compute:

- `ln(A_n) = ln(n!) − (n+1) ln(ln φ)`

using `math.lgamma` for `ln(n!)`, and then apply the formula for `F(n)`.

## 5) Complexity

- Time: `O(1)`
- Memory: `O(1)`

The program prints the required value `F(1234567)` and includes asserts for all
sample values given in the problem statement.
