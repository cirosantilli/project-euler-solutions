# Project Euler 574 Solution - Verifying Primes

<https://projecteuler.net/problem=574>:

* [574.py](574.py)

This repo contains a pure-Python solution (no third-party libraries) for Project Euler problem 574.

## Key ideas

### 1) The best `q` is always the smallest one
For a given prime `p`, the verification rule only needs **some** prime `q` with `p < q²`.

If a pair `(A,B)` works for a larger `q₂`, then it automatically works for any smaller prime `q₁ < q₂`
that still satisfies `p < q₁²`, because the “must be divisible by every prime `< q`” requirement becomes
weaker as `q` decreases.

So `V(p)` can be computed using only:

- `q =` the smallest prime such that `q² > p`.

### 2) Turn the divisibility conditions into congruences
For the **difference** verification `p = A - B` (so `A = B + p`):

For each prime `r < q`, we must have `r | A` or `r | B`, and `gcd(A,B)=1` prevents `r` dividing both.
So `B` must satisfy **one** of:

- `B ≡ 0 (mod r)`  (meaning `r | B`)
- `B ≡ -p (mod r)` (meaning `r | A = B+p`)

Similarly, for the **sum** verification `p = A + B` (so `A = p - B`):

- `B ≡ 0 (mod r)`  or  `B ≡ p (mod r)`

Because the moduli are distinct primes, each choice of “0 vs ±p” for every `r<q` yields exactly one residue
class modulo the primorial:

- `M = ∏_{r<q} r`

### 3) Use a Chinese Remainder “basis”
Precompute CRT basis elements `base_r` modulo `M` such that:

- `base_r ≡ 1 (mod r)`
- `base_r ≡ 0 (mod s)` for every other prime `s < q`

Then any solution `B (mod M)` is just a subset sum of terms of the form:

- `term_r = (±p mod r) * base_r   (mod M)`

So enumerating all assignments of primes to `A` vs `B` becomes enumerating subset sums.

### 4) Meet-in-the-middle subset sums
The number of primes `< q` is at most 18 for `p < 3800`, so:

- split the terms into two halves
- enumerate all subset sums in each half (`≤ 2⁹ = 512` each)
- combine them efficiently to get the best residue modulo `M`

For the **difference** case we want the **smallest positive** `B`. The smallest residues often arise from
“wrap-around” combinations where `(left + right) ≥ M`, so the search focuses on pairs just over `M`
(using binary search in a sorted list of right-side sums).

For the **sum** case we want the **largest** `B ≤ ⌊p/2⌋`, but this only occurs for small `q`, so brute force
over all `2^k` residues is tiny there.

### 5) `gcd(A,B)` becomes trivial for primes `p`
With `A = B + p` or `A = p - B`:

- `gcd(A,B) = gcd(B, p)`

Since `p` is prime and `0 < B < p` in the sum case, `gcd` is automatically 1.
In the difference case we only need to ensure `B` is not a multiple of `p`.

## What the program does

- Generates primes with a sieve.
- For each prime `p < 3800`, sets `q` to the smallest prime with `q² > p`.
- Computes `V(p)` from the best (smallest `A`) of:
  - a difference representation `p = A - B`
  - a sum representation `p = A + B` (when feasible)
- Sums `V(p)` for all primes `p < 3800` and prints `S(3800)`.

The included assertions cover the sample values given in the problem statement.
