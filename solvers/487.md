# Project Euler 487 Solution - Sums of Power Sums

<https://projecteuler.net/problem=487>:

* [487.py](487.py)

We need

\[
\sum_{p} \left(S_{10000}(10^{12}) \bmod p\right)
\]

over all primes \(p\) in \([2\cdot 10^9,\;2\cdot 10^9+2000]\), where

- \(f_k(n)=\sum_{i=1}^{n} i^k\)
- \(S_k(n)=\sum_{i=1}^{n} f_k(i)\)

## Key algebraic reduction

Swap the order of summation:

\[
S_k(n)=\sum_{i=1}^{n}\sum_{j=1}^{i} j^k
      =\sum_{j=1}^{n} (n-j+1)\,j^k
\]

so

\[
S_k(n)=(n+1)\sum_{j=1}^{n} j^k-\sum_{j=1}^{n} j^{k+1}
      =(n+1)f_k(n)-f_{k+1}(n)
\]

Thus, for each prime modulus \(p\), it suffices to compute \(f_{10000}(10^{12}) \bmod p\) and
\(f_{10001}(10^{12}) \bmod p\).

## Power sums are polynomials

For fixed \(k\), the function \(f_k(n)\) is a polynomial in \(n\) of degree \(k+1\) (Faulhaber's theorem).
Over a prime field \(\mathbb{F}_p\) (and here \(p\gg k\)), we can evaluate this polynomial at large \(n\)
using only its values at small points.

- \(f_{10000}(n)\) has degree \(10001\)
- \(f_{10001}(n)\) has degree \(10002\)

So we precompute:
- \(f_{10000}(i)\) for \(i=0..10001\)
- \(f_{10001}(i)\) for \(i=0..10002\)

all modulo \(p\), using prefix sums and one modular `pow()` per \(i\).

## Fast Lagrange interpolation on consecutive points

Given a degree-\(d\) polynomial \(P\) and values \(P(0),P(1),...,P(d)\), Lagrange interpolation gives:

\[
P(n)=\sum_{i=0}^{d} P(i)\prod_{j\ne i}\frac{n-j}{i-j}
\]

When sample points are consecutive integers, the denominator simplifies:

\[
\prod_{j\ne i}(i-j)=i!\cdot (-1)^{d-i}\cdot (d-i)!
\]

This allows an **\(O(d)\)** evaluation using:
- prefix products \(\prod_{j< i}(n-j)\)
- suffix products \(\prod_{j> i}(n-j)\)
- precomputed inverse factorials \((i!)^{-1}\) via Fermat's little theorem

All arithmetic is done modulo \(p\).

## Prime generation in the interval

The interval length is only 2001, so we:
1. sieve primes up to \(\sqrt{2\cdot 10^9+2000}\)
2. trial-divide each candidate in the interval by these small primes

## Complexity

Let \(d \approx 10^4\) and there are about 100 primes in the interval.

Per prime:
- build power-sum tables: \(O(d)\) modular exponentiations
- two Lagrange evaluations: \(O(d)\)

Overall runtime is comfortably fast in pure Python.
