# Project Euler 979 Solution - Heptagon Hopping

<https://projecteuler.net/problem=979>:

* [979.py](979.py)

This solution counts closed walks of length `n` on the adjacency graph of the regular hyperbolic tiling `{7,3}` (heptagons, three meeting at each vertex).

## Main ideas

### 1) Radius bound for closed walks
In any graph, a single move can change the distance to the start by at most `1`. Therefore a walk that starts and ends at the start in `n` steps can never reach distance larger than `⌊n/2⌋`.

For `n = 20`, it is enough to build the tiling graph **only out to layer 10**.

### 2) Layer-by-layer construction via a substitution rule
Tiles at a fixed distance from the start form a cycle (“layer”). Each tile in a layer is one of two combinatorial types:

- **Type I**: has **one** neighbor in the previous layer.
- **Type II**: has **two** neighbors in the previous layer.

As you go outward, the cyclic sequence of types in layer `k+1` is obtained from layer `k` by a simple substitution:

- `I  →  I I II`
- `II →  I II`

Interpreting the last `II` in each substituted block as the “corner” between consecutive tiles gives a direct parent mapping:

- each `I` in the new layer has **one** inward neighbor (its parent tile),
- each `II` in the new layer has **two** inward neighbors (its parent and the next tile on the cycle).

Together with the cycle edges inside each layer, this is enough to build the induced subgraph on layers `0..⌊n/2⌋`.

### 3) Dynamic programming for walk counts
With the finite induced subgraph built, `F(n)` is computed by standard DP:

- `dp[v]` = number of ways to be at vertex `v` after the current number of steps.
- For each step, distribute `dp[v]` to all neighbors of `v`.

After `n` steps, the answer is `dp[start]`.

## Complexity
For `n = 20`, the graph up to radius 10 has about `7.7e4` vertices, each of degree at most `7`. The DP runs in `O(n * E)` time with modest memory.
