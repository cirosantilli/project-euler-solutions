# Project Euler 771 Solution - Pseudo Geometric Sequences

<https://projecteuler.net/problem=771>:

* [771.py](771.py)

We count all strictly increasing integer sequences `a0..an` (n ≥ 4) with
`|a_i^2 − a_{i−1} a_{i+1}| ≤ 2`. The structure of such sequences collapses into a
small set of families plus a finite list of exceptional sequences.

## Key ideas

1. **Exact geometric sequences (k = 0)**
   - The condition `a_i^2 = a_{i-1} a_{i+1}` forces a fixed ratio.
   - Writing the ratio as `p/q` in lowest terms, every sequence is
     `a0 * p^i / q^i` with `q | a0`.
   - Counting all subsequences of length ≥ 5 reduces to summing
     `phi(p) * floor(N / p^e)` for all `p` and `e ≥ 4`. This is the standard
     primitive-ratio count and is computed by a totient sieve.

2. **Constant error sequences (k = ±1, ±2)**
   - For k in {±1, ±2}, valid sequences satisfy a linear recurrence
     `a_{n+1} = m a_n ± a_{n-1}` with `m` fixed by the first three terms.
   - Only a few families actually occur:
     - `s = +1`: all `m ≥ 1` with start `(1, m)` (k = 1), plus the single extra
       family `(1, 3)` with `m = 2` (k = 2).
     - `s = -1`: all `m ≥ 3` with start `(1, m)` (k = 1), plus `(1, 2)` at `m = 3`
       (k = −1) and `(1, 3)` at `m = 4` (k = −2).
   - Each recurrence is a single increasing sequence. The number of subsequences
     of length ≥ 5 is `(L-4)(L-3)/2`, where `L` is the length up to `N`.

3. **Consecutive sequences**
   - `a_i = a_0 + i` satisfies the constraint with k = 1.
   - Count is simply `(N-4)(N-3)/2`.

4. **Exceptional sequences**
   - The only non-family starts are `(1,2)` and `(2,3)`.
   - From `(1,2)` there is one infinite path `1,2,6,18,54,...` (k = −2 then 0s),
     contributing one sequence per prefix of length ≥ 5.
   - All other exceptions are finite and can be precomputed by DFS up to a
     small bound; their maximum term is 60.

## Algorithm

- Precompute `phi` up to `floor(N^(1/4))` for geometric sequences.
- Count:
  - consecutive sequences
  - geometric sequences via totient summation
  - regular recurrence families
  - exceptional sequences (finite list + infinite prefix count)
- Return the total modulo `1_000_000_007`.

## Complexity

- `phi` sieve: `O(P log log P)` where `P = floor(N^(1/4))` (≈ 31622 for `N=10^18`).
- Counting loops are `O(P log N)` with small constants.
- Total runtime is well under a second on PyPy3.
