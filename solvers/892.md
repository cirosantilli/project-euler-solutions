# Project Euler 892 Solution - Zebra Circles

<https://projecteuler.net/problem=892>:

* [892.py](892.py)

## Key ideas

### 1) Convert the geometry to a tree problem
A “cutting” is a non‑crossing perfect matching of the `2n` marked points by `n` chords.
Adding non‑intersecting chords one by one always splits one existing region into two, so the `n` chords produce exactly `n+1` regions.

Build the **dual graph**: vertices are regions, and each chord connects the two regions it separates.
Each added chord increases the region count by 1, so the dual has `n` edges and `n+1` vertices — therefore it is a **tree**.

The black/white rule (“adjacent pieces have opposite colours”) is exactly a 2‑colouring of this tree.
So for a cutting `C`,

*`d(C)` = absolute difference between the sizes of the two bipartition classes of the dual tree.*

### 2) Use Catalan objects
Non‑crossing matchings are counted by the Catalan numbers, and so are rooted plane trees with `n` edges.
Via the dual tree (rooted at the outer region), each cutting corresponds to a rooted plane tree.

For a rooted tree, the bipartition is “even depth vs odd depth” from the root.
Define

- `E` = number of vertices at even depth,
- `O` = number of vertices at odd depth.

Then `E+O = n+1` and `d(C) = |E - O|`.

A standard parenthesis/Dyck‑path encoding of rooted plane trees shows that `E` is “1 + the number of up‑steps that end at an even height”.
That statistic is distributed by the **Narayana numbers**.

### 3) Collapse the Narayana sum
Writing `N(n,k)` for the Narayana number (a refined Catalan count), one gets a weighted sum

`D(n) = Σ |E-O|` over all trees of size `n`.

After rewriting the weight in terms of the Narayana parameter, the sum becomes a hypergeometric sum.
It satisfies a simple first‑order multiplicative recurrence, which yields closed forms:

- If `n = 2r` (even):
  - `D(2r) = (1/2) * C(2r, r)^2`
- If `n = 2r+1` (odd):
  - `D(2r+1) = (2r)/(r+1) * C(2r, r)^2`

So everything reduces to central binomial coefficients.

### 4) Fast modular computation
The modulus `1234567891` is prime, so division is done with modular inverses.

To compute

`S = Σ_{n=1..10^7} D(n) (mod M)`

efficiently, the program iterates `r = 0..5·10^6` while maintaining `C(2r,r) (mod M)` using

`C(2(r+1), r+1) = C(2r,r) * (2r+1)(2r+2) / (r+1)^2`.

All inverses `inv[i] = i^{-1} (mod M)` for `i ≤ 5·10^6+1` are precomputed in linear time using the classic recurrence

`inv[i] = -(M//i) * inv[M%i] (mod M)`.

This makes the overall solution **O(N)** time with modest memory.
