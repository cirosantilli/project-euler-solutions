#!/usr/bin/env python3
"""
Project Euler 718 - Unreachable Numbers

We need G(6) where unreachable n are those for which:
    17^p * a + 19^p * b + 23^p * c = n
has no solution in positive integers a,b,c (and fixed p).

This program computes G(p) modulo 1_000_000_007 without external libraries.
"""

from array import array

MOD = 1_000_000_007


def egcd(a: int, b: int):
    """Extended GCD: returns (g, x, y) with ax + by = g = gcd(a,b)."""
    x0, y0, x1, y1 = 1, 0, 0, 1
    while b:
        q = a // b
        a, b = b, a - q * b
        x0, x1 = x1, x0 - q * x1
        y0, y1 = y1, y0 - q * y1
    return a, x0, y0


def inv_mod(a: int, m: int) -> int:
    """Multiplicative inverse of a modulo m (assumes gcd(a,m)=1)."""
    g, x, _ = egcd(a, m)
    if g != 1:
        raise ValueError("inverse does not exist")
    return x % m


def G_mod(p: int, mod: int = MOD) -> int:
    """
    Compute G(p) modulo mod.

    Let A=17^p, B=19^p, C=23^p, S=A+B+C.
    Positive coefficients correspond to shifting by S:
        n reachable with a,b,c>=1  <=>  n-S reachable with nonnegative coeffs for A,B,C.

    So:
      G(p) = sum_{n=1}^{S-1} n  +  sum_{m unreachable (nonneg)} (m+S)
           = (S-1)S/2  +  sum_gaps  +  count_gaps * S
    where "gaps" are the nonrepresentable nonnegative integers for the semigroup <A,B,C>.
    """
    A = 17**p
    B = 19**p
    C = 23**p
    S = A + B + C

    # We compute all "gaps" for the semigroup generated by {A,B,C} with nonnegative coefficients.
    # Standard approach: For each residue r (mod A), find d[r] = smallest representable value â‰¡ r (mod A).
    # Then every value r + k*A is representable iff k >= (d[r]-r)/A.
    #
    # Here we compute d[r] for all residues in O(A) using a prefix-min trick (see README).

    BmodA = B % A
    invB = inv_mod(BmodA, A)
    s = (C % A) * invB % A  # s = C * B^{-1} (mod A)
    invs = inv_mod(s, A)  # s^{-1} (mod A)

    # prefix_min[t] = min_{u<=t} (k(u)*C + B*u), where k(u) is derived from congruences.
    prefix_min = array("Q", [0]) * A

    k = 0  # k(t) for current t; starts at t=0: k(0)=0
    bt = 0  # B*t
    cur_min = (1 << 63) - 1

    # k(t+1) = k(t) - invs  (mod A); we maintain it via subtraction with a conditional add.
    for t in range(A):
        val = k * C + bt
        if val < cur_min:
            cur_min = val
        prefix_min[t] = cur_min
        bt += B
        k -= invs
        if k < 0:
            k += A

    INF = 10**40
    running_min2 = INF  # min over adjusted suffix values
    BA = B * A

    # For the suffix side we need values in descending t: t = A-1, A-2, ..., 1 (added one per step).
    # Note: k(A-1) = (-(A-1)*invs) mod A = invs mod A.
    kt = invs
    bt2 = B * (A - 1)

    total_count = 0  # number of gaps in semigroup <A,B,C>
    total_sum = 0  # sum of those gaps

    bx = 0  # B * r0, where r0 runs 0..A-1
    r = 0  # residue r = (r0 * B) mod A; updated incrementally

    for r0 in range(A):
        if r0 > 0:
            # Add t = A - r0 to the suffix set (this is t descending: A-1, A-2, ..., 1)
            val2 = kt * C + bt2 - BA
            if val2 < running_min2:
                running_min2 = val2

            # Prepare next kt, bt2 for the next smaller t
            bt2 -= B
            kt += invs
            if kt >= A:
                kt -= A

        cut = A - r0 - 1
        min1 = prefix_min[cut]
        h = running_min2 if running_min2 < min1 else min1
        d = bx + h

        # d = q*A + r, so q is exactly the count of gaps in residue class r.
        q = d // A
        total_count += q
        total_sum += q * r + A * (q * (q - 1) // 2)

        # advance
        bx += B
        r += BmodA
        if r >= A:
            r -= A

    # Combine with the positive-coefficient shift.
    base_sum = (S - 1) * S // 2
    G = base_sum + total_sum + total_count * S
    return G % mod


def main() -> None:
    # Tests from the problem statement:
    assert G_mod(1) == 8253
    assert G_mod(2) == 60258000

    print(G_mod(6))


if __name__ == "__main__":
    main()
