# Project Euler 605 Solution - Pairwise Coin-Tossing Game

<https://projecteuler.net/problem=605>:

* [605.py](605.py)

## Key ideas

### 1) Re-encode the game as a coin-flip pattern search
Number rounds so that round `i` is between players `i` and `i+1` (cyclic).

Let `X_i` be the outcome of round `i`:

- `X_i = 1` if the **second** player (`i+1`) wins round `i`
- `X_i = 0` if the **first** player (`i`) wins round `i`

A player wins the entire game when they win **two consecutive rounds**. The only player who can win both rounds `i` and `i+1` is the shared player `i+1`, so the game ends exactly when:

- round `i` is won by the second player (`X_i = 1`)
- round `i+1` is won by the first player (`X_{i+1} = 0`)

So the game ends at the first occurrence of the length‑2 pattern **`10`** in the infinite i.i.d. fair coin sequence `(X_i)`.

If the first `10` ends at position `t` (i.e. `X_{t-1}X_t = 10`), then the winner is player `t (mod n)`.

---

### 2) Compute the first-hit distribution for pattern `10`
Let `T` be the index of the second bit of the first `10` (so `T ≥ 2`).

To avoid `10` up to `T`, the sequence must look like:

- some number of `0`s,
- then a `1`,
- then some number of `1`s,
- then the terminating `0`.

Counting possibilities gives:

\[
\Pr(T=m) = \frac{m-1}{2^m}\quad (m\ge 2).
\]

---

### 3) Use a geometric-series sum to get \(P_n(k)\)
Player `k` wins when `T ≡ k (mod n)`:

\[
P_n(k)=\sum_{j\ge 0} \Pr(T=k+jn)
=\sum_{j\ge 0}\frac{k+jn-1}{2^{k+jn}}.
\]

This splits into two standard series: \(\sum q^j\) and \(\sum j q^j\), with \(q = 2^{-n}\), yielding a closed form rational expression.

With \(A = 2^n-1\) and \(N_0 = (k-1)A + n\), one convenient form is:

\[
P_n(k)=\frac{2^{\,n-k}\,N_0}{A^2}.
\]

---

### 4) Last digits via modular exponentiation
The problem asks for the last 8 digits of

\[
M_n(k)= (\text{reduced numerator})\times(\text{reduced denominator}).
\]

For the target \(n=10^8+7\) (a prime), \(\gcd(n,2^n-1)=1\), which implies the fraction above is already reduced, so:

\[
M_n(k)= 2^{\,n-k}\,N_0\,(2^n-1)^2.
\]

We only need \(M_n(k)\bmod 10^8\), which is computed efficiently using Python’s built‑in `pow(base, exp, mod)` (fast exponentiation in \(O(\log n)\)).

---

## What the code does
- Verifies the examples from the statement with assertions:
  - \(P_3(1)=12/49\), \(M_3(1)=588\)
  - \(P_6(2)=368/1323\), \(M_6(2)=486864\)
- Computes the required answer for \(n=10^8+7\), \(k=10^4+7\) and prints it as 8 digits.
