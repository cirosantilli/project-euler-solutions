# Project Euler 895 Solution - Gold &amp; Silver Coin Game II

<https://projecteuler.net/problem=895>:

* [895.py](895.py)

This repository solves Project Euler problem **895** without external libraries.

The task: Count ordered triples of **three non-empty stacks** of coins (each stack height ≤ `m`) that are:

- **Fair**: the first player loses under optimal play regardless of who starts.
- **Balanced**: total number of gold coins equals total number of silver coins.

Let `G(m)` be the number of such arrangements; compute `G(9898) mod 989898989`.

---

## 1. Game Values as Dyadic Rationals (Hackenbush Stalks)

Each stack is a *partizan game* equivalent to a **Hackenbush stalk**, therefore its value is a **dyadic rational**.

A key structural fact:

- A stack is either **monochrome** (all gold or all silver) → integer value.
- Or **mixed** (first color change occurs somewhere) → dyadic value of the form

\[
v = k + \frac{2x+1}{2^t}
\]

Where:

- `t ≥ 1` is the remaining length from the first color change to the top,
- `x` encodes the upper part of the stack in binary,
- `k` is an integer “base” determined by the length of the initial run of the bottom color.

---

## 2. Balance Condition Becomes a Popcount Expression

Let `D(stack) = #gold − #silver`.

For a mixed stack:

\[
D = k + offset + w
\]

Where:

- `offset = 0` if the stack starts with gold,
- `offset = 1` if the stack starts with silver,
- and

\[
w = 2\cdot \text{popcount}(x) - (t-1)
\]

Thus balance constraints reduce to constraints on **popcounts**, and (for three mixed stacks) ultimately to a constraint on **carry counts** during binary addition.

---

## 3. Case Split by Number of Mixed Stacks

Since each stack is either integer or dyadic, fairness forces strong constraints:

### Case A — 0 mixed stacks (all monochrome)
All values are integers; fairness and balance coincide.
This yields a simple closed form: `3*m*(m-1)`.

### Case B — 2 mixed stacks + 1 monochrome
The two dyadic fractional parts must sum to `1`.
This forces them to have **the same denominator**, and their `x` values become bitwise complements.
Balance then forces exactly one mixed stack to start gold and the other silver.
This leads to an O(m) summation.

### Case C — 3 mixed stacks
The fractional parts must sum to `1` or `2`.
A parity argument shows the largest denominator must appear **exactly twice**, so denominators are:

\[
(T,T,u)\qquad \text{with } u < T
\]

This eliminates a full 3D denominator search.

---

## 4. Carry-Sequence DP for the Dyadic Constraints

For the core equation

\[
\frac{2x_1+1}{2^T} + \frac{2x_2+1}{2^T} + \frac{2x_3+1}{2^u} \in \{1,2\}
\]

one can separate into:

- free low bits (giving a power-of-2 factor),
- and a **u-bit constrained sum** that forces the binary result to be all 1s.

The balance condition collapses to a linear function of the **number of carries**.

A compact DP counts weighted carry sequences of length `u`:

- states = carry-in bit (`0` or `1`)
- DP index = number of `1` carry states among internal positions
- transitions weighted by how many digit-triples produce them (`3` if carry stays, `1` if it flips)

This yields all needed numerator counts for all `u ≤ m` in total O(m²) updates but O(m) memory.

---

## 5. Eliminating the `T` Loop with Geometric Prefix Sums

Even though denominators are `(T,T,u)`, naively summing over `T` would still be quadratic.

We substitute:

- `a = m − T`
- `b = m − u`

So `a` ranges from `1..b-1` and the dyadic factor becomes a geometric weight `2^{b-a-1}`.

All base-count terms become sums of the shape:

\[
\sum_{a} \text{quadratic}(a)\cdot 2^{-a}
\]

We precompute:

- \(\sum 2^{-a}\)
- \(\sum a\cdot 2^{-a}\)
- \(\sum a^2\cdot 2^{-a}\)

allowing each weighted sum to be computed in O(1) time.

This collapses the entire three-mixed-stacks case to an O(m) sweep over `u`.

---

## 6. Summary of Techniques

✅ **Game theory → dyadic rational encoding**  
✅ **Popcount-based balance simplification**  
✅ **Casework by dyadic count (0/2/3 mixed)**  
✅ **Carry-sequence dynamic programming**  
✅ **Inclusion–exclusion for bounded 3-variable sums**  
✅ **Geometric prefix sums to remove a full loop**

---

## Running

```bash
python3 main.py
