# Project Euler 628 Solution - Open Chess Positions

<https://projecteuler.net/problem=628>:

* [628.py](628.py)

## 1) Model as permutations on a grid

Placing one pawn in every row and every column is exactly a **permutation matrix**: each valid position corresponds to a permutation of size `n`.

The rook starts at the lower-left square `(0,0)` and may move only **right** or **up** (unit steps). So we are asking whether there exists a **monotone lattice path** from `(0,0)` to `(n-1,n-1)` that avoids the `n` blocked squares (the pawns).

## 2) Characterize when a position is *not* open

A key observation is that a position is *closed* (no valid path exists) **iff** at least one of these happens:

- The permutation begins with the exact decreasing prefix  
  `(k-1, k-2, ..., 0)` for some `k ≥ 1`, i.e. the first `k` columns contain precisely the `k` smallest rows in decreasing order; or
- The permutation ends with the exact decreasing suffix  
  `(n-1, n-2, ..., n-k)` for some `k ≥ 1`, i.e. the last `k` columns contain precisely the `k` largest rows in decreasing order.

Intuitively, such a prefix (or suffix) creates a “hard barrier” near the start (or finish) that blocks all monotone paths.

## 3) Count closed positions by inclusion–exclusion

Let:

- `A_k` = permutations with the fixed decreasing prefix of length `k`.  
  Count: `|A_k| = (n-k)!` (the rest is arbitrary).
- `B_k` = permutations with the fixed decreasing suffix of length `k`.  
  Count: `|B_k| = (n-k)!`.

For overlaps:

- `A_k ∩ B_l` is possible only when the fixed prefix and suffix do **not** overlap in positions, i.e. `k + l ≤ n`.  
  Then `|A_k ∩ B_l| = (n-k-l)!`.

Applying inclusion–exclusion and simplifying the resulting sums yields a compact formula:

\[
f(n)\equiv (n-3)\sum_{i=0}^{n-1} i! + 2 \pmod{M}
\]

The sum `∑ i!` is the **left factorial** `!n`.

## 4) Modular computation

We work modulo `M = 1008691207` and compute:

- `!n = 0! + 1! + ... + (n-1)! (mod M)` via iterative multiplication,
- then `f(n) = (n-3)·!n + 2 (mod M)`.

The program asserts the sample values `f(3)=2` and `f(5)=70`, then prints `f(10^8) mod M`.
