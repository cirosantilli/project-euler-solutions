# Project Euler 945 Solution - XOR-Equation C

<https://projecteuler.net/problem=945>:

* [945.py](945.py)

This solution treats the XOR-product `⊗` as **carryless multiplication** over
the polynomial ring **GF(2)[t]**, where each integer is interpreted as a binary
polynomial.

---

## 1) Key Algebraic Interpretation

- `x ⊕ y` is polynomial addition over GF(2).
- `x ⊗ y` is polynomial multiplication mod 2 (carryless multiply).
- Squaring in GF(2) has a special property:

  \[
  \left(\sum a_i t^i\right)^2 = \sum a_i t^{2i}
  \]

So a polynomial is a square **iff** it has **no odd-degree coefficients**.

---

## 2) Reducing the Equation

The given equation is:

\[
(a \otimes a)\oplus(2\otimes a\otimes b)\oplus(b\otimes b)=c\otimes c
\]

The terms `a⊗a` and `b⊗b` are always squares → they contain only even-degree bits.

Thus the **only way the left side can be a square** is if the middle term has
**no odd-degree coefficients**.

Because `2` corresponds to multiplying by `t`, the term `2⊗a⊗b` shifts the
product `a⊗b` by one degree, meaning:

- odd coefficients in `2⊗a⊗b` correspond exactly to **even coefficients in `a⊗b`**.

Therefore:

> A pair `(a,b)` yields a solution **iff** `a⊗b` has **no bits in positions 0,2,4,...**

That is:

\[
(a \otimes b)\ \&\ 0x5555... = 0
\]

For every such pair `(a,b)`, the value of `c` exists and is **unique**.

So `F(N)` becomes a pure counting problem over `(a,b)`.

---

## 3) Symmetry and Diagonal

The condition is symmetric in `a,b`, and:

- `a⊗a` is always a square (only even-position bits),
- so the condition can only hold if `a⊗a = 0`, meaning `a=0`.

Hence the only diagonal solution is `(0,0)`.

Thus if `S(N)` counts **ordered** valid pairs `(a,b)` with `0≤a,b≤N`, then:

\[
F(N)=\frac{S(N)+1}{2}
\]

---

## 4) Splitting into Even/Odd Bit Polynomials

Write:

\[
x = X_0(t^2) + tX_1(t^2)
\]

where:

- `X0` = compacted even bits of `x`
- `X1` = compacted odd bits of `x`

This converts constraints on even-degree coefficients into constraints in a
smaller polynomial ring GF(2)[u] with `u=t^2`.

---

## 5) High-Bit Observation (Major Speedup)

If both numbers share the same top bit `2^k`, then their carryless product
contains the term `t^{2k}`, which is **even degree** and cannot cancel.

So:

> No valid pair can have both `a` and `b` in the top half `[2^k, 2^{k+1})`.

Thus for general `N`, with `2^k ≤ N < 2^{k+1}`:

- all internal solutions are exactly those from `[0,2^k-1]`
- only cross-pairs between `[0,2^k-1]` and `[2^k,N]` need to be counted

---

## 6) Cross-Counting via Polynomial GCD Degrees

For each `b = 2^k + y`, the set of valid `a` values in `[0,2^k-1]` forms a GF(2)
vector space whose size is always a power of two.

That size can be expressed using only the **degree of a polynomial gcd** in GF(2)[u],
making each `b` evaluation very fast.

---

## 7) Implementation Tricks

- **16-bit precomputed bit-compaction tables** emulate a fast "pext" operation
  for extracting even and odd bits.
- GF(2) polynomial gcd is implemented with XOR-based long division.

---

## Complexity

For the target `N = 10^7`:

- the main work is iterating `y = 0..(N-2^k)` (about 1.6 million terms)
- each term does small-degree polynomial gcd operations

This runs comfortably fast in pure Python without external libraries.
