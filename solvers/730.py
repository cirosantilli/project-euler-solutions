#!/usr/bin/env python3
"""
Project Euler 730

We count primitive k-shifted Pythagorean triples (p,q,r) of positive integers:
    p^2 + q^2 + k = r^2
with 1 <= p <= q <= r and p+q+r <= n.

Let P_k(n) be the number of such primitive triples for a given k.
Let S(m,n) = sum_{k=0..m} P_k(n).

This program computes S(100, 10^8) and prints it.
It also asserts the example values from the problem statement.
"""

from __future__ import annotations

import sys
import time
import math


# Forward generators (Berggren-style) that preserve p^2 + q^2 - r^2 (and thus preserve k)
# Children of (p,q,r):
# U*(p,q,r), V*(p,q,r), W*(p,q,r)
def child_u(p: int, q: int, r: int) -> tuple[int, int, int, int]:
    p1 = -2 * p + q + 2 * r
    q1 = -p + 2 * q + 2 * r
    r1 = -2 * p + 2 * q + 3 * r
    # perimeter quickly as a linear form
    s1 = -5 * p + 5 * q + 7 * r
    return p1, q1, r1, s1


def child_v(p: int, q: int, r: int) -> tuple[int, int, int, int]:
    p2 = p - 2 * q + 2 * r
    q2 = 2 * p - q + 2 * r
    r2 = 2 * p - 2 * q + 3 * r
    s2 = 5 * p - 5 * q + 7 * r
    return p2, q2, r2, s2


def child_w(p: int, q: int, r: int) -> tuple[int, int, int, int]:
    p3 = 2 * p + q + 2 * r
    q3 = p + 2 * q + 2 * r
    r3 = 2 * p + 2 * q + 3 * r
    s3 = 5 * p + 5 * q + 7 * r
    return p3, q3, r3, s3


# Exact integer inverses (det = Â±1) used only to detect roots (no positive ordered parent)
U_INV = ((-2, -1, 2), (1, 2, -2), (-2, -2, 3))
V_INV = ((1, 2, -2), (-2, -1, 2), (-2, -2, 3))
W_INV = ((2, 1, -2), (1, 2, -2), (-2, -2, 3))


def _apply_inv(
    M: tuple[tuple[int, int, int], ...], p: int, q: int, r: int
) -> tuple[int, int, int]:
    return (
        M[0][0] * p + M[0][1] * q + M[0][2] * r,
        M[1][0] * p + M[1][1] * q + M[1][2] * r,
        M[2][0] * p + M[2][1] * q + M[2][2] * r,
    )


def is_root(p: int, q: int, r: int) -> bool:
    """
    A triple is considered a root if none of U^{-1}, V^{-1}, W^{-1} maps it to a
    strictly positive ordered triple.
    """
    for M in (U_INV, V_INV, W_INV):
        a, b, c = _apply_inv(M, p, q, r)
        if a > 0 and b > 0 and c > 0 and a <= b <= c:
            return False
    return True


def generate_roots(max_k: int) -> list[list[tuple[int, int, int]]]:
    """
    Generate all root triples (p,q,r) for each k in [0..max_k], with 1<=p<=q<=r and gcd=1.

    A key fact: for k <= max_k, all roots occur with r bounded by O(max_k),
    so we can enumerate candidates in a small box and filter by the 'no parent' test.
    """
    # Empirically/structurally, roots are found with small r; a safe bound for max_k=100 is ~260.
    r_max = (5 * max_k + 1) // 2 + 10

    cands: list[list[tuple[int, int, int]]] = [[] for _ in range(max_k + 1)]
    for r in range(1, r_max + 1):
        rr = r * r
        for p in range(1, r + 1):
            pp = p * p
            # enumerate q so that k = r^2 - p^2 - q^2 is within range
            for q in range(p, r + 1):
                k = rr - pp - q * q
                if 0 <= k <= max_k:
                    if math.gcd(p, math.gcd(q, r)) == 1:
                        cands[k].append((p, q, r))

    roots: list[list[tuple[int, int, int]]] = [[] for _ in range(max_k + 1)]
    # k=0: the classical primitive Pythagorean triples are generated from (3,4,5)
    roots[0] = [(3, 4, 5)]

    for k in range(1, max_k + 1):
        rk: list[tuple[int, int, int]] = []
        for p, q, r in cands[k]:
            if is_root(p, q, r):
                rk.append((p, q, r))
        roots[k] = rk

    return roots


def count_from_roots(n: int, roots: list[tuple[int, int, int]]) -> int:
    """
    Count all triples in the forest generated by U,V,W from the given roots,
    limited by perimeter <= n.

    Starting from primitive roots and using unimodular transformations means
    all generated nodes remain primitive, so no gcd checks are needed here.
    """
    cnt = 0
    stack = list(roots)

    while stack:
        p, q, r = stack.pop()
        if p + q + r > n:
            continue

        cnt += 1

        p1, q1, r1, s1 = child_u(p, q, r)
        if s1 <= n:
            stack.append((p1, q1, r1))

        p2, q2, r2, s2 = child_v(p, q, r)
        if s2 <= n and not (p2 == p1 and q2 == q1 and r2 == r1):
            stack.append((p2, q2, r2))

        p3, q3, r3, s3 = child_w(p, q, r)
        if s3 <= n and not (
            (p3 == p1 and q3 == q1 and r3 == r1) or (p3 == p2 and q3 == q2 and r3 == r2)
        ):
            stack.append((p3, q3, r3))

    return cnt


def S(m: int, n: int) -> int:
    roots_by_k = generate_roots(m)
    total = 0
    for k in range(m + 1):
        total += count_from_roots(n, roots_by_k[k])
    return total


def _run_asserts() -> None:
    roots_by_k = generate_roots(100)
    n = 10_000

    # Provided example values
    assert count_from_roots(n, roots_by_k[0]) == 703
    assert count_from_roots(n, roots_by_k[20]) == 1979
    s10 = 0
    for k in range(11):
        s10 += count_from_roots(n, roots_by_k[k])
    assert s10 == 10956


def main(argv: list[str]) -> None:
    _run_asserts()

    if len(argv) == 3:
        m = int(argv[1])
        n = int(argv[2])
    else:
        m = 100
        n = 100_000_000

    t0 = time.time()
    ans = S(m, n)
    t1 = time.time()

    print(ans)
    # small timing note to stderr (doesn't affect judged output)
    print(f"computed in {t1 - t0:.3f}s", file=sys.stderr)


if __name__ == "__main__":
    main(sys.argv)
