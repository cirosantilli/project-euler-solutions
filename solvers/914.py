#!/usr/bin/env python3
"""Project Euler 914 - Triangles inside Circles

We consider primitive Pythagorean right triangles with integer sides (a,b,c).
Such a triangle fits strictly inside a circle of radius R iff its circumradius
is < R. For right triangles the circumradius is c/2, hence the constraint
c < 2R.

For a primitive triple generated by Euclid's formula:
  a = m^2 - n^2,  b = 2mn,  c = m^2 + n^2
with gcd(m,n)=1 and (m-n) odd.
The inradius of a right triangle is r = (a+b-c)/2, which simplifies to
  r = n(m-n).

So we need:
  maximize r = n(m-n)
  subject to m^2 + n^2 < 2R, gcd(m,n)=1, (m-n) odd, m>n.

For fixed n, r grows with m, so we take the largest admissible m for each n.
The optimum occurs very near the continuous optimum ratio, so scanning a small
band around the predicted n is sufficient.
"""

from __future__ import annotations

import math


def F(R: int) -> int:
    """Return F(R) as defined in the problem statement."""
    if R <= 0:
        return 0

    twoR = 2 * R
    # Need strict inequality: m^2 + n^2 < 2R  <=>  m^2 + n^2 <= 2R - 1
    limit = twoR - 1
    if limit <= 0:
        return 0

    # Continuous maximiser has m/n = 1 + sqrt(2), hence n ~= sqrt(R/(2+sqrt(2))).
    sqrt2 = math.sqrt(2.0)
    n0 = int(math.sqrt(R / (2.0 + sqrt2)))

    # Adaptive but simple search half-width around n0.
    # Empirically the maximiser is extremely close to n0 even for huge R.
    # We still keep a generous safety margin.
    W = max(10_000, n0 // 2_000 + 10_000)  # about 0.05% of n0 for large R

    best = 0

    lo = max(1, n0 - W)
    hi = n0 + W

    for n in range(lo, hi + 1):
        t = limit - n * n
        if t <= 0:
            continue

        m = math.isqrt(t)
        if m <= n:
            continue

        # Ensure (m-n) is odd (equivalently m,n opposite parity).
        if ((m - n) & 1) == 0:
            m -= 1
            if m <= n:
                continue

        # Enforce primitiveness: gcd(m,n)=1.
        # Keep parity while stepping down.
        while m > n and math.gcd(m, n) != 1:
            m -= 2

        if m <= n:
            continue

        r = n * (m - n)
        if r > best:
            best = r

    return best


def main() -> None:
    # Test value from the problem statement
    assert F(100) == 36

    print(F(10**18))


if __name__ == "__main__":
    main()
