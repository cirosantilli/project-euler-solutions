# Project Euler 677 Solution - Coloured Graphs

<https://projecteuler.net/problem=677>:

* [677.py](677.py)

This solution counts **unlabelled** connected acyclic graphs (i.e. **trees**) with vertex colours **R/B/Y**, subject to:

- degree caps: `R ≤ 4`, `B ≤ 3`, `Y ≤ 3`
- forbidden adjacency: no `Y–Y` edge

We compute `g(10000) mod 1,000,000,007`.

(Examples in the statement like `g(2)=5` confirm we’re counting *unlabelled* trees: for 2 nodes, there is 1 tree shape and 5 valid colour-multisets under swapping.)

## Main techniques

### 1) Unlabelled rooted trees via Pólya (cycle index of small symmetric groups)

For an unlabelled rooted tree, the root’s children form an **unlabelled multiset** of rooted subtrees.  
Pólya enumeration gives the ordinary generating function (OGF) for a multiset of size `m` by substituting into the cycle index of `S_m`.

Because degrees are capped (max 4), we only need `m ≤ 4`, and the cycle-index formulas are finite:

- `SET_2`: `(A1^2 + A2) / 2`
- `SET_3`: `(A1^3 + 3 A1 A2 + 2 A3) / 6`
- `SET_4`: `(A1^4 + 6 A1^2 A2 + 3 A2^2 + 8 A1 A3 + 6 A4) / 24`

with `Ak = A(x^k)`.

### 2) Planted trees to handle degree constraints cleanly

We use **planted** trees: the root has an extra “parent edge”.

- In a planted tree, if a colour has max degree `D`, then the root can have at most `D-1` children.
- This lets edge-rooted trees be built by gluing two planted trees at their roots.

We compute planted series for roots coloured `R`, `B`, `Y`, where `Y` roots may only have `R/B` children (to enforce no `Y–Y` edge).

### 3) Dissymmetry theorem (unrooted from rooted)

For the class of trees (including our colour/degree restrictions), the dissymmetry theorem gives:

> **Unrooted** = **vertex-rooted** + **edge-rooted** − **directed-edge-rooted**

We compute:
- vertex-rooted counts using the root “children multiset” OGFs (`≤4` children for red roots)
- directed-edge-rooted as an **ordered** pair of planted trees (minus the forbidden `Y–Y` case)
- edge-rooted as an **unordered** pair (cycle index of `C2`: `(A^2 + A(x^2))/2`, again subtract `Y–Y`)

### 4) Coefficient-by-coefficient dynamic programming

All series have **no constant term** (they count trees with at least one vertex), so coefficient `n` depends only on smaller coefficients.  
We build coefficients from `1..10000`, using simple convolution sums for:

- squares: `A(x)^2`
- a cube term needed for `SET_3`: `A(x)^3` via `A * (A^2)`
- a mixed term `A(x) * A(x^2)`

All arithmetic is done modulo `1,000,000,007` (prime), so divisions by `2,6,24` use modular inverses.

## Complexity

Let `N = 10000`.

The dominant work is the convolution-like sums while building the planted series, roughly `O(N^2)` with small constants (degree cap ≤ 4).  
This is fast enough in pure Python without external libraries.
