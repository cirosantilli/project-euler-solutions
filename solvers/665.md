# Project Euler 665 Solution - Proportionate Nim

<https://projecteuler.net/problem=665>:

* [665.py](665.py)

This repository contains a single-file solver (`main.py`) for the game:

- remove **n** from one heap, or
- remove **n** from both heaps, or
- remove **n** from one heap and **2n** from the other.

A position `(n, m)` is losing if the next player cannot force a win.  
The task is to compute:

> `f(M)`: the sum of `n+m` over all losing positions `(n, m)` with `n ≤ m` and `n+m ≤ M`, for `M = 10^7`.

The program also checks the small values supplied in the statement via `assert`s.

## Main ideas

### 1) Invariants that must be unique among losing positions

If two losing positions could be connected by a legal move, the larger one would not be losing.  
That forces uniqueness constraints for certain simple expressions:

1. **Single-heap move** preserves one coordinate  
   → no two losing positions may share a heap size.

2. **Equal removal from both heaps** preserves the **difference**  
   → no two losing positions may share the same value of `m - n` (with `m ≥ n`).

3. **1:2 removal** preserves the linear form `x - 2y` in the *orientation that removes `2n` from `x`*  
   → for an unordered pair `{n,m}`, both oriented values `m - 2n` and `n - 2m` must be unique overall.

These are exactly the quantities tracked while constructing the losing positions.

### 2) Greedy construction of losing pairs

Because each heap size appears in **exactly one** losing position, the losing positions can be generated by
repeatedly choosing:

- `a` = the smallest positive heap size not used yet,
- `b` = the smallest value `> a` that creates no collision in:
  - used coordinates,
  - used differences `b-a`,
  - used values of `b-2a` and `a-2b`.

This produces the losing positions in increasing order of the smallest coordinate.

### 3) Making it fast with successor DSU (“next unused”)

A naïve scan for `b` would try enormous runs of illegal candidates.

To skip these efficiently, the solver uses the classic *successor disjoint-set union* trick:

- keep an array `parent[]` such that `find(x)` returns the smallest unused value `≥ x`,
- when a value is used, link it to `find(x+1)`.

Three such structures are used:

- for **coordinates**,
- for **differences**,
- for the **linear form** values `x-2y` (over a fixed bounded range).

Each rejection of a candidate `b` can “jump” directly to the next potentially valid value, keeping the
overall work close to linear in the number of generated losing positions.

## Running

```bash
python3 main.py
```

Optionally you can pass a different `M`:

```bash
python3 main.py 1000
```

The script prints `f(M)` and runs the statement’s checks via `assert`.
