# Project Euler 660 Solution - Pandigital Triangles

<https://projecteuler.net/problem=660>:

* [660.py](660.py)

This repository contains a pure-Python solution for Project Euler 660 (Pandigital Triangles).

## Key ideas

### 1) 120° integer triangles via a parametrization
A triangle with a 120° angle satisfies

\[
L^2 = x^2 + y^2 + x y
\]

where `L` is the side opposite the 120° angle (and is the largest side).

All *primitive* integer solutions can be generated from coprime integers `m > n > 0` with `(m-n) % 3 != 0`:

- `L = m^2 + m n + n^2`
- `x = 2 m n + n^2`
- `y = m^2 - n^2`

Any non-primitive solution is a scalar multiple of a primitive one.

### 2) Tight size bounds from digit-count constraints
For base `b`, an `b`-pandigital triangle uses exactly `b` digits total across the three sides in base `b`.

Using the inequality `L < x + y` and the fact that `x, y >= L/2`, if `L` has `D` base-`b` digits then the other two sides have at least `D-1` digits. Therefore:

\[
D + (D-1) + (D-1) \le b \quad \Rightarrow \quad D \le \left\lfloor \frac{b+2}{3}\right\rfloor
\]

So we only need to consider largest sides

\[
L < b^{\left\lfloor \frac{b+2}{3}\right\rfloor}.
\]

This gives a practical finite search.

### 3) Digit-length partitioning for the scale factor
For a primitive triple `(L, x, y)` and a base `b`, we test multiples `k(L, x, y)`.

Rather than checking every `k`, we compute integer intervals of `k` where each side has a fixed digit length in base `b`, and only consider length triples `(dL, dx, dy)` with:

- `1 <= d* <= Dmax`
- `dL + dx + dy = b`

Each such length triple yields an intersection interval `[Lk, Rk]` for valid `k`.

### 4) A modular filter from digit sums
In base `b`, a number is congruent to its digit sum modulo `b-1`. Since a pandigital triangle uses all digits exactly once, the total digit sum is fixed, which imposes:

\[
k(L+x+y) \equiv T \pmod{b-1}
\]

with `T = 0` for even `b`, and `T = (b-1)/2` for odd `b`.

This turns `k` into an arithmetic progression inside each `[Lk, Rk]`, substantially reducing candidates.

### 5) Bitmask digit checking with chunk tables
To test “all digits used exactly once” quickly, digits are tracked as a bitmask (bases up to 18 fit in a machine integer).

Base conversion is accelerated by precomputing masks for 1-, 2-, and 3-digit chunks, then splitting up to 6-digit numbers into `3+3` digits and combining masks (rejecting overlaps).

### 6) Incremental updates for multiples
Inside a fixed `k` progression, side lengths are updated with additions (`A += step*L`, etc.) instead of repeated multiplications.

## Running

```bash
python3 main.py
```

The program prints the required sum.
