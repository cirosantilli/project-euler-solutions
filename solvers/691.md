# Project Euler 691 Solution - Long Substring with Many Repetitions

<https://projecteuler.net/problem=691>:

* [691.py](691.py)

This repository contains a pure-Python solution (no third‑party libraries) for **Project Euler 691**.

## Key ideas

### 1) Generating the string `S_n`
The problem defines three 0/1 sequences:

- **Thue–Morse**: `a_n` is defined by  
  `a_0 = 0`, `a_{2n} = a_n`, `a_{2n+1} = 1 - a_n`,  
  which is equivalent to `a_n = popcount(n) mod 2`.

- **Beatty / Wythoff**:  
  `b_n = floor((n+1)/φ) - floor(n/φ)` (always 0 or 1).  
  Floating-point accumulation can drift for large `n`, so the code generates
  `b_n` with **fixed-point integer arithmetic**:

  - precompute `invφ = (sqrt(5) - 1) / 2` scaled by `2^k`
  - maintain an integer accumulator `acc += invφ_scaled`
  - obtain `floor(t/φ)` as `acc >> k`
  - set `b_n` as the increment of that floor between steps

- **XOR merge**:  
  `c_n = a_n + b_n - 2 a_n b_n`, which is exactly `c_n = a_n XOR b_n`.

The string `S_n` is then `c_0 c_1 ... c_{n-1}` over the binary alphabet.

### 2) Long repeated substrings via a Suffix Automaton (SAM)
A suffix automaton compactly represents *all* substrings of a string.

For each SAM state we maintain:

- `maxlen[state]`: the length of the longest substring represented by the state
- `link[state]`: suffix link
- `occ[state]`: number of occurrences of substrings represented by the state  
  (computed as the size of the state’s end-position set)

Because the alphabet is binary, transitions are stored in two integer arrays.

### 3) Turning occurrences into `L(k, S)`
For any `k ≥ 1`:

> `L(k, S)` = the maximum substring length that occurs at least `k` times.

In a SAM, every substring with at least `k` occurrences belongs to some state with
`occ ≥ k`, and its length is at most that state’s `maxlen`. Therefore:

> `L(k, S) = max( maxlen[state] )` over all states with `occ[state] ≥ k`.

We compute:
1. `best[t] = max maxlen` among states with exactly `t` occurrences
2. Convert to “at least” using a suffix maximum:
   `best[k] = max(best[k], best[k+1])` for `k = n-1 .. 1`
3. Sum the non-zero `best[k]`.

### 4) Computing `occ[state]` efficiently
Occurrence counts are propagated from longer states to their suffix links.
We need states in decreasing `maxlen` order, which is obtained with a counting sort
over `maxlen` (since `maxlen ≤ n`).

## Complexity
- Time: **O(n)**
- Memory: **O(n)** (arrays for the automaton + counting/summarization arrays)

The provided asserts match the example values given in the problem statement.
