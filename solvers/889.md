# Project Euler 889 Solution - Rational Blancmange

<https://projecteuler.net/problem=889>:

* [889.py](889.py)

This solution computes

\[
F(k,t,r)=(2^{2k}-1)\,T\!\left(\frac{(2^t+1)^r}{2^k+1}\right)
\]

modulo **1,000,062,031**, for the large input in the problem statement.

## Key techniques

### 1) Periodicity from the special denominator
Let \(Q=2^k+1\) and \(x=N/Q\). Using the definition

\[
T(x)=\sum_{n\ge 0}\frac{s(2^n x)}{2^n},\qquad s(y)=\text{distance of }y\text{ to the nearest integer},
\]

the crucial observation is:

- \(2^k\equiv -1\pmod Q\), so \(2^{n+k}x\equiv -2^n x\pmod 1\).
- Since \(s(-y)=s(y)\), we get a **period** \(s(2^{n+k}x)=s(2^n x)\).

This turns the infinite series into a geometric sum and yields the exact finite identity:

\[
F(k,t,r)=\sum_{j=0}^{k-1} d_j\,2^{k-j},
\]

where \(d_j=\min(m_j, Q-m_j)\) and \(m_j\equiv 2^j N\pmod Q\).

### 2) One-wrap reduction when \(k\) is much larger than \(N\)
For the required instance, \(N=(2^t+1)^r\) has highest bit around \(t\cdot r\), and **\(k\gg t\cdot r\)**.
That means when shifting \(N\) by \(2^j\) with \(0\le j<k\), the bits cross the \(2^k\) boundary at most once.

Writing \(2^j N = B + 2^k C\) (low/high parts), modulo \(Q\) this becomes

\[
2^jN \equiv B - C \pmod Q
\]

thanks to \(2^k\equiv -1\pmod Q\). This is the algebraic reason the computation can be reduced to bookkeeping on which bits have wrapped.

### 3) Sparse numerator via binomial expansion
For large \(t\) and modest \(r\), the binomial expansion

\[
(2^t+1)^r=\sum_{u=0}^r \binom{r}{u}\,2^{tu}
\]

is **sparse in binary** because each coefficient \(\binom{r}{u}\) fits inside a \(t\)-bit window (no carries between blocks). So the set bits of \(N\) can be listed as positions \(tu+b\), where \(b\) ranges over the set bits of \(\binom{r}{u}\).

### 4) Swapping sums: count contributions per bit
After scaling each term by \(2^{k-j}\), a single set bit at position \(p\) contributes:

- \(+2^{k+p}\) for each \(j<k-p\) (not wrapped), and
- \(-2^{p}\) for each \(j\ge k-p\) (wrapped).

So the “base” part of the answer is a simple count:

\[
\sum_{p\in\text{bits}(N)}\Big((k-p)2^{k+p}-p2^p\Big).
\]

### 5) A small correction set
The only time \(d_j\) is not just \(B-C\) is when the shifted value exceeds \(Q/2\), which happens **only when a bit lands exactly on the top position** \(k-1\).
There is one such shift per set bit (except the very lowest bit), so only a few thousand corrections are needed.
The code computes these corrections efficiently using prefix sums over the sorted bit positions.

## Structure of `main.py`

- A small **brute** routine is used for the statement’s example assertions.
- The main solver uses the sparse bit-position generation + counted contributions + prefix-sum corrections.

Run:

```bash
python3 main.py
```

It prints the required result modulo **1,000,062,031**.
