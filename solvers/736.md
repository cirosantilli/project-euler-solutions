# Project Euler 736 Solution - Paths to Equality

<https://projecteuler.net/problem=736>:

* [736.py](736.py)

We work on lattice points with:

- `r(x,y) = (x+1, 2y)`
- `s(x,y) = (2x, y+1)`

A **path to equality** starts at `(45,90)`, applies only `r`/`s`, never visits a point with `x=y` except at the end, and finishes at `(v,v)`.

The task is to find the **unique** path with **smallest odd length** (odd number of visited points), and output `v`.

## Main techniques used

### 1) Reverse the process

Instead of searching forward (which grows explosively), reverse the moves from the unknown equality point `(v,v)`:

- Reverse of `r` (call it `R`): `(x,y) -> (x-1, y/2)` (requires `y` even)
- Reverse of `s` (call it `S`): `(x,y) -> (x/2, y-1)` (requires `x` even)

A forward path exists iff a reverse path exists using the inverse operations in reverse order.

### 2) Encode a reverse path by “column counts”

In reverse, count how many `S` moves have already occurred. Call that column index `j`.

While you are in a given column `j`, you may do some number of `R` moves, then (except in the last column) exactly one `S` move to advance to column `j+1`.

So any reverse path is uniquely described by non‑negative integers:

- `c_j =` number of `R` moves taken in column `j`, for `j = 0..p`
- Total `R` moves: `q = sum(c_j)`
- Total `S` moves: `p` (one `S` after each of columns `0..p-1`)

This yields a deterministic reverse operation sequence:
`R` repeated `c_0`, then `S`, then `R` repeated `c_1`, then `S`, …, finally `R` repeated `c_p`.

### 3) Turn equality into a power‑of‑two identity

With `p` reverse-`S` moves and `q` reverse-`R` moves, the final value `v` satisfies two expressions:

- From ending at `x=45` after reversing: `v = 45·2^p + sum_j c_j·2^j`
- From ending at `y=90` after reversing: `v = 90·2^q + sum_{j=0..p-1} 2^{P_j}`  
  where `P_j = c_0 + … + c_j` is the prefix sum up to column `j`.

So we need:
`45·2^p + sum_j c_j·2^j = 90·2^q + sum_{j=0..p-1} 2^{P_j}`.

All terms are powers of two, so the constraint is very rigid.

### 4) A bounding argument for small even step counts

The smallest odd length means the smallest **even** number of steps `k`.
For `k < 96`, a size comparison shows you must have `p=q=t` (same number of `r` and `s` steps), hence `k=2t`.

So we only check `t = 45, 46, 47, …` until the first solution appears.

### 5) Reduce the search to a tiny combinatorial enumeration

With `p=q=t` and `(45,90)` where `90 = 2·45`, the leading `2^t` contribution forces almost all `R` moves into the last column, leaving only:

- `s = t - 45` “early” `R` moves to place in columns `0..t-1`.

Let the early `R` moves be a multiset of column indices. For each candidate multiset we can compute the two sides of the reduced identity in **O(t)** and check equality.

The first `t` that works is the minimal solution, and the multiset is unique at that `t`, giving a unique minimal odd-length path.

### 6) Reconstruct and verify the forward path

Once the reverse operation list is known, we:

1. Reverse it and swap `R -> r`, `S -> s` to get the forward path
2. Forward-simulate from `(45,90)`
3. Verify:
   - all intermediate points have `x != y`
   - the last point has `x == y`

The program prints the final `v`.

## Built-in sample checks

`main.py` includes assertions for the sample from the statement:

- the provided path has length 10 and ends at `(1476,1476)`
- no path of length ≤ 9 exists (checked by brute force for ≤ 8 steps)

Run:

```bash
python3 main.py
```

It prints the required final value.
