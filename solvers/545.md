# Project Euler 545 Solution - Faulhaber's Formulas

<https://projecteuler.net/problem=545>:

* [545.py](545.py)

## Core math idea

Let:

\[
S_k(n)=\sum_{i=1}^{n} i^k
\]

Faulhaber’s theorem says \(S_k(n)\) is a polynomial in \(n\). The problem defines \(D(k)\) as the denominator of the *linear* coefficient \(a_1\) (in lowest terms).

A key identity connects the linear coefficient to Bernoulli numbers:

- \(a_1 = (-1)^k B_k\)

So \(D(k)\) is the denominator of \(B_k\).

Now use **Von Staudt–Clausen**:

- For even \(k\):

\[
\mathrm{denom}(B_k)=\prod_{\substack{p\ \text{prime}\\ (p-1)\mid k}} p
\]

- For odd \(k>1\): \(B_k=0\Rightarrow D(k)=1\)

This turns the task into a pure divisibility / prime-product problem.

## Reducing the search

We want \(D(k)=20010\).

Factor:

- \(20010 = 2\cdot 3\cdot 5\cdot 23\cdot 29\)

To *force* these primes to appear, we need \((p-1)\mid k\) for each of them, so:

- \(k\) must be a multiple of

\[
L = \mathrm{lcm}(1,2,4,22,28)=308
\]

Write \(k = L\cdot n\).  
Then we must ensure **no other prime** \(p\notin\{2,3,5,23,29\}\) satisfies \((p-1)\mid k\).

## Sieve strategy (the main trick)

An “extra” prime \(p\) appears iff \((p-1)\mid L\cdot n\).

For each divisor \(g\mid L\), consider primes of the form:

- \(p = g\cdot m + 1\)

If \(p\) is prime, then \((p-1)=g\cdot m\). Because \(g\mid L\), we can check when \(g\cdot m\mid L\cdot n\):

Let \(L=g\cdot b\). Then:

\[
g m \mid g b n \iff m \mid b n \iff \frac{m}{\gcd(m,b)}\mid n
\]

So each prime \(p=g m + 1\) forbids all \(n\) that are multiples of:

\[
f = \frac{m}{\gcd(m, L/g)}
\]

### Implementation details

- Choose a safe bound \(N\) for \(n\) (here \(4{,}000{,}000\) is enough).
- Maintain a `bytearray invalid[n]`.
- For each \(g\mid L\):
  - Sieve the arithmetic progression \(p=g m + 1\) for \(1\le m\le N\) to find which \(p\) are prime.
  - For each such prime \(p\notin\{2,3,5,23,29\}\), compute \(f\) and mark multiples of \(f\) as invalid.

After this sieve, the remaining `n` values correspond exactly to \(k=L n\) with \(D(k)=20010\).  
We then scan to the 100000-th valid \(n\).

## Why this is fast

- We **never** compute Bernoulli numbers or Faulhaber polynomials.
- We avoid sieving all primes up to \(L\cdot N\) directly; instead we sieve only **12 arithmetic progressions** (divisors of 308).
- Marking invalid `n` values is done with efficient strided slice assignment on `bytearray`.

On a typical machine this runs in seconds in pure Python.
