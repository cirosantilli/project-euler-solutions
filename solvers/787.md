# Project Euler 787 Solution - Bézout's Game

<https://projecteuler.net/problem=787>:

* [787.py](787.py)

This solution uses **game theory + Stern–Brocot structure + analytic counting**.

---

## 1) Game analysis → a simple losing rule

A move from `(a,b)` removes `(c,d)` such that:

\[
ad - bc = \pm 1
\]

Because `gcd(a,b)=1`, solutions exist, and the move always transforms `(a,b)` into one of its **two Stern–Brocot parents**.  
So the game is a finite directed acyclic graph: each state has two parent-states (except near the boundary).

Computing Grundy numbers for small states reveals:

- If `a+b` is **even**, the position is **always winning**.
- If `a+b` is **odd**, the position is **losing iff** the **smaller** pile is **even**.

Equivalently:

> For coprime `(a,b)` with `a+b` odd, the position is losing **exactly when the even number is the smaller of the two**.

So all complexity collapses to counting lattice points with parity constraints.

---

## 2) Counting winning positions

Let:

- \(S(N)\) = number of coprime ordered pairs `(a,b)` with `a+b ≤ N`.
- \(L(N)\) = number of losing ordered pairs with `a+b ≤ N`.

Then:

\[
H(N)=S(N)-L(N)
\]

### 2.1 Total coprime pairs
For each sum `s`, the number of coprime ordered pairs with `a+b=s` equals `φ(s)`, so:

\[
S(N)=\sum_{s=2}^{N}\varphi(s)
\]

We compute the summatory totient efficiently using a **Du Jiao sieve**:

\[
\Phi(n)=\sum_{k\le n}\varphi(k)
\]

---

## 3) Counting losing states with Möbius inversion

Losing states occur only when `a+b` is odd and `min(a,b)` is even.

Write the unordered losing pairs as:

- even pile: `e = 2x`
- odd pile:  `o = y` (odd)

Conditions become:

- `2x < y`
- `2x + y ≤ N`
- `gcd(2x,y)=1` ⇔ `gcd(x,y)=1` (because `y` is odd)

So we count coprime pairs `(x,y)` in a triangle-like region where `y` must be odd.

### 3.1 Region counting
Define \(C(M)\) as the count of integer pairs:

- `x ≥ 1`
- `y ≥ 1` odd
- `2x < y`
- `2x + y ≤ M`

This admits a closed form:

Let:

\[
t = \left\lfloor \frac{M-1}{4}\right\rfloor
\]

Then:

\[
C(M) = t\left\lfloor\frac{M+1}{2}\right\rfloor - t(t+1)
\]

### 3.2 Möbius inversion to enforce gcd=1
Using Möbius inversion:

\[
L_u(N)=\sum_{\substack{d\le N \\ d\text{ odd}}}\mu(d)\,C\!\left(\left\lfloor\frac{N}{d}\right\rfloor\right)
\]

Ordered losing count is double (swap piles gives a distinct ordered pair):

\[
L(N)=2L_u(N)
\]

---

## 4) Fast summatory μ on odd integers

The sum above needs prefix sums of μ over odd numbers.

Let:

- \(M(n)=\sum_{k\le n}\mu(k)\)
- \(M_{\text{odd}}(n)=\sum_{k\le n,\,k\text{ odd}}\mu(k)\)

Identity:

\[
M(n)=M_{\text{odd}}(n)-M_{\text{odd}}\!\left(\left\lfloor\frac n2\right\rfloor\right)
\Rightarrow
M_{\text{odd}}(n)=M(n)+M_{\text{odd}}\!\left(\left\lfloor\frac n2\right\rfloor\right)
\]

So we compute `M(n)` via Du Jiao sieve and derive odd-only prefix sums with memoization.

---

## 5) Complexity

For \(N=10^9\):

- Pre-sieve up to \(N^{2/3} \approx 10^6\).
- Du Jiao recursion handles large values using floor-division grouping.
- The Möbius sum is evaluated in \(O(\sqrt N)\) blocks.

This is efficient enough in pure Python without external dependencies.

---

## 6) Validation

The code asserts the given test values:

- `H(4) = 5`
- `H(100) = 2043`

Then prints `H(10^9)`.
