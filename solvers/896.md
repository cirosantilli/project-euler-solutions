# Project Euler 896 Solution - Divisible Ranges

<https://projecteuler.net/problem=896>:

* [896.py](896.py)

This repository contains a pure-Python solution (no external libraries) for **Project Euler 896**.

## Core reformulation

For a fixed length `L`, a range `[a..a+L-1]` is *divisible* iff there exists a permutation of its numbers such that:

- the `n`-th term is divisible by `n` for all `n = 1..L`.

This is naturally a **perfect matching** problem in a bipartite graph:

- Left side: indices `i = 1..L`
- Right side: offsets `j = 0..L-1` representing the number `a+j`
- Edge `(i, j)` exists when `(a+j) % i == 0`

A valid permutation exists exactly when this graph has a matching of size `L`.

A crucial observation is that divisibility only depends on `a` **modulo `lcm(1..L)`**, so valid starts repeat periodically.

## Enumerating valid starts via congruences

Instead of scanning `a` (which becomes infeasible), the solver enumerates all valid **residues**:

- Choosing offset `j` for index `i` forces the congruence  
  `a ≡ -j (mod i)`.

A full permutation corresponds to selecting one distinct offset for each `i = 1..L` such that all these congruences are consistent.

This becomes a constraint search:

- State includes the current congruence `a ≡ r (mod m)` and which offsets/indices are still unused.
- Adding an assignment merges congruences using the **Chinese Remainder Theorem** (works for non-coprime moduli too).

## Performance techniques

The search is made fast with:

- **Bitmasks** for unused offsets and remaining indices (36 fits comfortably in an integer).
- **Memoization** of explored states `(r mod m, m, offsets_mask, indices_mask)` to avoid repeated work.
- A **minimum-remaining-values (MRV)** heuristic:
  - at each step, pick the index `i` that currently has the fewest feasible offsets
  - tie-break toward larger `i` (this quickly increases the modulus and tightens constraints)

These choices keep the explored state space small enough to fully enumerate all valid residues for `L = 36`, after which the starts are just:

- `start = residue` (or `lcm(1..L)` if the residue is `0`)
- sort all starts and pick the 36th.

## Correctness checks

The program includes assertions for the sample facts from the problem statement for `L = 4`:

- the first three starts are `1, 2, 3`
- the 4th start is `6`
- `[6..9]` is divisible
