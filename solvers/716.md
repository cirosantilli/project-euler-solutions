# Project Euler 716 Solution - Grid Graphs

<https://projecteuler.net/problem=716>:

* [716.py](716.py)

## Key ideas used

### 1) Work with the *sum over all orientations*, not individual graphs
Each graph is defined by choosing directions for:

- `H` horizontal “street” lines (each row is all left-to-right or all right-to-left)
- `W` vertical “street” lines (each column is all top-to-bottom or all bottom-to-top)

So there are `2^(H+W)` graphs. Directly computing SCCs for each graph is impossible at the target sizes.

### 2) Closed form via low-dimensional recurrence and symmetry
When you vary `W` while keeping `H` fixed, the aggregated count `C(H,W)` turns out to lie in the span of:

- `2^W`
- `W·2^W`
- `1`
- `W`

That is, for each fixed `H` the function is *affine* in `2^W` and in `W`, which means only a constant number of coefficients must be determined.

Using:
- symmetry `C(H,W) = C(W,H)`,
- boundary cases like `C(H,1) = 2^(H+1)·H`,
- and a few small fixed-width instances,

the coefficients can be solved exactly, giving a compact symmetric formula:

\[
\begin{aligned}
C(H,W)=\;&9\cdot 2^{H+W}
+2HW\,(2^H+2^W+1)\\
&-8\,(W2^H+H2^W)
-10\,(2^H+2^W)
+10\,(H+W+1).
\end{aligned}
\]

### 3) Modular arithmetic and fast exponentiation
All we need are `2^H (mod M)` and `2^W (mod M)`, computed with Python’s built-in modular exponentiation:

- `pow(2, H, M)`
- `pow(2, W, M)`

Then evaluate the formula modulo `M = 1_000_000_007`.

## Complexity
- Time: `O(log M)` (dominated by modular exponentiation)
- Memory: `O(1)`

## What’s in `main.py`
- A `C_mod(H,W)` function implementing the formula modulo `1_000_000_007`.
- `assert`s for the three check values from the problem statement.
- Prints the required value for `H=10000, W=20000` (or custom `H W` from the command line).
