# Project Euler 850 Solution - Fractions of Powers

<https://projecteuler.net/problem=850>:

* [850.py](850.py)

This repository contains a standalone Python solution (standard library only) for Project Euler 850.

It prints:

\[
\lfloor S(33557799775533)\rfloor \bmod 977676779
\]

where

\[
f_k(n)=\sum_{i=1}^{n}\left\{\frac{i^k}{n}\right\},\qquad
S(N)=\sum_{\substack{1\le k\le N\\ k\ \text{odd}}}\ \sum_{n=1}^{N} f_k(n).
\]

The code avoids floats by working with **twice** the quantities (so half-integers become integers).

---

## 1) Odd-\(k\) pairing gives a closed form

For odd \(k\),

\[
(n-i)^k \equiv -i^k\pmod n.
\]

So the residues \(i^k \bmod n\) pair to sum to \(n\), except when the residue is \(0\).
Let

\[
m(n,k)=\prod_{p^e\|\|n} p^{\lceil e/k\rceil}
\]

(the smallest integer whose \(k\)-th power is divisible by \(n\)),
and define \(h_k(n)=n/m(n,k)\). Then for odd \(k\):

\[
2f_k(n)=n-h_k(n).
\]

Hence:

\[
2S(N)=\sum_{\substack{k\le N\\k\ \text{odd}}}\ \sum_{n\le N} \bigl(n-h_k(n)\bigr).
\]

---

## 2) Work modulo \(2M\), then divide by 2

Let \(M=977676779\). Since \(2S(N)\) is an integer, computing

\[
T \equiv 2S(N)\pmod{2M}
\]

preserves the parity (which encodes the “.0 vs .5”),
and

\[
\lfloor S(N)\rfloor \bmod M = \left\lfloor \frac{T}{2}\right\rfloor \bmod M.
\]

So the program computes \(2S(N)\) modulo \(2M\) and finally takes integer division by 2.

---

## 3) Collapse the huge \(k\)-range

For any \(n\le N\), the largest prime exponent in its factorization is at most \(\lfloor\log_2 N\rfloor\).
If odd \(k\) is larger than that exponent, then \(\lceil e/k\rceil=1\) for all \(e\ge 1\), hence

\[
h_k(n)=\prod_{p^e\|\|n} p^{e-1} = \frac{n}{\operatorname{rad}(n)}.
\]

Therefore, for all sufficiently large odd \(k\), the inner sum \(\sum_{n\le N} h_k(n)\) is **constant**.
The solver computes a short list of “small” odd \(k\) explicitly and one shared value for the long tail.

---

## 4) Only the powerful part matters for \(k\ge 3\)

For \(k\ge 3\), any prime appearing with exponent 1 in \(n\) contributes nothing to \(h_k(n)\).
So \(h_k(n)\) depends only on the **powerful (squareful) part** \(P\) of \(n\) (all exponents \(\ge 2\)).

Every \(n\) has a unique decomposition

- \(n = P\cdot u\)
- \(P\) powerful
- \(u\) squarefree
- \(\gcd(u,\operatorname{rad}(P))=1\)

and

\[
h_k(n)=h_k(P)\quad (k\ge 3).
\]

So:

\[
\sum_{n\le N} h_k(n)
=
\sum_{P\le N\atop P\ \text{powerful}}
h_k(P)\cdot
\#\{u\le N/P:\ u\ \text{squarefree},\ (u,\operatorname{rad}(P))=1\}.
\]

Powerful numbers are enumerated by DFS over prime powers \(p^e\) with \(e\ge 2\).

---

## 5) Counting squarefree numbers and the coprime constraint

Let \(Q(x)\) be the number of squarefree integers \(\le x\).
Using the Möbius function \(\mu\):

\[
Q(x)=\sum_{d\le\sqrt{x}} \mu(d)\left\lfloor\frac{x}{d^2}\right\rfloor,
\]

and the sum is accelerated by grouping ranges where \(\left\lfloor x/d^2\right\rfloor\) is constant.
Values are cached because many arguments repeat.

### The subtle part: enforcing \(\gcd(u,R)=1\) *within* squarefree numbers

A naive inclusion–exclusion like \(Q(x)-Q(\lfloor x/p\rfloor)\) is **wrong** for squarefree numbers,
because \(Q(x/p)\) includes numbers still divisible by \(p\), which would correspond to \(p^2\).

A correct filter for a single forbidden prime \(p\) is:

\[
\#\{u\le x:\ u\ \text{squarefree},\ p\nmid u\}
=
\sum_{j\ge 0} (-1)^j\,Q\!\left(\left\lfloor\frac{x}{p^j}\right\rfloor\right).
\]

For multiple primes \(p_1,\dots,p_m\), these filters multiply, giving a finite alternating sum over
products of prime powers \(d=\prod p_i^{e_i}\) (with \(e_i\ge 0\)):

\[
\sum_{e_1,\dots,e_m\ge 0} (-1)^{e_1+\cdots+e_m}\,
Q\!\left(\left\lfloor\frac{x}{p_1^{e_1}\cdots p_m^{e_m}}\right\rfloor\right),
\]

which truncates when the denominator exceeds \(x\).
The code implements this with a small DFS over exponents.

---

## 6) Constant-suffix optimization over \(k\)

For a fixed powerful \(P\), once \(k\ge \max_p v_p(P)\), we have \(h_k(P)=P/\operatorname{rad}(P)\).
So over the small-\(k\) list, many \(k\) share the same value and can be updated using a difference array
(range add on a suffix), avoiding per-\(k\) work for most \(P\).

---

## Files

- `main.py` — solver with asserts for the statement’s test values.
- `README.md` — this explanation.
