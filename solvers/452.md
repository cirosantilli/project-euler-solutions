# Project Euler 452 Solution - Long Products

<https://projecteuler.net/problem=452>:

* [452.py](452.py)

We want the number of `N`-tuples of positive integers whose product is at most `N`,
reported modulo **1234567891**.

## 1) Turn the problem into a summatory multiplicative function

Let `g(m, n)` be the number of `n`-tuples `(a1..an)` with product exactly `m`.

If `m = ∏ p^e` is the prime factorization, then each exponent `e` can be distributed
among `n` slots independently (stars and bars), giving:

- `g(p^e, n) = C(n + e - 1, e)`
- `g(m, n) = ∏ C(n + e - 1, e)` (multiplicative over distinct primes)

The required count of tuples with product `≤ N` is:

`F(N, n) = ∑_{m=1..N} g(m, n)`

For this problem `n = N`, so the task becomes:

`Answer = ∑_{m ≤ N} ∏_{p^e || m} C(N + e - 1, e)  (mod MOD)`

## 2) Use the “exponent only” structure

For `N = 10^9`, the largest possible exponent is:

`e ≤ floor(log2 N) = 29`

So we precompute the small table:

`w[e] = C(N + e - 1, e) (mod MOD)`

and every prime power contributes `w[e]`. The prime itself only determines *which*
factor is used, not its value.

## 3) Recursion over prime powers + counting the tail with π(x)

We sum the multiplicative function by recursively choosing prime powers in increasing
prime order:

- pick a prime `p`
- pick an exponent `e ≥ 1` while `p^e ≤ limit`
- recurse on `limit // p^e` with the next primes

A crucial shortcut:

If the next prime `p0` satisfies `p0^2 > limit`, then any remaining number can only be:
- `1`, or
- a single prime in `[p0 .. limit]` (only exponent `1` is possible)

So the remaining contribution is:

`1 + (π(limit) - π(p0 - 1)) * w[1]`

This replaces a huge amount of work by a single prime-count query.

## 4) Fast prime counting (Lehmer π)

To support `π(x)` quickly up to `10^9`, the solution implements the Lehmer prime
counting algorithm, backed by:

- a sieve up to `10^6`
- a cached `phi(x, a)` helper (count of integers ≤ x not divisible by the first `a` primes)

This is fast enough for the recursion to run in seconds in CPython.

## 5) Memoization

The recursion is cached on `(limit, prime_index)`; many subproblems repeat due to
integer division shrinking the limit.

## 6) Built-in checks

The program asserts the known test values:

- `F(10, 10) = 571`
- `F(10^6, 10^6) mod 1234567891 = 252903833`

The final value for `N = 10^9` is **printed**, and not stored as a constant.
