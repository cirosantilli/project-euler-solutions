# Project Euler 911 Solution - Khinchin Exceptions

<https://projecteuler.net/problem=911>:

* [911.py](911.py)

This solution computes
\(k_\infty(\rho_n)\) for \(0 \le n \le 50\), where

\[
\rho_n = \sum_{i=0}^{\infty} \frac{2^n}{2^{2^i}} = 2^n\,B(2,\infty),
\qquad
B(2,\infty)=\sum_{i=0}^{\infty} \frac{1}{2^{2^i}}.
\]

For an irrational \(x=[a_0; a_1,a_2,\dots]\), define
\(k_j(x)=(a_1a_2\cdots a_j)^{1/j}\) and
\(k_\infty(x)=\lim_{j\to\infty} k_j(x)\).

The key is to avoid *directly* expanding the continued fractions to huge length.

## Main techniques

### 1) Shallit’s explicit continued-fraction recurrences

Jeffrey Shallit (JNT 1979, *Simple Continued Fractions for Some Irrational Numbers*)
proved exact recurrences for the continued fractions of the *finite truncations*

- \(B(u,v)=\sum_{k=0}^{v} u^{-2^k}\) (Theorem 1), and
- \(u^t B(u,v)\) (Theorem 11).

For our problem \(u=2\) and \(t=n\), so \(\rho_n = 2^n B(2,\infty)\).

The recurrences have a “mirror” structure: from the continued fraction of a truncation
at depth \(v\), the continued fraction at depth \(v+1\) is obtained by appending a short
fixed pattern and then a reversed copy of (most of) the previous coefficients.
This approximately *doubles* the available prefix length each step.

### 2) Handling the \(u=2\) “zero digit” issue

Shallit notes that for \(u=2\) some intermediate partial denominators can become 0.
A standard continued-fraction identity removes them:

\[
[\dots, x, 0, y, \dots] = [\dots, x+y, \dots].
\]

For \(n\ge 1\) the only possible 0 comes from the local \((a_n-1)\) term when the
last partial denominator equals 1, so it can be fixed with a small conditional.

For \(n=0\) we also need to keep each *finite truncation* in canonical continued-
fraction form (no trailing `... , 1`) because rationals have two equivalent
representations.

### 3) Computing \(k_\infty\) via average \(\log a_i\), not products

Instead of multiplying partial denominators (which would overflow immediately), we use

\[
\ln k_j(x) = \frac{1}{j}\sum_{i=1}^{j}\ln a_i.
\]

For \(n\ge 1\) Theorem 11’s mirror structure means we can update the **average log**
in \(O(1)\) time per step, because each step is essentially “two copies plus a few
extra terms”.

For \(n=0\) we compute the average log over two long prefixes and apply a simple
\(1/L\) extrapolation to remove the remaining boundary error.

Once the average log stabilizes, \(k_\infty(x)=\exp(\lim \text{average log})\).

### 4) Geometric mean across \(n=0\dots 50\)

The final quantity is the geometric mean of \(k_\infty(\rho_n)\).
Using logs again:

\[
\ln\Bigl(\text{GM}\Bigr)=\frac{1}{51}\sum_{n=0}^{50} \ln k_\infty(\rho_n).
\]

So the program computes \(\ln k_\infty(\rho_n)\) for each \(n\), averages, then exponentiates.

## Built-in checks

The code asserts two values stated in the problem:

- The continued fraction for \(\rho_2\) begins with \([3; 3,1,3,4,3,1,3,\dots]\).
- \(k_\infty(\rho_2)\) rounds to `2.059767` (6 decimals).
