# Project Euler 538 Solution - Maximum Quadrilaterals

<https://projecteuler.net/problem=538>:

* [538.py](538.py)

We have a growing multiset of side lengths `U_n = (u1, u2, …, un)` where

- `u_n = 2^{B(3n)} + 3^{B(2n)} + B(n+1)`
- `B(k)` is the number of 1-bits in the binary representation of `k` (`popcount`).

For each prefix `U_n`, define `f(U_n)` as the **perimeter** of the quadrilateral with **maximum possible area** that can be formed from **four distinct elements** of `U_n`. If multiple quadrilaterals have the same maximum area, choose the one with the **largest perimeter**.

We need:

\[
\sum_{n=4}^{3\,000\,000} f(U_n)
\]

## 1) Maximum area for fixed side lengths (cyclic quadrilateral)

For fixed side lengths `(a,b,c,d)`, the maximum possible area is achieved by a **cyclic quadrilateral**, and its area is given by Brahmagupta’s formula:

\[
A^2 = (s-a)(s-b)(s-c)(s-d),\quad s = \frac{a+b+c+d}{2}
\]

A quadrilateral with these sides exists iff the longest side is smaller than the sum of the other three:

\[
\max(a,b,c,d) < a+b+c+d - \max(a,b,c,d)
\quad\Longleftrightarrow\quad
d < a+b+c
\]
(assuming `a ≤ b ≤ c ≤ d`)

To avoid floating point and square roots, we compare areas via an integer proportional to `A^2`:

\[
16A^2 = (P-2a)(P-2b)(P-2c)(P-2d),\quad P=a+b+c+d
\]

So we maximize:

- `prod = (P-2a)(P-2b)(P-2c)(P-2d)` (equivalently `A^2`),
- and on ties maximize `P`.

## 2) Key structural lemma: only consecutive quadruples matter

Let all available side lengths be sorted into a nondecreasing list (with multiplicity). Empirically and in standard “max area from sticks” arguments, an optimal maximum-area quadruple can always be chosen as **four consecutive elements** in this sorted list.

Intuition (proof sketch):

- The cyclic-area expression prefers *balanced* side lengths (it is maximized when the `(s-a)` factors are balanced).
- If a chosen set has a “gap” (you skipped an available length between two chosen lengths), replacing the smaller chosen side with that intermediate value makes the set more balanced and (for feasible quadruples) does not decrease the area.
- Repeating this “gap tightening” yields an optimal quadruple that is consecutive in the global sorted order.

This lemma is what makes the incremental update fast.

## 3) Incremental update: only check windows containing the new element

When we append one new value to the multiset, the previous best quadrilateral remains available, so the best area/perimeter can only improve if the new optimum **uses the new element**.

Because the optimum is consecutive in sorted order, a new optimum must be one of the at most **4 length‑4 windows** that contain the newly inserted element (start positions `p-3 … p`).

Therefore, per `n` we only need:

- the new element,
- up to **3 predecessors** and **3 successors** around it in sorted order,
- evaluate up to 4 candidate quadruples.

## 4) Efficient multiset maintenance with few distinct values

Even though `n` is large, `u_n` depends only on a few popcounts, so the number of **distinct** values is small (≲ 25³). The solution uses:

- coordinate compression of all `u_n` values,
- an array `counts[value_index]` for multiplicities,
- a sorted list `active` of indices with nonzero counts.

Finding up to 3 predecessors/successors becomes a short walk in `active`.

## 5) Popcount-based generation

`B(2n) = B(n)` because shifting left adds a zero bit. We precompute `3^k` for `k ≤ 24`, and use Python’s fast `int.bit_count()` for popcounts.

## Complexity

- Time: `O(N log M)` for maintaining the active list, with `M ≈ 10–15k` distinct values, plus constant work per step (≤ 4 candidate checks).
- Memory: stores all `u_n` for `n ≤ 3,000,000` (a few dozen MB) plus small auxiliary structures.

## Output

Running `main.py` prints the required sum for `N = 3,000,000` and also asserts all sample values from the problem statement.
