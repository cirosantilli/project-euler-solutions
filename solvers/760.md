# Project Euler 760 Solution - Sum over Bitwise Operators

<https://projecteuler.net/problem=760>:

* [760.py](760.py)

## Key simplification
For each bit position, `(m xor n) + (m and n) = (m or n)` because for a single bit:

- `xor` contributes `1` exactly when the bits differ
- `and` contributes `1` exactly when both bits are `1`
- together they contribute `1` exactly when at least one bit is `1`, i.e. `or`

So:

\[
g(m,n) = (m\oplus n) + (m\vee n) + (m\wedge n) = 2\,(m\vee n).
\]

Therefore `G(N)` is twice the sum of bitwise OR over all pairs `(a,b)` with `a+b ≤ N`.

## Re-indexing the double sum
The original definition enumerates `(k, n-k)` for every `n ≤ N`, which is exactly the set of all non-negative pairs:

\[
(a,b)\ \text{with}\ a\ge 0,\ b\ge 0,\ a+b \le N.
\]

This turns the problem into summing `a | b` over a triangular region of lattice points.

## Bit decomposition
Use linearity over bits:

\[
\sum (a\vee b) = \sum_{i\ge 0} 2^i \cdot \#\{(a,b): (a\vee b)_i = 1\}.
\]

For a fixed bit `i`, the OR bit is `0` **only** when **both** `a_i=0` and `b_i=0`, so:

\[
\#\{(a,b): (a\vee b)_i = 1\} = T - Z_i
\]

where `T` is the total number of pairs with `a+b ≤ N`, and `Z_i` counts pairs with `a_i=b_i=0`.

`T` has a closed form:

\[
T = \frac{(N+1)(N+2)}{2}.
\]

## Counting `Z_i` with a reverse-carry digit DP
To count pairs satisfying `a+b ≤ N` (and optionally forcing a specific bit to be `0` in both numbers), we use a digit DP over the binary addition constraints.

Carry normally flows from low bits to high bits, so the DP processes bits **from MSB to LSB** while running the addition automaton **backwards**:

- state includes the carry *into the already-processed higher bit* (`carry_next`)
- at each bit, enumerate `(a_bit, b_bit, carry_current)` that produce `carry_next`
- update the next state to `carry_current` (moving downward)

A standard `less` flag enforces `a+b ≤ N` by comparing the constructed sum bits against `N` from MSB to LSB.

This yields `Z_i` in `O(B)` states per bit, where `B ≈ 60` for `N = 10^18`, so the whole solution runs in about `O(B^2)` operations.

## Modulo arithmetic
All counts and sums are accumulated modulo `1_000_000_007`. The division by `2` in `T` uses the modular inverse of `2`, which is `(MOD+1)//2` because the modulus is prime.
