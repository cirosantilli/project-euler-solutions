# Project Euler 908 Solution - Clock Sequence II

<https://projecteuler.net/problem=908>:

* [908.py](908.py)

This repository contains a pure-Python solution for Project Euler **908 (Clock Sequence II)**.

## Key ideas

### 1) Turning the segmentation rule into a prefix-sum condition
Let the periodic sequence be `a1, a2, ...` and let `A(t)=a1+...+at`.

If the sequence can be split into segments whose sums are `1,2,3,...`, then the segment endpoints
`e_n` satisfy:

- `A(e_n) = 1+2+...+n = n(n+1)/2` (triangular numbers)

So **every triangular number must appear as a prefix sum**.

### 2) Using periodicity modulo the period-sum
Let the (chosen) period length be `p` and the period block be `b1..bp`.
Let `m = b1+...+bp`.

Then `A(t+p) = A(t) + m`, so the set of prefix sums **modulo `m`** repeats with period `p`.
Inside one period the strict prefix sums are

- `0, s1, s2, ..., s_{p-1}` where `s_i = b1+...+bi` and `0 < s1 < ... < s_{p-1} < m`.

A triangular number `T` occurs as a prefix sum **iff** its residue `T mod m` is one of these
prefix residues. Therefore a block defines a clock sequence iff:

- `b1 = 1` (the first segment must sum to `1`, and all terms are positive)
- the set `{0, s1, ..., s_{p-1}}` contains **all triangular residues modulo `m`**.

Let `k(m)` be the number of distinct residues of `n(n+1)/2 (mod m)`.
Then the condition becomes `k(m) <= p`.

### 3) Counting blocks for fixed `(m,p)`
For a fixed `m`, the triangular residues form a fixed set of size `k(m)` and must be included
among the `p` prefix residues.

Inside `{1,2,...,m-1}` there are exactly `m-k(m)` positions **not** forced by the triangular
residue requirement, and we must choose `p-k(m)` of them.

So the number of period blocks of length `p` and sum `m` is:

- `binom(m-k(m), p-k(m))`.

Summing over all `m` with `k(m) <= p` gives `B(p)`: the number of clock sequences that admit
period `p` (not necessarily minimal).

### 4) Computing `k(m)` by prime powers
The function `k(m)` is multiplicative via CRT:

- if `gcd(m1,m2)=1` then `k(m1*m2) = k(m1) * k(m2)`.

So it suffices to know `k(p^e)`.

- For `2^e`, triangular numbers are a complete residue system, so `k(2^e)=2^e`.
- For odd primes `p`, `k(p^e)` follows a simple recurrence:

  - `k(p) = (p+1)/2`
  - for `e>=2`:

    - if `e` is even: `k(p^e) = p*k(p^{e-1}) - (p-1)`
    - if `e` is odd:  `k(p^e) = p*k(p^{e-1}) - (p-1)/2`

This is implemented directly and validated against brute force for small moduli.

### 5) Removing overcounting of non-minimal periods (Möbius inversion)
A sequence with **minimal** period `d` is also counted in `B(p)` for every multiple `p` of `d`.
Thus:

- `B(p) = sum_{d | p} A(d)`

where `A(d)` counts sequences with minimal period exactly `d`.
By Möbius inversion:

- `A(p) = sum_{d | p} mu(d) * B(p/d)`.

Finally:

- `C(N) = sum_{p<=N} A(p)`.

## Implementation outline

- Generate all moduli `m` with `k(m) <= 10^4` by DFS over prime powers.
- For each `(m,k(m))`, add the shifted binomial row `binom(m-k, r)` into `B[k+r]`.
- Compute Möbius `mu(1..N)` by a sieve.
- Apply the divisor-sum inversion to get `A(1..N)`, then prefix-sum to obtain `C(t)`.

The program asserts the sample values from the statement (`C(3)`, `C(4)`, `C(10)`) and prints
`C(10^4) mod 1111211113`.
