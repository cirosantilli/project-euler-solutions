# Project Euler 933 Solution - Paper Cutting

<https://projecteuler.net/problem=933>:

* [933.py](933.py)

## Game model

A position is a multiset of integer rectangles.  
A move chooses one rectangle of size `w×h` and makes **one vertical** and **one horizontal** cut, producing four smaller rectangles.  
Normal play: a player who cannot move loses.

This is an impartial game, so **Sprague–Grundy theory** applies.

---

## 1) Sprague–Grundy numbers (nimbers)

Let `G(w,h)` be the nimber of a single `w×h` rectangle (order doesn’t matter; `G(w,h)=G(h,w)`).

A move splitting at `(x,y)` (with `1≤x<w`, `1≤y<h`) produces rectangles:

- `x×y`
- `(w-x)×y`
- `x×(h-y)`
- `(w-x)×(h-y)`

The resulting game is the XOR-sum of those rectangles, so the move’s nimber is:

G(x,y) xor G(w-x,y) xor G(x,h-y) xor G(w-x,h-y)

makefile
Copy code

Thus:

G(w,h) = mex( { move_nimber over all valid cuts } )

perl
Copy code

We compute nimbers in increasing width, and for each width in increasing height.

To make `mex` fast, the implementation uses a stamping array (`visited[value]=stamp`) instead of clearing a boolean list each time.

---

## 2) Why nimbers become constant for fixed width

For fixed width `w`, the sequence `G(w,1), G(w,2), ...` eventually becomes constant.

Intuition: when the height is very large, every possible horizontal cut leaves at least one side “large enough” that all smaller-width rectangles in that side have already reached their stabilized nimber values. This makes the *set of reachable move nimbers* stop changing, so the `mex` stops changing too.

### Practical certification lemma

A useful rigorous check is:

> If `G(w,h)` is constant for all `h` in the interval `[s, 2s]`, then it stays constant for all `h ≥ s`.

Reason (sketch): when `h > 2s`, any horizontal split `(b, h-b)` has `max(b, h-b) ≥ s`, and for the smaller rectangles created by the move, nimbers match the already-stabilized values. So the set of reachable nimbers is the same as at height `2s`, therefore `mex` is identical.

The code finds the last index `s` where a change occurs, and extends the computed range until it can verify constancy over `[s, 2s]`. The constant value is stored as `const[w]`.

---

## 3) Counting `D(W,H)` without summing `C(w,h)` directly

A **first move** from a `w×h` rectangle is uniquely described by positive integers:

- `i` and `j` with `i+j = w` (left/right widths)
- `k` and `l` with `k+l = h` (top/bottom heights)

So summing all winning moves over all rectangles `w≤W`, `h≤H` is equivalent to counting **all quadruples**:

i,j,k,l ≥ 1
i+j ≤ W
k+l ≤ H

vbnet
Copy code

that satisfy the winning condition.

The XOR of the four rectangles after the cut is zero exactly when:

G(i,k) xor G(j,k) == G(i,l) xor G(j,l)

scss
Copy code

For fixed ordered `(i,j)`, define:

t(x) = G(i,x) xor G(j,x)

yaml
Copy code

Then for that `(i,j)`, we need the number of ordered `(k,l)` with `k+l≤H` and `t(k)=t(l)`.

Because `G(i,x)` becomes constant for large `x`, `t(x)` also becomes constant beyond a small threshold. This allows `k,l` counting to be done with:
- a histogram on the short “prefix” part, plus
- closed-form formulas for the large “tail” triangle.

This turns the huge `H=1,234,567` into a computation that mainly depends on the much smaller stabilization thresholds.

---

## 4) Complexity notes

- The Grundy table is computed only up to the heights needed to prove stabilization per width.
- Final `D(W,H)` is computed using per-width-pair histograms over the short prefix (typically a few thousand terms) and O(1) tail formulas.

No external libraries are required, and the program uses a single CPU core.

---

## Verification

The program asserts the values given in the statement:

- `C(5,3) = 4`
- `D(12,123) = 327398`

Then it prints `D(123,1234567)`.
