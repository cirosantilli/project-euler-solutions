# Project Euler 706 Solution - $3$-Like Numbers

<https://projecteuler.net/problem=706>:

* [706.py](706.py)

This solution counts **$d$-digit numbers** whose number of **non-empty substrings divisible by 3** is itself divisible by 3, and computes:

- `F(10^5) (mod 1_000_000_007)`

## Key techniques

### 1) Substrings divisible by 3 via prefix sums (mod 3)

A decimal substring is divisible by 3 iff its **digit sum** is divisible by 3.

Let `s_k` be the prefix digit-sum modulo 3 for the first `k` digits (with `s_0 = 0`).
Then the substring from `i` to `j` is divisible by 3 exactly when:

- `s_{i-1} == s_j (mod 3)`

So the number of divisible substrings is:

- `f = Σ_r C(count_r, 2)`

where `count_r` is how many prefix residues equal `r` among `s_0..s_d`.

### 2) Only `count_r (mod 3)` matters

We only need `f (mod 3)`.

Since `C(m, 2) = m(m-1)/2`, modulo 3 this depends only on `m (mod 3)`:
- `C(m,2) ≡ 1 (mod 3)` iff `m ≡ 2 (mod 3)`
- otherwise it is `0 (mod 3)`

Therefore `f (mod 3)` is simply the number of residues `r ∈ {0,1,2}` with `count_r ≡ 2 (mod 3)`, taken modulo 3.

So `f` is divisible by 3 iff:
- **none** of `count_0,count_1,count_2` are `2 (mod 3)`, or
- **all three** are `2 (mod 3)`

### 3) Small state DP as a weighted automaton

While scanning digits left-to-right, keep the state:

- `(count0 mod 3, count1 mod 3, count2 mod 3, current_prefix_mod)`

That’s `3^4 = 81` states.

Appending a digit with residue `r` (mod 3) moves:
- `next_prefix_mod = (current + r) mod 3`
- increment the corresponding `count_next` modulo 3

Digit choices become **weights** on transitions:
- first digit (1–9): residue weights are `(3,3,3)`
- other digits (0–9): residue weights are `(4,3,3)`

### 4) Matrix exponentiation for `d = 100000`

The per-digit DP is a fixed linear transition on an 81-dimensional vector, so we exponentiate the transition matrix:

- `v_final = (T_step)^(d-1) * (T_lead * v_start)`

Time complexity is about `O(81^3 log d)`, which is easily fast enough.

## Files

- `main.py`: computes and prints the answer, and includes asserts for the sample values from the problem statement.
