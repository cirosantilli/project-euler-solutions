# Project Euler 774 Solution - Conjunctive Sequences

<https://projecteuler.net/problem=774>:

* [774.py](774.py)

where rows index `y_bit` and columns index `x_bit`.

For `m` bits:

- `B = R ⊗ R ⊗ ... ⊗ R`  (m times)

This is crucial: applying `B` to a vector over `{0,1}^m` becomes a *local per-bit transform*.

---

### 4) Use a Tensor-Train / Matrix Product State (MPS)
A vector of length `2^m` is stored as an MPS:

- `v(x) = G1[x1] · G2[x2] · ... · Gm[xm]`

Each core `Gi` is a small 3D tensor `(rank_left × 2 × rank_right)`.
This compresses huge vectors as long as the internal ranks remain moderate.

Operations needed:

- Apply Kronecker operator `B`: **local update** to each core.
- Add/subtract: block-diagonal rank merge.
- Elementwise multiply by a mask: rank-multiplying Hadamard product.

---

### 5) Encoding `x ≤ b` as a 2-state automaton (digit-DFA)
The set `{x : x ≤ b}` is a classic binary digit-DP automaton with states:

- **tight**: prefix equals `b`
- **loose**: prefix already smaller

This DFA is compiled directly into a rank-2 MPS (very compact).

---

### 6) Exact Rank Compression with Gaussian Elimination (mod prime)
After sum/product operations, ranks increase.
To keep computation feasible, we perform **exact** TT/MPS compression using
Gaussian elimination **over the finite field mod 998244353**:

- For each core, reshape into a matrix.
- Find independent columns via elimination.
- Rewrite dependent columns as linear combinations.
- Push those coefficients into the next core.

This keeps ranks near their true algebraic minimum without any floating-point SVD.

A further optimization is used:

- forward elimination to echelon form
- back elimination only among pivot rows
- sufficient to read coefficients needed for compression

---

## Why This Works Efficiently Here
- `b < 2^27`, so `m = 27` bits.
- The automaton mask stays small (rank ~2).
- The operator `B` is separable by bits (Kronecker).
- With exact compression each step, ranks stay manageable for `n=123`.

---

## Output
Running `main.py`:

- asserts the three given test values
- prints the required `c(123, 123456789) mod 998244353`

No final answer is hard-coded.
