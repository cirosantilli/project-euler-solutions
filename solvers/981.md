# Project Euler 981 Solution - Unknown Title

<https://projecteuler.net/problem=981>:

* [981.py](981.py)

# Neutral strings with fixed counts — main ideas

We start from the empty word and repeatedly apply one of:

- insert `xx` / `yy` / `zz`,
- replace `x→yz`, `y→zx`, `z→xy`,
- swap adjacent **different** letters.

A word is **neutral** if it can be produced in an **even** number of steps.

The task asks for a large modular sum of `N(X,Y,Z)`, where `N(X,Y,Z)` counts neutral words
containing exactly `X` copies of `x`, `Y` of `y`, `Z` of `z`.

## 1) A parity invariant via the quaternion group

Map letters into the quaternion group `Q8`:

- `x ↦ i`, `y ↦ j`, `z ↦ -k`.

With this choice:

- inserting `aa` multiplies the product by `a² = -1`,
- swapping different letters uses anti-commutation (`ab = -ba`),
- the replacement rules satisfy `yz = -x`, `zx = -y`, `xy = -z`.

So **each allowed step flips the sign** of the quaternion product.
Starting from the empty word (product `+1`), a word is neutral **iff its quaternion product is `+1`**.

Also, reachable count triples must satisfy `X≡Y≡Z (mod 2)` (inserts preserve parities, replacements flip all three).

## 2) Product reduces to inversion parity

The three mapped generators pairwise anti-commute, so for any word with fixed counts `(X,Y,Z)`:

`product(word) = (-1)^{inv(word)} · product(x^X y^Y z^Z)`

where `inv(word)` is the inversion number when sorting letters in the order `x<y<z`
(counting only pairs of **different** letters).

For `X≡Y≡Z (mod 2)`, the canonical product `product(x^X y^Y z^Z)` is always `±1`,
and its sign is simply:

`(+1)` if `(X//2 + Y//2 + Z//2)` is even, else `(-1)`.

Therefore, `N(X,Y,Z)` becomes:

- number of words with **even** inversions, or
- number with **odd** inversions,

depending on that canonical sign.

## 3) Counting even/odd inversions using q-multinomials at q = -1

The inversion generating function over multiset permutations is the Gaussian multinomial:

`Σ q^{inv(word)} = [n]!_q / ([X]!_q [Y]!_q [Z]!_q)`.

Let `T` be the total number of words (`q=1`) and `D = E−O` the even/odd difference (`q=-1`).
Then:

- `E = (T + D)/2`,
- `O = (T - D)/2`.

A key simplification is that the q-multinomial factors into q-binomials, and at `q=-1`:

`C(n,k)_{-1} = 0` if `n` is even and `k` is odd, otherwise `binom(n//2, k//2)`.

So:

`D = C(n, X)_{-1} · C(n-X, Y)_{-1}`

uses only ordinary binomial coefficients with halved parameters.

## 4) Efficient modular computation

All needed `n = X+Y+Z` are below the modulus, so factorials are invertible.
The implementation precomputes `fact` and `invfact` up to the maximum `n`,
then evaluates:

- multinomials `n!/(X!Y!Z!) (mod M)`,
- half-size binomials for the `q=-1` terms,

and combines them with a single division by `2 (mod M)`.

This yields an `O(88^3)` loop with `O(max_n)` precomputation.
