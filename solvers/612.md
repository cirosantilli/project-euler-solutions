# Project Euler 612 Solution - Friend Numbers

<https://projecteuler.net/problem=612>:

* [612.py](612.py)

Two numbers are **friend numbers** if their base‑10 representations share at least one digit.

We need:

- `f(n)`: number of pairs `(p, q)` with `1 ≤ p < q < n` that are friend numbers
- Output: `f(10^18) mod 1000267129`
- Given check: `f(100) = 1539`

## Key techniques

### 1) Digit set as a bitmask
Represent the set of digits used in a number by a 10‑bit mask:

- bit `d` is `1` iff digit `d` appears
- there are only `2^10 = 1024` possible masks

### 2) Count by complement (disjoint masks)
Two numbers **fail** to be friend numbers exactly when their digit masks are **disjoint**:

- friend pair ⇔ `(mask_a & mask_b) != 0`
- non‑friend pair ⇔ `(mask_a & mask_b) == 0`

So:

```
friend_pairs = total_pairs - disjoint_pairs
total_pairs  = (n-1 choose 2)
```

Once we know `count[mask] = #{ x < n : mask(x)=mask }`,
we can sum disjoint pairs by looping over all `(a, b)` with `a < b` and `(a & b) == 0`.

### 3) Digit DP to count masks up to a huge limit
To get `count[mask]` for all `x` in `1..(n-1)` where `n` is as large as `10^18`,
we use a classic **digit DP** over the decimal digits of `m = n-1`:

State:
- `mask`: digits used so far
- `started`: whether we've placed a non‑leading digit yet (to ignore leading zeros)
- `tight`: whether we are still equal to the prefix of `m`

Transitions:
- choose next digit `d` within the allowed limit (`0..9` or `0..current_digit` if tight)
- update `(started, tight, mask)` accordingly

At the end, sum counts over all states with `started = True` (exclude the number 0).

## Complexity

- Digit DP states: at most `1024 * 2 * 2 = 4096`
- Transitions: `~ (#digits) * states * 10` → about `18 * 4096 * 10 < 1e6`
- Disjoint‑pair summation: `~ 1024^2 / 2 ≈ 5.2e5` checks

This runs comfortably fast in pure Python without external libraries.
