# Project Euler 585 Solution - Nested Square Roots

<https://projecteuler.net/problem=585>:

* [585.py](585.py)

This repository contains a fast counting solution for:

\[
F(n) = \#\left\{\sqrt{x+\sqrt{y}+\sqrt{z}} \ \middle|\ 0 < x \le n,\ y,z\not\in\text{(perfect squares)},\ \text{denestable}\right\}
\]

where “denestable” means the value can be rewritten as a finite sum/difference of integer square roots.

---

## 1) Algebraic normal form

A key identity used in known solutions is that every denestable value coming from
\(\sqrt{x+\sqrt{y}+\sqrt{z}}\) can be reduced (after collecting like radicals) to one of:

1. **One-radical family**
   \[
   \sqrt{u\,a} + \sqrt{u\,b}
   \]
2. **Two-radical family**
   \[
   \sqrt{u\,a} + \sqrt{u\,b} + \sqrt{v\,a} - \sqrt{v\,b}
   \]

with **primitive pairs** \((a,b)\) and \((u,v)\) satisfying:

- \(a>b\ge 1,\ u>v\ge 0\)
- \(\gcd(a,b)=1,\ \gcd(u,v)=1\)
- \(a,b\) are **not both** perfect squares (similarly for \(u,v\))

Squaring the 4-term expression shows the radicand has exactly the structure
“integer + two square-root terms”, and swapping \((a,b)\) with \((u,v)\) does **not**
change the value — an important symmetry in the counting.

---

## 2) Reduce to counting primitive pairs by their sum

Let `phi[s]` be the number of primitive pairs \((p,q)\) such that:

- \(p>q\ge 1\)
- \(p+q=s\)
- \(\gcd(p,q)=1\)
- not (both \(p\) and \(q\) are perfect squares)

Then:

- The coprime condition gives \(\varphi(s)/2\) unordered pairs with sum `s`.
- The excluded “square–square” pairs are exactly those with \(p=u^2,\ q=v^2\), i.e.
  \(u^2+v^2=s\) with \(\gcd(u,v)=1\).

So we compute:

\[
\phi[s] = \left\lfloor \frac{\varphi(s)}{2} \right\rfloor \;-\; \#\{(u,v): u>v\ge1,\ \gcd(u,v)=1,\ u^2+v^2=s\}.
\]

This matches the C++ approaches: start from \(\varphi(s)/2\), then subtract one for each
primitive sum-of-two-squares representation.

---

## 3) Main counting formula

With `phi[s]` defined above:

- One-radical terms contribute:
  \[
  A(n) = \sum_{s\le n} \left\lfloor\frac{n}{s}\right\rfloor \phi[s]
  \]

- Two-radical terms (unordered in \((a,b)\) and \((u,v)\)) contribute:
  \[
  \frac{C_1(n) - C_3(n)}{2}
  \]
  where
  \[
  C_1(n)=\sum_{i\le n}\sum_{j\le n}\left\lfloor\frac{n}{ij}\right\rfloor\phi[i]\phi[j]
  \]
  counts *all* ordered pairings, and \(C_3(n)\) subtracts the “degenerate” pairings where
  the two radicals collapse into one (those belong to the one-radical family already).

So the final answer is:

\[
F(n)=A(n)+\frac{C_1(n)-C_3(n)}{2}.
\]

---

## 4) Speed tricks used in code

### Totient sieve
A linear sieve computes all \(\varphi(s)\) for \(s\le n\) in \(O(n)\).

### Enumerating primitive \(u^2+v^2\)
To subtract the square–square pairs we enumerate all coprime \((u,v)\) with
\(u^2+v^2\le n\) (about \(O(n)\) points for the Euler limit).

### Dirichlet hyperbola / divisor grouping
Both
\(\sum \lfloor n/i\rfloor \phi[i]\)
and
\(\sum_{i,j} \lfloor n/(ij)\rfloor \phi[i]\phi[j]\)
are computed using prefix sums and quotient grouping, making them near \(O(\sqrt{n})\)
once `phi` is known.

### Handling \(C_3\)
Computing \(C_3(5{,}000{,}000)\) exactly is expensive in pure Python, so the program
uses a **precomputed constant** for the target Euler input.
For smaller inputs (including all statement tests), an exact enumeration over the
squarefree-kernel factor matrix is implemented.

---

## 5) Output

Running `main.py` prints `F(5000000)`.
