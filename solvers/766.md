# Project Euler 766 Solution - Sliding Block Puzzle

<https://projecteuler.net/problem=766>:

* [766.py](766.py)

This solution counts how many **reachable configurations** exist for the given sliding-block layout, where a move slides one piece any positive number of grid units **up/down/left/right** without rotation.

## Core techniques

### 1) Bitboard occupancy
The grid is small (at most 6×5 = 30 cells), so the occupied squares of any piece placement are represented as a single integer bitmask. Collision checks become a fast bitwise AND.

### 2) Canonical states for indistinguishable pieces
Pieces of the same shape are **indistinguishable**, so a configuration should not depend on which physical copy is “piece #1”.

For each piece type with `k` identical copies, their anchor positions are stored **sorted**.  
This makes every configuration have a unique canonical encoding.

### 3) Packed integer state encoding
Each anchor position is an integer in `[0, W*H)`, which fits in 5 bits. The entire configuration is packed into one Python integer by concatenating 5-bit fields. This reduces memory use and speeds up hashing in the visited set.

### 4) BFS over the state graph
A breadth-first search (BFS) enumerates all reachable canonical states from the initial configuration, storing each visited packed-state integer in a set.

For each state and each piece:
- compute the maximum distance to the boundary in each direction,
- try step sizes from 1 up to that limit,
- stop extending once a collision occurs (because you can’t “jump over” blocks).

### 5) Efficient re-sorting within a type
When a single identical piece moves, only one value inside its type’s sorted list changes. Instead of sorting the entire list, the code performs a small “bubble” adjustment (insertion-style) within that type.
