# Project Euler 238 Solution - Infinite String Tour

<https://projecteuler.net/problem=238>:

* [238.py](238.py)

This solution relies on two key ideas:

## 1) Periodicity

The sequence is

* `s0 = 14025256`
* `s(n+1) = s(n)^2 mod 20300713`
* `w` is the infinite decimal digit string formed by concatenating `s0, s1, s2, ...`.

Because the modulus is finite, the `s(n)` sequence is purely periodic (after the start) and therefore the digit stream `w` is also periodic. Let

* `L` = number of digits in one full period of `w`
* `T` = sum of those `L` digits

Every time you extend a substring by exactly `L` digits, you add exactly `T` to its digit-sum.

### Consequence: `p(k)` is periodic in `k` with period `T`

Represent sums `k` by their residue `k mod T` (with residue `0` meaning `k = T`).

For a starting position whose prefix digit-sum is `S`, the possible digit-sums you can obtain by ending at some later position are exactly the residues

`(U - S) mod T`

where `U` ranges over all prefix sums that occur in the period.

If a residue is achievable from a start position, then the **smallest** achievable sum with that residue lies in `[1..T]`; adding whole periods generates all larger sums with the same residue. That means the earliest start for sums with residue `r` is the same for `r`, `r+T`, `r+2T`, ...

So:

*Compute `p(k)` only for `k = 1..T` and repeat it for all larger `k`.*

## 2) Bitset covering with circular shifts

Let `V` be the set of residues (mod `T`) that appear as prefix sums during one period. Build a bitset `present` of length `T`:

* bit `u` is `1` iff `u ∈ V`

If the prefix sum at a start position is `S`, then the set of achievable sums from that start (within one period) is exactly the **circular right shift** of `present` by `S`.

Now compute `p(k)` for all `k=1..T` by scanning starts in increasing order:

1. Maintain a bitset `unknown` of sums not yet assigned their `p(k)`.
2. For each start position `z`:
   * `new = unknown & rotated_present`
   * Every `1` bit in `new` has `p(k) = z` (this is the first time it becomes reachable).
   * Add `z * popcount(new)` to the running total and clear those bits from `unknown`.

Because `p(k)` is very small on average for this problem, `unknown` becomes empty after only a few dozen start positions, so the expensive bitset operations are performed only a small number of times.

## Implementation notes

* The solution stores the period digit stream as ASCII bytes (≈ 19 MB).
* `present` and `unknown` are Python `int` values used as big bitsets, taking advantage of fast C-level `&`, shifts, and `.bit_count()`.
* The problem’s check value is asserted:

  `sum_{k=1}^{1000} p(k) = 4742`.
