# Project Euler 417 Solution - Reciprocal Cycles II

<https://projecteuler.net/problem=417>:

* [417.py](417.py)

This solution computes:

\[
\sum_{3 \le n \le 100\,000\,000} L(n)
\]

where **L(n)** is the length of the recurring cycle of the decimal expansion of **1/n**, and **L(n)=0**
when `n` has no prime factors other than `2` and/or `5`.

---

## Key Techniques Used

### 1) Reduce to Multiplicative Order
Write:

\[
n = 2^a 5^b m \quad \text{with } \gcd(m,10)=1
\]

Then the decimal recurring cycle length is:

\[
L(n)=\operatorname{ord}_m(10)
\]

So only the “reduced denominator” `m` (coprime to 10) matters; factors of 2 and 5 only affect the
terminating prefix.

---

### 2) Count Multiples by `2^a * 5^b`
For each reduced denominator `m`, it contributes the same cycle length to every number:

\[
m \cdot 2^a \cdot 5^b \le N
\]

So we weight each `ord_m(10)` by:

\[
g\left(\left\lfloor \frac{N}{m} \right\rfloor\right)
\]

where `g(x)` counts how many values of `2^a*5^b` are ≤ x.
All such products are precomputed (only a few hundred values), and `g(x)` is computed via binary search.

---

### 3) Smallest Prime Factor Sieve (Odd Only)
Because all reduced denominators `m` are **odd and not divisible by 5**, we only sieve **odd numbers**,
halving memory.

We build an SPF table:

- `spf[i] = smallest prime factor of (2*i+1)`
- `spf[i] = 0` means `(2*i+1)` is prime

---

### 4) Fast Orders for Composite Numbers via LCM
For a composite reduced denominator:

\[
m = p^e \cdot r
\]

we use:

\[
\operatorname{ord}_m(10) = \mathrm{lcm}(\operatorname{ord}_{p^e}(10), \operatorname{ord}_r(10))
\]

Orders are computed in increasing `m`, so `ord_r(10)` is already known.

---

### 5) Prime Orders via Factorization of `p-1`
For prime `p`, the order divides `p-1`.
We factor `p-1` quickly using the SPF table, then shrink the candidate order by testing:

\[
10^{k/q} \equiv 1 \pmod p
\]

for each prime divisor `q` of `p-1`.

---

### 6) Prime Powers via Lifting
For powers `p^e`, the order can only stay the same or multiply by `p` when going from `p^{e-1}` to `p^e`.
We build these values once per small prime and cache them.

---

## Correctness Check (from statement)
The code asserts the given checksum:

\[
\sum_{3\le n\le 1,000,000} L(n) = 55535191115
\]

and also asserts the example cycle lengths:
- `L(6)=1`, `L(7)=6`, terminating examples yield `0`.

---

## Complexity Notes
- Memory: ~400MB (two `array('I')` tables of size ~50 million)
- Time: dominated by one pass over ~40 million reduced denominators plus prime-order computations.

---

## Final Output
Running `python3 main.py` prints the required sum for `N=100,000,000`.
