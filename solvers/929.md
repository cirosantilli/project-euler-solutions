# Project Euler 929 Solution - Odd-Run Compositions

<https://projecteuler.net/problem=929>:

* [929.py](929.py)

This solution computes \(F(10^5)\) modulo \(1111124111\) (a prime), where \(F(n)\) is the number of compositions of \(n\) such that **every maximal run of equal parts has odd length**.

## Key ideas

### 1) Turn “odd run length” into a run-generating function
A run of value \(v\) must have odd length: \(1,3,5,\dots\).  
So a single run contributes
\[
x^v + x^{3v} + x^{5v} + \cdots = \frac{x^v}{1-x^{2v}}.
\]

The only remaining constraint is that **adjacent runs must have different values**.

### 2) Eliminate the adjacency constraint with a last-run decomposition
Let \(T(x)=\sum_{n\ge 0}F(n)x^n\).  
If we append a new run of value \(v\), the previous composition must end with a run of value \(\ne v\).  
This leads to an identity of the form
\[
T(x)=1+T(x)\cdot S(x),
\]
where
\[
S(x)=\sum_{v\ge 1}\frac{x^v}{1+x^v-x^{2v}}.
\]
Hence
\[
T(x)=\frac{1}{1-S(x)}.
\]

### 3) Fibonacci expansion gives a fast divisor-sum formula
Write \(y=x^v\). Then
\[
\frac{y}{1+y-y^2} = \sum_{m\ge 1} (-1)^{m-1}\,F_m\, y^m,
\]
where \(F_m\) are Fibonacci numbers (\(F_1=F_2=1\)).

Therefore \(S(x)\) is a Lambert series and its coefficients satisfy:
\[
[x^n]S(x)=s[n]=\sum_{d\mid n} (-1)^{d-1}\,F_d.
\]
We compute all \(s[1..N]\) in \(O(N\log N)\) using a divisor sieve.

### 4) Power series inversion by Newton iteration
We need the coefficients of
\[
T(x)=\frac{1}{f(x)},\quad f(x)=1-S(x),\ f(0)=1.
\]
A standard Newton iteration doubles the number of correct coefficients each step:
\[
g \leftarrow g\,(2 - f g) \pmod{x^{2m}}.
\]
This reduces the task to repeated polynomial multiplications.

### 5) Fast polynomial multiplication via custom FFT (no libraries)
The code implements a complex FFT and performs convolution modulo `MOD` using **15-bit splitting**:
- represent each coefficient \(a\) as \(a = a_0 + a_1\cdot 2^{15}\),
- pack \((a_0, a_1)\) into a complex number \(a_0 + i a_1\),
- recover the needed sub-convolutions with two inverse FFTs,
- recombine and reduce modulo `MOD`.

This keeps intermediate floating-point values small enough for reliable rounding.

## Sanity check
The problem statement gives \(F(5)=10\). The program asserts this value before printing \(F(10^5)\bmod 1111124111\).
