# Project Euler 937 Solution - Equiproduct Partition

<https://projecteuler.net/problem=937>:

* [937.py](937.py)

This write‑up summarizes the core ideas used in `main.py`.

## 1) From the pair-count condition to a multiplicative sign function

Let the partition be encoded by a sign function

- `f(x) = +1` if `x ∈ A`
- `f(x) = -1` if `x ∈ B`

The condition `p(A, z) = p(B, z)` for every `z` can be rewritten as a divisor-style recurrence that uniquely determines `f` once `f(1)=+1` is fixed.

Because `Z[√-2]` is a unique factorization domain and its only units are `±1`, this recurrence forces `f` to be **multiplicative** (on coprime elements) and lets you reduce everything to prime powers.

## 2) Prime powers produce the Thue–Morse / bitcount-parity pattern

For a prime element `π` and exponent `e ≥ 0`, the recurrence implies a simple closed form:

- `f(π^e) = (-1)^{popcount(e)}`

So the contribution of a prime to `f(x)` depends only on the **parity of the number of 1-bits** in its exponent.

For a general factorization `x = ∏ π_i^{e_i}`:

- `f(x) = ∏ (-1)^{popcount(e_i)}`

and `x ∈ A` iff the product is `+1`.

## 3) Restricting to rational integers: only certain primes matter

In `Z[√-2]`, an odd rational prime `p` either

- **splits** into two conjugate primes, or
- stays **inert** (prime) in the ring.

For integers, split primes appear as `π^e · \bar{π}^e`, so their exponent contributions occur **twice** and cancel in the overall sign.

In this ring, the inert primes are exactly those with

- `p ≡ 5 or 7 (mod 8)`

and `2` is ramified (handled separately in code).

Therefore, for an integer `n`, membership in `A` depends only on the exponents of

- `2`, and
- primes `p` with `p % 8 ∈ {5, 7}`.

## 4) Applying it to factorials

To decide whether `k! ∈ A`, we need the exponents `v_p(k!)` for the relevant primes. Rather than recomputing them from scratch, the program walks `k = 1..n` and updates prime exponents using the factorization of `k`:

- `k! = (k-1)! · k`
- so each step adds `v_p(k)` to `v_p((k-1)!)`.

Whenever the **bitcount-parity** of an exponent changes, the overall membership flips.

At the same time, the running factorial modulo `1_000_000_007` is updated, and included in the sum precisely when the current `k!` lies in `A`.

## 5) Implementation techniques used

- **Odd-only SPF sieve (u16):**
  - Stores the smallest prime factor for every odd number up to `n`.
  - This makes per-`k` factorization fast and memory-feasible.

- **Custom open-addressing hash table:**
  - Stores exponent values only for the *relevant* odd primes (those `≡ 5,7 (mod 8)`), avoiding huge dense arrays.
  - Also stores the current `popcount(exponent) mod 2` to update the global parity in O(1).

- **Incremental modulo arithmetic:**
  - Maintains `k! mod MOD` and `G(n) mod MOD` with cheap reductions.

The included asserts in `main.py` validate the sample values from the problem statement.
