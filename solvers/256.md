# Project Euler 256 Solution - Tatami-Free Rooms

<https://projecteuler.net/problem=256>:

* [256.py](256.py)

This repository solves **Project Euler Problem 256: Tatami-Free Rooms**.

The problem defines `T(s)` as the number of integer rectangles `a × b` with
area `s` that are **tatami-free** (they cannot be tiled by 1×2 tatami without a
point where **four tile corners meet**). The task is to find the smallest `s`
for which `T(s) = 200`.

## Main techniques used

### 1) Constant-time tatami-free test (Olson inequality)

For `a ≤ b`, define:

- `q = b // a`

A rectangle `a × b` is **tatami-free** iff:

```
(a + 1) * q + 2 ≤ b ≤ (a - 1) * (q + 1) - 2
```

This replaces any expensive tiling search with a few integer operations.

### 2) Computing T(s) by enumerating factor pairs

To compute `T(s)` directly:

- iterate `a` from `1` to `isqrt(s)`
- if `a` divides `s`, set `b = s // a`
- count `(a, b)` when `a ≤ b` and the inequality above holds

This is used for small checks and for validating the examples.

### 3) Searching for the smallest s with T(s) = N via prime-factor DFS

Brute forcing `s` upward is far too slow. Instead, the solver enumerates
candidate `s` by recursively building **prime factorizations**:

- start from `s = 2` (all tatami-free rooms have even area)
- at each step either:
  1) increase the exponent of the current prime, or
  2) introduce a new larger prime factor

This generates many “highly composite” candidates early, which is exactly what
you want when `T(s)` needs to be large (e.g., 200).

### 4) Pruning with a fast divisor-pair upper bound (“sigma”)

Computing `T(s)` from scratch for every candidate would still be too slow.
The solver uses a cheap upper bound (matching Eric Olson’s reference approach)
to decide whether it’s even worth computing `T(s)`:

For the factorization:

```
s = 2^e0 * p1^e1 * p2^e2 * ...
```

use:

```
sigma = e0 * Π (ei + 1)   for i ≥ 1
```

If `sigma < N`, then `T(s) = N` is impossible at that node, so the expensive
evaluation is skipped.

### 5) Computing T(s) from the factorization without refactoring

When the bound is large enough, `T(s)` is computed by iterating over exponent
split vectors `z` that represent a divisor:

- `k = Π p_i^(z_i)`
- `l = Π p_i^(e_i - z_i)`  so that `k * l = s`

Count the pair when `k ≤ l` and the tatami-free inequality holds.

To make this fast, prime powers `p^0 .. p^e` are precomputed once per evaluation
and reused in the loop.

### 6) Prime precomputation

The search needs many primes; the first ~1300 primes are generated once via a
small sieve (1300th prime is 10657).

## Included correctness checks

The code asserts the problem statement examples:

- `T(70) = 1` and the only tatami-free rectangle is `7 × 10`
- `T(1320) = 5` and the tatami-free rectangles are:
  `20×66, 22×60, 24×55, 30×44, 33×40`
- the smallest `s` with `T(s)=5` is `1320`

## Run

```bash
python main.py
```

It prints the smallest `s` with `T(s)=200`.
