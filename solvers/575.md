# Project Euler 575 Solution - Wandering Robots

<https://projecteuler.net/problem=575>:

* [575.py](575.py)

## Key idea

After an “unfathomably long time”, Leonhard’s location follows the **stationary distribution** of a finite Markov chain on an `n × n` grid (with moves to the 4-neighborhood and possibly staying put). The final answer is the average of two possible programs (coin flip).

## Technique 1: Stationary distribution by detailed balance

Both movement rules define a **reversible random walk** on an undirected grid graph:

- **Rule (i)**: choose uniformly among `{stay}` plus all adjacent rooms.  
  If a cell has `k` exits, every option has probability `1/(k+1)`.

  This is the “choose a random incident edge” walk on a graph where each vertex has **one self-loop**.  
  The stationary weight is proportional to `k+1`.

- **Rule (ii)**: stay with probability `1/2`, otherwise choose a random adjacent room.  
  This is a **lazy** version of the simple random walk. Laziness does not change the stationary distribution.  
  The stationary weight is proportional to `k`.

On an `n × n` grid, cells have `k = 4` (interior), `k = 3` (edge), `k = 2` (corner), so each stationary distribution only depends on these three classes.

## Technique 2: Reduce the 1,000,000-state problem to counting

We only need:

1. The **total stationary weight** of all interior/edge/corner cells (closed forms).
2. How many **perfect-square room numbers** land in each class.

A room number `x` maps to coordinates `(r, c)` by row-major indexing:

- `r = (x−1)//n + 1`
- `c = (x−1)%n + 1`

Perfect squares are `1², 2², …, n²`, so we just iterate `s = 1..n` (only 1000 iterations for the real task) and classify each square cell as interior/edge/corner.

## Technique 3: Exact rational arithmetic + rounding

All probabilities are rational numbers with small integer weights, so we keep everything as `(numerator, denominator)` pairs, reduce by `gcd`, and only at the end format the result to **12 decimal places** using integer rounding (half-up).

## Output

`main.py` prints the requested probability for the `1000 × 1000` grid, rounded to 12 decimal places, and includes an `assert` for the sample value:

- `solve(5) == 0.177976190476`
