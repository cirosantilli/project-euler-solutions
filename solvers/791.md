# Project Euler 791 Solution - Average and Variance

<https://projecteuler.net/problem=791>:

* [791.py](791.py)

This solution turns the “average equals twice the variance” condition into a **lattice-point summation** that can be computed in about `O(n)`-ish time with tight constant factors (in practice: `O(R^2)` where `R ≈ √(2n)`).

## 1) Algebraic reduction

For a quadruple `(a,b,c,d)`, let:

- `t = a+b+c+d`
- `s2 = a²+b²+c²+d²`

The condition **mean = 2·variance** becomes, after simplification:

- `t` must be even: `t = 2m`
- `s2 = m(m+1)`

So every valid quadruple has:

- `a+b+c+d = 2m`
- `a²+b²+c²+d² = m(m+1)`

and its contribution to `S(n)` is simply `2m`.

## 2) Centering and a Hadamard-type transform

Define “centered” variables:

- `x_i = 2a_i - m`  (so `a_i = (m + x_i)/2`)

Then the constraints become:

- `x1+x2+x3+x4 = 0`
- `x1²+x2²+x3²+x4² = 4m`

A key trick is to parametrize all integer 4-tuples with sum `0` using a 4×3 Hadamard-style map:

```
x1 =  u + v + w
x2 =  u - v - w
x3 = -u + v - w
x4 = -u - v + w
```

This mapping is **bijective** on the relevant integer lattice (you can recover `u,v,w` from `(x1,x2,x3,x4)`), and it diagonalizes the quadratic form:

- `x1²+x2²+x3²+x4² = 4(u²+v²+w²)`

Therefore:

- `m = u²+v²+w²`

and each solution contributes `2m = 2(u²+v²+w²)`.

## 3) Encoding sorting constraints as inequalities

Because `a_i = (m + x_i)/2`, the ordering

`a ≤ b ≤ c ≤ d`

is equivalent to

`x1 ≤ x2 ≤ x3 ≤ x4`.

Translating the differences `x2-x1`, `x3-x2`, `x4-x3` into `(u,v,w)` yields simple inequalities.
After a convenient sign change (`U=-u`, `V=-v`) and splitting by the sign of `w`, we get a clean chain:

- `U ≥ V ≥ W ≥ 0`, where `W = |w|`
- `w = ±W` (two choices unless `W=0`)

This takes care of **unique counting** under the `a≤b≤c≤d` requirement.

## 4) Applying the bound `d ≤ n`

In these variables:

- `m = U²+V²+W²`
- `d = (m + U + V ± W)/2`

So `d ≤ n` becomes:

- `U²+V²+W² + U + V ± W ≤ 2n`

For fixed `U` and `W` (and a chosen sign), this is a **quadratic inequality in `V`**:

- `V² + V + C ≤ 0`

which implies `V` is in a contiguous range `[W .. Vmax]`.

## 5) Summing without iterating over `V`

For each `(U,W,sign)`, we need:

\[
\sum_{V=W}^{V_{\max}} 2(U^2+V^2+W^2)
\]

This is computed using:

- count of terms
- a prefix table for `∑V²`

Additionally, many `(U,W)` pairs allow the full range `V=W..U`, and those are summed in bulk using precomputed prefix sums of:

- `∑W`, `∑W²`, `∑W³`
- and “prefix-of-prefix” for `∑ s2[W-1]`

This keeps the inner work low and avoids enumerating all triples.

## 6) Practical implementation details

- Only `math.isqrt` and integer arithmetic are used.
- For the final computation, we reduce modulo `433494437` with **periodic reduction** to avoid expensive `%` on every tiny addition.
- The asserts included match the problem’s given test values.

Run:

```bash
python3 main.py
```

It prints `S(10^8) mod 433494437`.
