# Project Euler 733 Solution - Ascending Subsequences

<https://projecteuler.net/problem=733>:

* [733.py](733.py)

This solution computes:

- `a_i = 153^i mod 10,000,019` for `i ≥ 1`
- `S(n)`: the total **sum of the terms** over all **strictly increasing subsequences of length 4**
  chosen from the first `n` terms of `a_i`
- the required output is `S(10^6) mod 1,000,000,007`

## Key techniques used

### 1) Dynamic programming on increasing subsequences
For each position `i` with value `x = a_i`, we build increasing subsequences ending at `i`:

- length 1: `(x)`
- length 2: append `x` to any length-1 subsequence ending with a smaller value
- length 3: append `x` to any length-2 subsequence ending with a smaller value
- length 4: append `x` to any length-3 subsequence ending with a smaller value

For each length `L`, we track two quantities:

- `count_L`: number of increasing subsequences of length `L`
- `sum_L`: total sum of terms across all those subsequences (each subsequence contributes the sum of its elements)

Appending `x` to all length-`(L-1)` subsequences contributes:

- `count_L += count_{L-1}`
- `sum_L += sum_{L-1} + count_{L-1} * x`

The final answer is the sum of `sum_4` over all endpoints, taken modulo `1,000,000,007`.

### 2) Fenwick trees (Binary Indexed Trees) for prefix aggregation
The recurrence needs fast queries of:

> “all previous subsequences whose last value is `< x`”.

By coordinate-compressing values to ranks `1..m`, we can maintain Fenwick trees keyed by rank and query
prefix sums in `O(log m)` time.

We keep three Fenwick trees (for lengths 1, 2, and 3). Each stores:

- the total `count_L` ending at each value
- the total `sum_L` ending at each value

### 3) Packing two accumulators into one 64-bit Fenwick tree
To reduce the constant factor, each Fenwick node stores **both** `count` and `sum` packed into a single
unsigned 64-bit integer:

- high 32 bits: `count (mod M)`
- low 32 bits:  `sum (mod M)`

This halves the number of Fenwick traversals compared to maintaining separate trees for counts and sums.

### 4) Built-in test asserts from the statement
The implementation includes asserts for:

- `S(6) = 94513710`
- `S(100) = 4465488724217`

These are computed exactly (without modulus) using the same DP idea on a small `n`.

## Running

```bash
python3 main.py
```

It prints the required value (and nothing else).
