# Project Euler 860 Solution - Gold and Silver Coin Game

<https://projecteuler.net/problem=860>:

* [860.py](860.py)

## Key idea: each stack is a tiny partizan game

A single stack has height 2, and each coin is either **Gold** (removable by Gary) or **Silver** (removable by Sally).
A move removes a coin of your color and anything above it, so stacks never interact except by “taking your turn in one stack”.
That means the whole position is a **disjunctive sum** of independent stack-games.

For height 2 there are only 4 stack types (bottom, top):

- **GG**: Gold over Gold  
- **SS**: Silver over Silver  
- **GS**: Silver on top of Gold  
- **SG**: Gold on top of Silver

Under normal-play combinatorial game theory, each of these is a **number game**:

- `GG = 2`, `SS = -2`
- `GS = 1/2`, `SG = -1/2`

(Example: `GS` has Left option to `0` and Right option to `1`, so its value is `{0 | 1} = 1/2`.)

## Fairness ⇔ total value is zero

A position is **fair** if the *first player loses* no matter whether the first mover is Gold or Silver.
For number games, that happens **exactly when the total value is 0**.

So the problem becomes:

> Count sequences of `n` stack-values from `{2, -2, 1/2, -1/2}` whose sum is `0`.

Multiplying by `2` removes fractions; each stack contributes one of the integers `{+4, -4, +1, -1}` and we need the total sum to be `0`.

## Counting with binomials

Let:
- `t` = how many `±4` steps are used,
- `s = n - t` = how many `±1` steps are used,
- `m` = net balance among the `±4` steps (`m = #(+4) - #(-4)`).

Then the `±1` steps must have net balance `-4m` to make the overall sum `0`.

For fixed `(t, m)` the number of sequences is:

- choose which positions are `±4`: `C(n, t)`
- choose signs among the `±4`: `C(t, (t+m)/2)`
- choose signs among the `±1`: `C(s, (s-4m)/2)`

Summing over all valid `t` and `m` gives `F(n)`.

Because the range of `m` is symmetric, we sum `m ≥ 0` and double the `m > 0` contributions.

## Modular arithmetic

We only need results modulo `989898989`, and `n = 9898` is small enough to precompute factorials:

- `fac[i] = i! mod M`
- `inv_fac[i] = (i!)^{-1} mod M` (using the extended Euclidean algorithm)

Then each binomial coefficient is:

`C(n, k) = fac[n] * inv_fac[k] * inv_fac[n-k] mod M`.

## Complexity

The `(t, m)` summation has about `O(n^2)` valid pairs but with a small constant (roughly `~ n^2 / 10` after symmetry),
so it runs comfortably fast in pure Python.
