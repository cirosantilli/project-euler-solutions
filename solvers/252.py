#!/usr/bin/env python3
"""
Project Euler 252: Convex Holes

A convex hole is a convex polygon whose vertices are among a given set of points,
and which contains no other given point in its *interior* (points on the boundary
are allowed).

We compute the maximum possible area for the first 500 points generated by the
PRNG specified in the problem.

Key techniques:
- Precompute strict left-of-halfplane sets for every directed edge using bitsets
  (Python integers).
- Triangle emptiness test via intersection of three bitsets.
- Dynamic programming over chains (fan triangulation from the polygon's unique
  lowest vertex) using only *empty triangles* as edges, plus convexity checks.
- Additional constraint: internal fan diagonals must not contain any point in
  their open segment (points on polygon boundary are allowed, but not on internal
  diagonals).
"""

from __future__ import annotations

import math
from collections import defaultdict
from typing import List, Tuple


Point = Tuple[int, int]


def generate_points(n: int) -> List[Point]:
    """Generate the first n points from the PRNG in the problem statement."""
    MOD = 50515093
    s = 290797
    T = []
    for _ in range(2 * n):
        s = (s * s) % MOD
        T.append(s % 2000 - 1000)
    return [(T[2 * i], T[2 * i + 1]) for i in range(n)]


def build_left_bitsets(points: List[Point]) -> List[List[int]]:
    """
    For each ordered pair (u,v), compute a bitset of all points strictly to the
    left of the directed line u -> v.

    Uses angular sorting around each u and a rotating calipers / sliding window
    method. Important subtlety: collinear points on the SAME RAY as u->v must NOT
    terminate the window (they are not strictly left, but angle difference is 0),
    otherwise left-sets are wrong and the final answer is overestimated.
    """
    n = len(points)
    xs = [p[0] for p in points]
    ys = [p[1] for p in points]

    left = [[0] * n for _ in range(n)]

    for u in range(n):
        x_u = xs[u]
        y_u = ys[u]

        # Sort other points by angle around u, tiebreak by distance
        order = [i for i in range(n) if i != u]
        order.sort(
            key=lambda i: (
                math.atan2(ys[i] - y_u, xs[i] - x_u),
                (xs[i] - x_u) * (xs[i] - x_u) + (ys[i] - y_u) * (ys[i] - y_u),
            )
        )

        m = len(order)
        order2 = order + order

        j = 1
        window = 0  # bitset of indices in (i, j)

        for i in range(m):
            if j < i + 1:
                j = i + 1
                window = 0

            v = order2[i]
            vx = xs[v] - x_u
            vy = ys[v] - y_u

            while j < i + m:
                w = order2[j]
                wx = xs[w] - x_u
                wy = ys[w] - y_u

                c = vx * wy - vy * wx
                if c > 0:
                    window |= 1 << w
                    j += 1
                    continue

                # Collinear on same ray (angle diff 0): skip but do not include
                if c == 0 and vx * wx + vy * wy > 0:
                    j += 1
                    continue

                break

            left[u][v] = window
            out = order2[i + 1]
            window &= ~(1 << out)

    return left


def build_segment_clear(points: List[Point]) -> List[List[bool]]:
    """
    segment_clear[a][b] is True iff the OPEN segment a->b contains no other point.

    Computed by grouping points by reduced direction from each anchor and sorting
    by distance along that ray: only the nearest point in each direction yields a
    clear segment.
    """
    n = len(points)
    xs = [p[0] for p in points]
    ys = [p[1] for p in points]

    clear = [[True] * n for _ in range(n)]
    for i in range(n):
        clear[i][i] = False

    for a in range(n):
        x_a = xs[a]
        y_a = ys[a]
        dirs = defaultdict(list)

        for b in range(n):
            if b == a:
                continue
            dx = xs[b] - x_a
            dy = ys[b] - y_a
            g = math.gcd(dx, dy)
            dx //= g
            dy //= g
            dist = (xs[b] - x_a) * (xs[b] - x_a) + (ys[b] - y_a) * (ys[b] - y_a)
            dirs[(dx, dy)].append((dist, b))

        for lst in dirs.values():
            lst.sort()
            # Only closest is clear; any further has a point in between
            for idx, (_, b) in enumerate(lst):
                if idx > 0:
                    clear[a][b] = False

    return clear


def max_convex_hole_area(points: List[Point]) -> float:
    """
    Compute the maximum area convex hole (boundary points allowed; interior empty).
    Returns area as float (will be integer or half-integer).
    """
    n = len(points)
    xs = [p[0] for p in points]
    ys = [p[1] for p in points]

    left = build_left_bitsets(points)
    seg_clear = build_segment_clear(points)

    best2 = 0  # store DOUBLE area as integer

    for s in range(n):
        x_s = xs[s]
        y_s = ys[s]

        # Ensure s is the unique lowest vertex of the polygon (lex tie handled)
        cand = [
            i
            for i in range(n)
            if i != s and (ys[i] > y_s or (ys[i] == y_s and xs[i] > x_s))
        ]
        if len(cand) < 2:
            continue

        # Sort candidates by polar angle around s; tiebreak by distance
        cand.sort(
            key=lambda i: (
                math.atan2(ys[i] - y_s, xs[i] - x_s),
                (xs[i] - x_s) * (xs[i] - x_s) + (ys[i] - y_s) * (ys[i] - y_s),
            )
        )
        m = len(cand)

        # succ[a] = list of (b, weight) edges a->b for which triangle (s, a, b) is empty
        succ: List[List[Tuple[int, int]]] = [[] for _ in range(m)]

        # Build empty-triangle edges from s
        for ai in range(m - 1):
            a = cand[ai]
            la = left[s][a]
            ax = xs[a] - x_s
            ay = ys[a] - y_s
            for bi in range(ai + 1, m):
                b = cand[bi]
                # CCW check for triangle (s,a,b)
                c = ax * (ys[b] - y_s) - ay * (xs[b] - x_s)
                if c <= 0:
                    continue
                # Empty interior check via bitsets
                if (la & left[a][b] & left[b][s]) != 0:
                    continue
                succ[ai].append((bi, c))

        # DP: dp[j] maps prev_index -> best double-area for chain ending prev->j
        dp: List[dict[int, int]] = [dict() for _ in range(m)]

        # Initialize with triangles s->i->j
        for i in range(m - 1):
            for j, w in succ[i]:
                prev_best = dp[j].get(i)
                if prev_best is None or w > prev_best:
                    dp[j][i] = w

        # Process in topological order of indices (angles increase => DAG)
        for curr in range(m):
            c_idx = cand[curr]
            x_c = xs[c_idx]
            y_c = ys[c_idx]

            # Consider closing polygon at curr (edge curr -> s)
            for prev, val in dp[curr].items():
                p_idx = cand[prev]
                # Convexity at curr for closure: prev -> curr -> s is left turn
                if (x_c - xs[p_idx]) * (y_s - y_c) - (y_c - ys[p_idx]) * (
                    x_s - x_c
                ) > 0:
                    if val > best2:
                        best2 = val

            # If diagonal s->curr is not clear, curr cannot become an internal vertex,
            # but we may still close here (handled above).
            if not seg_clear[s][c_idx]:
                continue

            # Extend chains: prev -> curr -> nxt
            for prev, val in dp[curr].items():
                p_idx = cand[prev]
                x_p = xs[p_idx]
                y_p = ys[p_idx]
                for nxt, w in succ[curr]:
                    n_idx = cand[nxt]
                    x_n = xs[n_idx]
                    y_n = ys[n_idx]

                    # Convexity at curr: prev -> curr -> nxt must be left turn
                    if (x_c - x_p) * (y_n - y_c) - (y_c - y_p) * (x_n - x_c) <= 0:
                        continue

                    nv = val + w
                    old = dp[nxt].get(curr)
                    if old is None or nv > old:
                        dp[nxt][curr] = nv

    return best2 / 2.0


def solve(n: int = 500) -> float:
    return max_convex_hole_area(generate_points(n))


def main() -> None:
    # Assert the example given in the problem statement
    assert abs(solve(20) - 1049694.5) < 1e-9

    ans = solve(500)
    print(f"{ans:.1f}")


if __name__ == "__main__":
    main()
