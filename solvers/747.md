# Project Euler 747 Solution - Triangular Pizza

<https://projecteuler.net/problem=747>:

* [747.py](747.py)

This solution counts **all valid cut configurations for every** `n` from `3` up to `m`, and returns the cumulative total `Ψ(m)` (modulo `1_000_000_007` for the final target `m = 10^8`).

## Core ideas

### 1) Split into “easy” and “hard” skeletons
Every configuration has an interior point `P` where all cut segments meet.

There are two broad structural situations:

- **Easy skeletons:** every corner is “touched” by a cut from `P`, or (equivalently) at most a very restricted collinearity case occurs.  
  These configurations reduce to distributing the `n` equal-area triangles among a small number of larger triangles determined by the skeleton.  
  The cumulative count for these cases is a simple polynomial in `m`.

- **Hard skeleton:** **exactly one** corner is not directly connected to `P`.  
  In that case, the cuts around that corner must align in a very constrained way, and counting depends on a quadratic condition.

The final result is:
- `Ψ(m) = Easy(m) + 3 * Hard(m)`  
  The factor `3` corresponds to choosing which corner is the “uncut” corner.

### 2) Closed form for the easy part
For each `n`:
- One family contributes `C(n-1, 2)`
- Another contributes `6(n-2)`

Summing over `n = 3..m` yields the exact closed form:
\[
Easy(m)=\frac{m^3 + 15m^2 - 52m + 36}{6}.
\]

### 3) The hard part becomes a “threshold then arithmetic tail”
Fix which corner is uncut. Let `x` and `y` be the numbers of equal-area triangles based along the two adjacent sides (both positive integers).  
For each pair `(x,y)`:

- There is a **smallest** `n_min(x,y)` for which a valid configuration exists.
- For every larger `n`, configurations continue to exist.

The derivation leads to:
\[
n_{min} = 2xy + x + y + 1 + \lceil 2\sqrt{x y (x+1)(y+1)}\rceil.
\]

If `x y (x+1)(y+1)` is a perfect square, the first valid `n` yields **one** configuration; otherwise it yields **two**. For all larger `n`, it yields **two**.

So the contribution of a fixed `(x,y)` up to `m` is:
- `0` if `n_min > m`
- otherwise `2*(m - n_min + 1) - [square]`

### 4) Symmetry and integer square roots
The hard expression is symmetric in `(x,y)`, so the code sums only over `x <= y` and doubles the off-diagonal pairs.

All square-root boundaries are handled with **exact integer arithmetic** using `math.isqrt`, including the ceiling term via `isqrt(4D)`.

### 5) Incremental updates inside loops
For fixed `x`, as `y` increases:
- `y(y+1)` can be updated by an `O(1)` recurrence
- `2xy` increases by a constant step

This reduces per-iteration overhead.

## Tests
The file `main.py` includes assertions for the sample values given in the statement:
- `ψ(3) = 7`
- `ψ(6) = 34`
- `ψ(10) = 90`
- `Ψ(10) = 345`
- `Ψ(1000) = 172166601`

## Output
Running `main.py` prints `Ψ(10^8) mod 1_000_000_007`.
